local lua_name = "t a b s e n s e"
local lua_color = {r = 222, g = 195, b = 195}
local data = obex_fetch and obex_fetch() or {username = 'wyscigufa9', build = 'Source', discord=''}
X,Y = client.screen_size()

local lua_banner = [[                                                                                                                                                                                                                                    
]]

local function try_require(module, msg)
    local success, result = pcall(require, module)
    if success then return result else return error(msg) end
end

local pui = require("gamesense/pui")

local images = try_require("gamesense/images", "Download images library: https://gamesense.pub/forums/viewtopic.php?id=22917")
local bit = try_require("bit")
local base64 = try_require("gamesense/base64", "Download base64 encode/decode library: https://gamesense.pub/forums/viewtopic.php?id=21619")
local antiaim_funcs = try_require("gamesense/antiaim_funcs", "Download anti-aim functions library: https://gamesense.pub/forums/viewtopic.php?id=29665")
local ffi = try_require("ffi", "Failed to require FFI, please make sure Allow unsafe scripts is enabled!")
local vector = try_require("vector", "Missing vector")
local http = try_require("gamesense/http", "Download HTTP library: https://gamesense.pub/forums/viewtopic.php?id=21619")
local clipboard = try_require("gamesense/clipboard", "Download Clipboard library: https://gamesense.pub/forums/viewtopic.php?id=28678")
local ent = try_require("gamesense/entity", "Download Entity Object library: https://gamesense.pub/forums/viewtopic.php?id=27529")
local csgo_weapons = try_require("gamesense/csgo_weapons", "Download CS:GO weapon data library: https://gamesense.pub/forums/viewtopic.php?id=18807")
local ent = try_require("gamesense/entity")
local steamworks = try_require("gamesense/steamworks") or error('Missing https://gamesense.pub/forums/viewtopic.php?id=26526')

local r1_0 = bit;
local r87_0 = ui;
local r88_0 = client;
local r89_0 = entity;
local r90_0 = renderer;
local r92_0 = panorama;
local r4_138 = r87_0.new_combobox;
local r5_138 = r87_0.new_checkbox;
local r6_138 = r87_0.new_multiselect;
local r7_138 = r87_0.new_label;
local r8_138 = r87_0.new_color_picker;
local r35_138 = require("gamesense/entity") or error("Failed to load entity | https://gamesense.pub/forums/viewtopic.php?id=27529");

local crr_t = ffi.typeof('void*(__thiscall*)(void*)')
local cr_t = ffi.typeof('void*(__thiscall*)(void*)')
local gm_t = ffi.typeof('const void*(__thiscall*)(void*)')
local gsa_t = ffi.typeof('int(__fastcall*)(void*, void*, int)')


local var_table = {};
    
local prev_simulation_time = 0

local function time_to_ticks(t)
    return math.floor(0.5 + (t / globals.tickinterval()))
end
local diff_sim = 0

function var_table:sim_diff() 
    local current_simulation_time = time_to_ticks(entity.get_prop(entity.get_local_player(), "m_flSimulationTime"))
    local diff = current_simulation_time - prev_simulation_time
    prev_simulation_time = current_simulation_time
    diff_sim = diff
    return diff_sim
end

local login = {
    username = data.username,
    version = "1.0.0",
    build = data.build,
}

if not LPH_OBFUSCATED then
    LPH_NO_VIRTUALIZE = function (...)
        return ...;
    end
end

debug_x, debug_y = 30, Y / 2

local function intersect(x, y, width, height)
    local cx, cy = ui.mouse_position()
    return cx >= x and cx <= x + width and cy >= y and cy <= y + height
end

local new_class = function()
	local mt, mt_data, this_mt = { }, { }, { }

	mt.__metatable = false
	mt_data.struct = function(self, name)
		assert(type(name) == 'string', 'invalid class name')
		assert(rawget(self, name) == nil, 'cannot overwrite subclass')

		return function(data)
			assert(type(data) == 'table', 'invalid class data')
			rawset(self, name, setmetatable(data, {
				__metatable = false,
				__index = function(self, key)
					return
						rawget(mt, key) or
						rawget(this_mt, key)
				end
			}))

			return this_mt
		end
	end

	this_mt = setmetatable(mt_data, mt)

	return this_mt
end

local function normalize_yaw1(yaws)
    while yaws > 180 do
        yaws = yaws - 360
    end
    while yaws < -180 do
        yaws = yaws + 360
    end
    return yaws
end


local color = {}
color.__index = color

function color.new(r, g, b, a)
    local self = setmetatable({}, color)

    self.r = r or 255
    self.g = g or 255
    self.b = b or 255
    self.a = a or 255

    return self
end

color.__add = function(a, b)
    return color.new(a.r + b.r, a.g + b.g, a.b + b.b, a.a + b.a)
end

color.__sub = function(a, b)
    return color.new(a.r - b.r, a.g - b.g, a.b - b.b, a.a - b.a)
end

color.__mul = function(a, b)
    return color.new(a.r * b.r, a.g * b.g, a.b * b.b, a.a * b.a)
end

color.__div = function(a, b)
    return color.new(a.r / b.r, a.g / b.g, a.b / b.b, a.a / b.a)
end

color.__eq = function(a, b)
    return a.r == b.r and a.g == b.g and a.b == b.b and a.a == b.a
end

color.__tostring = function(self)
    return string.format("color(%d, %d, %d, %d)", self.r, self.g, self.b, self.a)
end

function color:table()
    return { self.r, self.g, self.b, self.a }
end

function color:hex()
    return string.format("%02x%02x%02x%02x", self.r, self.g, self.b, self.a)
end

function color:unpack()
    return self.r, self.g, self.b, self.a
end

function color:lerp(color, amount)
    local r = self.r + (color.r - self.r) * amount
    local g = self.g + (color.g - self.g) * amount
    local b = self.b + (color.b - self.b) * amount
    local a = self.a + (color.a - self.a) * amount

    return color.new(r, g, b, a)
end

if login.build == 'User' then
    login.build = 'Live'
end

local x, o = '\x14\x14\x14\xFF', '\x0c\x0c\x0c\xFF'

local pattern = table.concat{
    x,x,o,x,
    o,x,o,x,
    o,x,x,x,
    o,x,o,x
  }

  local logo = images.load(base64.decode("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"))


local tex_id = renderer.load_rgba(pattern, 4, 4)

local ui_menu = {
    tabs_names = {"","","",""},

    selected_tab = 1,
    selected_color = { {20, 20, 20, 255}, {210,210,210,255} },
    menu_alpha = 255,
    is_hovered = false,
    dpi_scaling_y = {{84,149},{100,181},{116,213},{132,245},{148,276}},
    pesadelo_na_cozinha2 = {597,741,885,1030,1173 },
    selected_gs_tab = false,
    mouse_press = false,
    old_mpos = {0,0}
}

local function lerp(a, b, t)
    return a + (b - a) * t
end

local script = {}

script.renderer = {
    rec = function(self, x, y, w, h, radius, color)
         radius = math.min(x/2, y/2, radius)
         local r, g, b, a = unpack(color)
         renderer.rectangle(x, y + radius, w, h - radius*2, r, g, b, a)
         renderer.rectangle(x + radius, y, w - radius*2, radius, r, g, b, a)
         renderer.rectangle(x + radius, y + h - radius, w - radius*2, radius, r, g, b, a)
         renderer.circle(x + radius, y + radius, r, g, b, a, radius, 180, 0.25)
         renderer.circle(x - radius + w, y + radius, r, g, b, a, radius, 90, 0.25)
         renderer.circle(x - radius + w, y - radius + h, r, g, b, a, radius, 0, 0.25)
         renderer.circle(x + radius, y - radius + h, r, g, b, a, radius, -90, 0.25)
     end,
 
     rec_outline = function(self, x, y, w, h, radius, thickness, color)
         radius = math.min(w/2, h/2, radius)
         local r, g, b, a = unpack(color)
         if radius == 1 then
             renderer.rectangle(x, y, w, thickness, r, g, b, a)
             renderer.rectangle(x, y + h - thickness, w , thickness, r, g, b, a)
         else
             renderer.rectangle(x + radius, y, w - radius*2, thickness, r, g, b, a)
             renderer.rectangle(x + radius, y + h - thickness, w - radius*2, thickness, r, g, b, a)
             renderer.rectangle(x, y + radius, thickness, h - radius*2, r, g, b, a)
             renderer.rectangle(x + w - thickness, y + radius, thickness, h - radius*2, r, g, b, a)
             renderer.circle_outline(x + radius, y + radius, r, g, b, a, radius, 180, 0.25, thickness)
             renderer.circle_outline(x + radius, y + h - radius, r, g, b, a, radius, 90, 0.25, thickness)
             renderer.circle_outline(x + w - radius, y + radius, r, g, b, a, radius, -90, 0.25, thickness)
             renderer.circle_outline(x + w - radius, y + h - radius, r, g, b, a, radius, 0, 0.25, thickness)
         end
     end,
 
     glow_module = function(self, x, y, w, h, width, rounding, accent, accent_inner)
         local thickness = 1
         local offset = 1
         local r, g, b, a = unpack(accent)
         if accent_inner then
             self:rec(x , y, w, h + 1, rounding, accent_inner)
         end
         for k = 0, width do
             if a * (k/width)^(1) > 5 then
                 local accent = {r, g, b, a * (k/width)^(2)}
                 self:rec_outline(x + (k - width - offset)*thickness, y + (k - width - offset) * thickness, w - (k - width - offset)*thickness*2, h + 1 - (k - width - offset)*thickness*2, rounding + thickness * (width - k + offset), thickness, accent)
             end
         end
     end
 }


 function ui_menu:is_aa_tab()
    local menu_size = { ui.menu_size() }
  
    
    local menu_pos = { ui.menu_position() }
    local mouse_pos = { ui.mouse_position() }

   local scale = {0,0}
   local scale_x = 0
   local pesadelo_no_direito = 0

    if ui.get(ui.reference("MISC","Settings","DPI scale")) == "100%" then
        scale = { ui_menu.dpi_scaling_y[1][1],ui_menu.dpi_scaling_y[1][2] }
        scale_x = 76
        pesadelo_no_direito = ui_menu.pesadelo_na_cozinha2[1]
    elseif ui.get(ui.reference("MISC","Settings","DPI scale"))  == "125%" then
        scale = { ui_menu.dpi_scaling_y[2][1],ui_menu.dpi_scaling_y[2][2] }
        scale_x = 95
        pesadelo_no_direito = ui_menu.pesadelo_na_cozinha2[2]
    elseif ui.get(ui.reference("MISC","Settings","DPI scale"))  == "150%" then
        scale = { ui_menu.dpi_scaling_y[3][1],ui_menu.dpi_scaling_y[3][2] }
        scale_x = 113
        pesadelo_no_direito = ui_menu.pesadelo_na_cozinha2[3]
    elseif ui.get(ui.reference("MISC","Settings","DPI scale"))  == "175%" then
        scale = { ui_menu.dpi_scaling_y[4][1],ui_menu.dpi_scaling_y[4][2] }
        scale_x = 132
        pesadelo_no_direito = ui_menu.pesadelo_na_cozinha2[4]
    elseif ui.get(ui.reference("MISC","Settings","DPI scale"))  == "200%" then
        scale = { ui_menu.dpi_scaling_y[5][1],ui_menu.dpi_scaling_y[5][2] }
        scale_x = 151
        pesadelo_no_direito = ui_menu.pesadelo_na_cozinha2[5]
    end

    if ui_menu.mouse_press == false then
        ui_menu.old_mpos = mouse_pos
    end      

    if client.key_state(0x1) then
        if not ui_menu.mouse_press then
            ui_menu.mouse_press = true
            if mouse_pos[1] > menu_pos[1] + 5 and mouse_pos[1] < menu_pos[1] + 5 + scale_x then
                if mouse_pos[2] > menu_pos[2] + scale[1] and mouse_pos[2] < menu_pos[2] + scale[2] then
                    ui_menu.selected_gs_tab = true
                    
                elseif mouse_pos[2] > menu_pos[2] + 19 and (menu_size[2] >= pesadelo_no_direito and mouse_pos[2] < menu_pos[2] + menu_size[2] or mouse_pos[2] < menu_pos[2] + pesadelo_no_direito) and ui_menu.selected_gs_tab == true then
                    ui_menu.selected_gs_tab = false
                end
            end
        end
    else
        ui_menu.mouse_press = false
    end
end


function ui_menu:new_tab()

    ui_menu.is_hovered = false
    if not ui.is_menu_open()  then
        ui_menu.menu_alpha = lerp(ui_menu.menu_alpha,0,globals.frametime() * 50)
    else
        ui_menu.menu_alpha = lerp(ui_menu.menu_alpha,255,globals.frametime() * 5)
    end

    if ui_menu.menu_alpha < 50 then return end

    local menu_size = { ui.menu_size() }
    local divide_menu = (menu_size[1] - 12) / #ui_menu.tabs_names
    
    local menu_pos = { ui.menu_position() }
    local mouse_pos = { ui.mouse_position() }

    if not ui_menu.selected_gs_tab then return end

    for k,v in ipairs(ui_menu.tabs_names) do

        if ui_menu.selected_tab == k then
            ui_menu.selected_color[1] = {20, 20, 20}
            ui_menu.selected_color[2] = {210, 210, 210}
        else
            ui_menu.selected_color[1] = {12, 12, 12}
            ui_menu.selected_color[2] = {90, 90, 90}
        end
       
        renderer.text(menu_pos[1] + (divide_menu * k) - divide_menu / 2 ,menu_pos[2] - 25,ui_menu.selected_color[2][1], ui_menu.selected_color[2][2], ui_menu.selected_color[2][3],ui_menu.menu_alpha,"cd+",0,v)

        if mouse_pos[1] > menu_pos[1] + (divide_menu * k) -  divide_menu and mouse_pos[1] < menu_pos[1] + (divide_menu * k) and mouse_pos[2] > menu_pos[2] - 50 and mouse_pos[2] < menu_pos[2] then
            ui_menu.is_hovered = true
            if  client.key_state(0x1) then
                ui_menu.selected_tab = k
            end
        end
    end
    renderer.text(menu_pos[1] + (divide_menu * ui_menu.selected_tab) - divide_menu / 2 ,menu_pos[2] - 25,210, 210, 210,ui_menu.menu_alpha,"cd+",0,ui_menu.tabs_names[ui_menu.selected_tab])
end

function ui_menu:render_tabs() 
    local menu_s = { ui.menu_size() }
    local menu_p = { ui.menu_position() }

    if not ui.is_menu_open()  then
        ui_menu.menu_alpha = lerp(ui_menu.menu_alpha,0,globals.frametime() * 90)
    else
        ui_menu.menu_alpha = lerp(ui_menu.menu_alpha,255,globals.frametime() * 5)
    end

    local divide_menu = (menu_s[1] - 12) / #ui_menu.tabs_names
    
    if ui_menu.menu_alpha < 170 then return end

    if not ui_menu.selected_gs_tab then return end

    renderer.texture(tex_id, menu_p[1] + 1, menu_p[2]-49, menu_s[1] - 2, 50, 255, 255, 255, ui_menu.menu_alpha, "r")

    --renderer.rectangle(menu_p[1] + (divide_menu * ui_menu.selected_tab) - divide_menu + 7, menu_p[2] - 44,divide_menu -1,50,11,11,11,255) 
    
    --top bar
    renderer.rectangle(menu_p[1] ,menu_p[2] - 53,menu_s[1] ,1 ,12,12,12,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + 2,menu_p[2] - 52,menu_s[1] - 4,5 ,60,60,60,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + 2,menu_p[2] - 51,menu_s[1] - 4,3 ,40,40,40,ui_menu.menu_alpha) 
    
    --left bar
    renderer.rectangle(menu_p[1] ,menu_p[2] - 53,1,53 ,12,12,12,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + 1,menu_p[2] - 52,4,52 ,60,60,60,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + 2,menu_p[2] - 51,3,51 ,40,40,40,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + 5,menu_p[2] - 48,1,48 ,60,60,60,ui_menu.menu_alpha)
    
    --right bar
    renderer.rectangle(menu_p[1] + menu_s[1] - 1,menu_p[2] - 53,1,53 ,12,12,12,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + menu_s[1] - 3,menu_p[2] - 52,2,52 ,60,60,60,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + menu_s[1] - 5,menu_p[2] - 51,3,51 ,40,40,40,ui_menu.menu_alpha)
    renderer.rectangle(menu_p[1] + menu_s[1] - 6,menu_p[2] - 48,1,48 ,60,60,60,ui_menu.menu_alpha) 

    renderer.gradient(menu_p[1] + 7,menu_p[2] - 46, menu_s[1]/2,1, 59, 175, 222, ui_menu.menu_alpha, 202, 70, 205, ui_menu.menu_alpha,true)
                
    renderer.gradient(menu_p[1] + 7 + menu_s[1]/2 ,menu_p[2] - 46, menu_s[1]/2 - 13.3, 1,203, 70, 205, ui_menu.menu_alpha,204, 227, 53, ui_menu.menu_alpha,true)
end

client.set_event_callback("paint_ui", ui_menu.is_aa_tab)
client.set_event_callback("paint_ui", ui_menu.render_tabs)
client.set_event_callback("paint_ui", ui_menu.new_tab)


----------------------------------------------------------------------------------------------------------------------------------------------MENU




client.exec("clear")
client.color_log(255, 255, 255, " \n \n \n \n \n ")
client.color_log(lua_color.r, lua_color.g, lua_color.b, lua_banner)
client.color_log(255, 255, 255, " \n \n \n \n \n ")

normalize = function(self, angle)
    angle =  angle % 360 
    angle = (angle + 360) % 360
    if (angle > 180)  then
        angle = angle - 360
    end
    return angle
end

local function round(num, numDecimalPlaces)
	local mult = 10^(numDecimalPlaces or 0)
	return math.floor(num * mult + 0.5) / mult
end

local ft_prev = 0
local function get_fps()
	ft_prev = ft_prev * 0.9 + globals.absoluteframetime() * 0.1
	return round(1 / ft_prev)
end

local function lerp(a, b, percentage)
	return a + (b - a) * percentage
end

local function table_lerp(a, b, percentage)
	local result = {}
	for i=1, #a do
		result[i] = lerp(a[i], b[i], percentage)
	end
	return result
end

local function clamp(cur_val, min_val, max_val)
	return math.min(math.max(cur_val, min_val), max_val)
end

local function lerp_color_yellow_red(val, max_normal, max_yellow, max_red, default, yellow, red)
	default = default or {255, 255, 255}
	yellow = yellow or {230, 210, 40}
	red = red or {255, 32, 32}
	if val > max_yellow then
		return unpack(table_lerp(yellow, red, clamp((val-max_yellow)/(max_red-max_yellow), 0, 1)))
	else
		return unpack(table_lerp(default, yellow, clamp((val-max_normal)/(max_yellow-max_normal), 0, 1)))
	end
end

function render_ogskeet_border(x,y,w,h,a,text)
    renderer.rectangle(x - 10, y - 48 ,w + 20, h + 16,12,12,12,a)
    renderer.rectangle(x - 9, y - 47 ,w + 18, h + 14,60,60,60,a)
    renderer.rectangle(x - 8, y - 46 ,w + 16, h + 12,40,40,40,a)
    renderer.rectangle(x - 5, y - 43 ,w + 10, h + 6,60,60,60,a)
    renderer.rectangle(x - 4, y - 42 ,w + 8, h + 4,12,12,12,a)
    renderer.texture(tex_id, x - 4, y - 42, w + 8, h + 4, 255, 255, 255, a, "r")
    renderer.gradient(x - 4,y - 42, w /2, 1, 59, 175, 222, a, 202, 70, 205, a,true)               
    renderer.gradient(x - 4 + w / 2 ,y - 42, w /2 + 8.5, 1,202, 70, 205, a,204, 227, 53, a,true)
    renderer.text(x, y - 40, 255,255,255,a, "", nil, text)
end

-- resolver_data = {}
-- local ctx = (function()
--     local ctx = {}

--     ctx.globals = {
--         states = {"stand", "slow walk", "run", "duck", "duck move", "jump", "duck jump", "fakelag", "hideshots"},
-- 		extended_states = {"global", "stand", "slow walk", "run", "duck", "duck move", "jump", "duck jump", "fakelag", "hideshots"},
-- 		teams = {"t", "ct"},
-- 		in_ladder = 0,
-- 		nade = 0,
-- 		resolver_data = {}
--     }


--     ctx.resolver = {
--       run = function(self)
--     end
-- }
  
--     return ctx
-- end)()

local ctx = new_class()

:struct 'helpers' {
    last_eye_yaw = 0,
		was_in_air = true,
		last_tick = globals.tickcount(),

		contains = function(self, tbl, val)
			for k, v in pairs(tbl) do
				if v == val then
					return true
				end
			end
			return false
		end,

		get_lerp_time = function(self)
			local ud_rate = cvar.cl_updaterate:get_int()
			
			local min_ud_rate = cvar.sv_minupdaterate:get_int()
			local max_ud_rate = cvar.sv_maxupdaterate:get_int()
			
			if (min_ud_rate and max_ud_rate) then
				ud_rate = max_ud_rate
			end

			local ratio = cvar.cl_interp_ratio:get_float()
			
			if (ratio == 0) then
				ratio = 1
			end

			local lerp = cvar.cl_interp:get_float()
			local c_min_ratio = cvar.sv_client_min_interp_ratio:get_float()
			local c_max_ratio = cvar.sv_client_max_interp_ratio:get_float()
			
			if (c_min_ratio and  c_max_ratio and  c_min_ratio ~= 1) then
				ratio = clamp(ratio, c_min_ratio, c_max_ratio)
			end

			return math.max(lerp, (ratio / ud_rate));
		end,

		rgba_to_hex = function(self, r, g, b, a)
			return bit.tohex(
			(math.floor(r + 0.5) * 16777216) + 
			(math.floor(g + 0.5) * 65536) + 
			(math.floor(b + 0.5) * 256) + 
			(math.floor(a + 0.5))
			)
		end,

		easeInOut = function(self, t)
			return (t > 0.5) and 4*((t-1)^3)+1 or 4*t^3;
		end,

		animate_text = function(self, time, string, r, g, b, a)
			local t_out, t_out_iter = { }, 1

			local l = string:len( ) - 1
	
			local r_add = (255 - r)
			local g_add = (255 - g)
			local b_add = (255 - b)
			local a_add = (155 - a)
	
			for i = 1, #string do
				local iter = (i - 1)/(#string - 1) + time
				t_out[t_out_iter] = "\a" .. self:rgba_to_hex( r + r_add * math.abs(math.cos( iter )), g + g_add * math.abs(math.cos( iter )), b + b_add * math.abs(math.cos( iter )), a + a_add * math.abs(math.cos( iter )) )
	
				t_out[t_out_iter + 1] = string:sub( i, i )
	
				t_out_iter = t_out_iter + 2
			end
	
			return t_out
		end,

		clamp = function(self, val, lower, upper)
			assert(val and lower and upper, "not very useful error message here")
			if lower > upper then lower, upper = upper, lower end -- swap if boundaries supplied the wrong way
			return math.max(lower, math.min(upper, val))
		end,

		get_damage = function(self)
			local mindmg = ui.get(self.ref.rage.mindmg[1])
			if ui.get(self.ref.rage.ovr[1]) and ui.get(self.ref.rage.ovr[2]) then
				return ui.get(self.ref.rage.ovr[3])
			else
				return mindmg
			end
		end,

		normalize = function(self, angle)
			angle =  angle % 360 
			angle = (angle + 360) % 360
			if (angle > 180)  then
				angle = angle - 360
			end
			return angle
		end,

		fetch_data = function(self, ent)
			return {
				origin = vector(entity.get_origin(ent)), -- +
				vev_velocity = vector(entity.get_prop(ent, "m_vecVelocity")),
				view_offset = entity.get_prop(ent, "m_vecViewOffset[2]"), -- +
				eye_angles = vector(entity.get_prop(ent, "m_angEyeAngles")), -- +
				lowerbody_target = entity.get_prop(ent, "m_flLowerBodyYawTarget"),
				simulation_time = self.helpers:time_to_ticks(entity.get_prop(ent, "m_flSimulationTime")),
				tickcount = globals.tickcount(),
				curtime = globals.curtime(),
				tickbase = entity.get_prop(ent, "m_nTickBase"),
				origin = vector(entity.get_prop(ent, "m_vecOrigin")),
				flags = entity.get_prop(ent, "m_fFlags"),
			}
		end,

		time_to_ticks = function(self, t)
			return math.floor(0.5 + (t / globals.tickinterval()))
		end,

		menu_visibility = function(self, visible)
			for _, v in pairs(self.ref.aa) do
				for _, item in ipairs(v) do
					ui.set_visible(item, visible)
				end
			end
		end,

		in_ladder = function(self)
			local me = entity.get_local_player()

			if entity.is_alive(me) then
				if entity.get_prop(me, "m_MoveType") == 9 then
					self.globals.in_ladder = globals.tickcount() + 8
				end
			else
				self.globals.in_ladder = 0
			end

		end,

		in_air = function(self, ent)
			local flags = entity.get_prop(ent, "m_fFlags")
			return bit.band(flags, 1) == 0
		end,

		in_duck = function(self, ent)
			local flags = entity.get_prop(ent, "m_fFlags")
			return bit.band(flags, 4) == 4
		end,

    get_eye_yaw = function (self, ent)
      if ent == nil then
        return
      end

      local player_ptr = get_client_entity(ientitylist, ent)
      if player_ptr == nil then
        return
      end

      if globals.chokedcommands() == 0 then
	      self.last_eye_yaw = ffi.cast("float*", ffi.cast("char*", ffi.cast("void**", ffi.cast("char*", player_ptr) + 0x9960)[0]) + 0x78)[0]
      end

      return self.last_eye_yaw
    end,

    get_closest_angle = function(self, max, min, dir, ang)
      -- Calculate the absolute angular difference between d and a, b, and c
      max = self.helpers:normalize(max)
      min = self.helpers:normalize(min)
      dir = self.helpers:normalize(dir)
      ang = self.helpers:normalize(ang)

      --check if ang is between max and min and also in the same side as dir
      local diff_maxang = math.abs((max - ang + 180) % 360 - 180)
      local diff_minang = math.abs((min - ang + 180) % 360 - 180)
      local diff_maxdir = math.abs((max - dir + 180) % 360 - 180)
      local diff_mindir = math.abs((min - dir + 180) % 360 - 180)
      local diff_minmax = math.abs((min - max + 180) % 360 - 180)

      local ang_side = diff_maxang > diff_minmax or diff_minang > diff_minmax

      local dir_side = diff_maxdir > diff_minmax or diff_mindir > diff_minmax

      if dir_side ~= ang_side then
        if diff_minang < diff_maxang then
          return 0
        else
          return 1
        end
        return
      end

      return 2
    end,

		get_freestanding_side = function(self, data)
			local me = entity.get_local_player()
			local target = client.current_threat()
			local _, yaw = client.camera_angles()
			local pos = vector(client.eye_position())

      if not target then
        return 2
      end
			
			_, yaw = (pos - vector(entity.get_origin(target))):angles()
			
			local yaw_offset = data.offset
			local yaw_jitter_type = string.lower(data.type)
			local yaw_jitter_amount = data.value
			
			local offset = math.abs(yaw_jitter_amount)
			
			if yaw_jitter_type == 'skitter' then
				offset = math.abs(yaw_jitter_amount) + 33
			elseif yaw_jitter_type == 'offset' then
				offset = math.max(0, yaw_jitter_amount)
			elseif yaw_jitter_type == 'center' then
				offset = math.abs(yaw_jitter_amount)/2
			end
			
			local max_yaw = self.helpers:normalize(yaw + yaw_offset + offset)
			
			local min_offset = offset
			if yaw_jitter_type == 'offset' then
				min_offset = math.abs(math.min(0, yaw_jitter_amount))
			end
			
			local min_yaw = self.helpers:normalize(yaw + yaw_offset - min_offset)
			
			local current_yaw = self:get_eye_yaw(me)

      local left_offset = max_yaw - current_yaw
      local right_offset = min_yaw - current_yaw

      local closest = self:get_closest_angle(min_yaw, max_yaw, yaw, current_yaw)
			
      return closest
		end,

		get_state = function(self)
			local me = entity.get_local_player()
			local velocity = vector(entity.get_prop(me, "m_vecVelocity")):length2d()
			local duck = self:in_duck(me) or ui.get(self.ref.rage.fd[1])

			local state = velocity > 1.5 and "run" or "stand"
			
			if self:in_air(me) or self.was_in_air then
				state = duck and "duck jump" or "jump"
			elseif velocity > 1.5 and duck then
				state = "duck move"
			elseif ui.get(self.ref.slow_motion[1]) and ui.get(self.ref.slow_motion[2]) then
				state = "slow walk"
			elseif duck then
				state = "duck"
			end
			if globals.tickcount() ~= self.last_tick then
				self.was_in_air = self:in_air(me)
				self.last_tick = globals.tickcount()
			end
			return state
		end,

		get_team = function(self)
			local me = entity.get_local_player()
			local index = entity.get_prop(me, "m_iTeamNum")

			return index == 2 and "t" or "ct"
		end,

		loop = function (arr, func)
			if type(arr) == "table" and arr.__type == "pui::element" then
				func(arr)
			else
				for k, v in pairs(arr) do
					loop(v, func)
				end
			end
		end,

		get_charge = function ()
			local me = entity.get_local_player()
			local simulation_time = entity.get_prop(entity.get_local_player(), "m_flSimulationTime")
			return (globals.tickcount() - simulation_time/globals.tickinterval())
		end,
	}


    :struct 'ui' {
		menu = {
			global = {},
            Normal = {},
			Debug = {},
            resik = {},
		},
        

		execute = function(self)
			local group = pui.group("Players", "Adjustments")
			self.menu.global.tab = group:combobox("\badffff\bfacfff[TAB SELECTOR]\n", {"Normal", "Debug"})
            self.menu.Normal.resolver2 = group:combobox("\badffff\bfacfff[Resolver [Recode]]\n", {"Off", "On"})
            self.menu.Normal.label2 = group:label(" ")
            self.menu.Debug.resolver = group:combobox("\badffff\bfacfff[AI [Recode]]\n", {"Off", "On"})
            self.menu.Debug.tab2 = group:combobox(" \ntab", {"Smart", "Dangerous"}):depend({self.menu.Debug.resolver, true})
           -- self.menu.Debug.label = group:label("~DISABLE RECODE [0.1]!")
            self.menu.Debug.label2 = group:label(" ")


            

			-- set item dependencies (visibility)=
			for tab, arr in pairs(self.menu) do
				if type(arr) == "table" and tab ~= "global" then
					Loop = function (arr, tab)
						for _, v in pairs(arr) do
							if type(v) == "table" then
								if v.__type == "pui::element" then
									v:depend({self.menu.global.tab, tab})
								else
									Loop(v, tab)
								end
							end
						end
					end

					Loop(arr, tab)
				end
			end
			
		end,

		shutdown = function(self)
			self.helpers:menu_visibility(true)
		end
	}


    :struct 'globals' {
        states = {"stand", "slow walk", "run", "duck", "duck move", "jump", "duck jump", "fakelag", "hideshots"},
        extended_states = {"global", "stand", "slow walk", "run", "duck", "duck move", "jump", "duck jump", "fakelag", "hideshots"},
        teams = {"t", "ct"},
        in_ladder = 0,
        nade = 0,
        resolver_data = {}
    }

    :struct 'ref' {
		aa = {
			enabled = {ui.reference("aa", "anti-aimbot angles", "enabled")},
			pitch = {ui.reference("aa", "anti-aimbot angles", "pitch")},
			yaw_base = {ui.reference("aa", "anti-aimbot angles", "Yaw base")},
			yaw = {ui.reference("aa", "anti-aimbot angles", "Yaw")},
			yaw_jitter = {ui.reference("aa", "anti-aimbot angles", "Yaw Jitter")},
			body_yaw = {ui.reference("aa", "anti-aimbot angles", "Body yaw")},
			freestanding_body_yaw = {ui.reference("aa", "anti-aimbot angles", "Freestanding body yaw")},
			freestand = {ui.reference("aa", "anti-aimbot angles", "Freestanding")},
			roll = {ui.reference("aa", "anti-aimbot angles", "Roll")},
			edge_yaw = {ui.reference("aa", "anti-aimbot angles", "Edge yaw")}
		},
		fakelag = {
			enable = {ui.reference("aa", "fake lag", "enabled")},
			amount = {ui.reference("aa", "fake lag", "amount")},
			variance = {ui.reference("aa", "fake lag", "variance")},
			limit = {ui.reference("aa", "fake lag", "limit")},
		},
		rage = {
			dt = {ui.reference("rage", "aimbot", "Double tap")},
			dt_limit = {ui.reference("rage", "aimbot", "Double tap fake lag limit")},
			fd = {ui.reference("rage", "other", "Duck peek assist")},
			os = {ui.reference("aa", "other", "On shot anti-aim")},
			silent = {ui.reference("rage", "Other", "Silent aim")},
			quickpeek = {ui.reference("RAGE", "Other", "Quick peek assist")},
			quickpeek2 = {ui.reference("RAGE", "Other", "Quick peek assist mode")},
			mindmg = {ui.reference('rage', 'aimbot', 'minimum damage')},
			ovr = {ui.reference('rage', 'aimbot', 'minimum damage override')}
		},
		slow_motion = {ui.reference("aa", "other", "Slow motion")},
	}

    :struct 'resolver' {
        state = {},
        counter = {},
        jitterhelper = function(self)

            local resolver = self.ui.menu.Debug.resolver:get()
            local resolver2 = self.ui.menu.Normal.resolver2:get()
            if resolver == "On" then
                if resolver2 == "On" then 
                    print("Disable Resolver [Recode] before AI!")
                end
                local players = entity.get_players(true)      
                if #players == 0 then
                    return
                end
              --  resolver_status = self.ui.menu.misc.resolver_flag()
                for _, i in next, players do

                    local target = i
                    if self.globals.resolver_data[target] == nil then
                        local data = self.helpers:fetch_data(target)
                        self.globals.resolver_data[target] = {
                            current = data,
                            last_valid_record = data
                        }
                    else
                        local simulation_time = self.helpers:time_to_ticks(entity.get_prop(target, "m_flSimulationTime"))
                        if simulation_time ~= self.globals.resolver_data[target].current.simulation_time then
                            table.insert(self.globals.resolver_data[target], 1, self.globals.resolver_data[target].current)
                            local data = self.helpers:fetch_data(target)
                            if simulation_time - self.globals.resolver_data[target].current.simulation_time >= 1 then
                                self.globals.resolver_data[target].last_valid_record = data
                            end
                            self.globals.resolver_data[target].current = data
                            for i = #self.globals.resolver_data[target], 1, -1 do
                                if #self.globals.resolver_data[target] > 16 then 
                                    table.remove(self.globals.resolver_data[target], i)
                                end
                            end
                        end
                    end

                    if self.globals.resolver_data[target][1] == nil or self.globals.resolver_data[target][2] == nil or self.globals.resolver_data[target][3] == nil or self.globals.resolver_data[target][6] == nil or self.globals.resolver_data[target][7] == nil then
                        return
                    end
                    
                    local yaw_delta = self.helpers:normalize(self.globals.resolver_data[target].current.eye_angles.y - self.globals.resolver_data[target][1].eye_angles.y)
                    local yaw_delta2 = self.helpers:normalize(self.globals.resolver_data[target][2].eye_angles.y - self.globals.resolver_data[target][3].eye_angles.y)
                    local yaw_delta3 = self.helpers:normalize(self.globals.resolver_data[target][6].eye_angles.y - self.globals.resolver_data[target][7].eye_angles.y)

                    if math.abs(yaw_delta) >= 33 then
                        self.globals.resolver_data[target].lastyawupdate = globals.tickcount() + 10
                        self.globals.resolver_data[target].side = yaw_delta
                    end

                    if self.globals.resolver_data[target].lastyawupdate == nil then self.globals.resolver_data[target].lastyawupdate = 0 end
                    if self.globals.resolver_data[target].lastplistupdate == nil then self.globals.resolver_data[target].lastplistupdate = 0 end
                    if self.globals.resolver_data[target].skitterupdate == nil then self.globals.resolver_data[target].skitterupdate = 0 end

                    if math.abs(yaw_delta2 - yaw_delta3) > 90 then
                        self.globals.resolver_data[target].skitterupdate = globals.tickcount() + 10
                    end
                    if self.globals.resolver_data[target].skitterupdate - globals.tickcount() > 0 then
                        self.state[target] = "SKITTER"
                      --  resolver_flag[target] = "SKITTER"
                        if math.abs(yaw_delta2 - yaw_delta3) == 0 then
                            plist.set(target, "Force body yaw value", 0)
                        else
                            plist.set(target, "Force body yaw value", (yaw_delta) > 0 and 60 or -60)
                        end
                    elseif self.globals.resolver_data[target].lastyawupdate > globals.tickcount() and yaw_delta == 0 and self.globals.resolver_data[target].skitterupdate - globals.tickcount() < 0 then
                        plist.set(target, "Force body yaw", true)
                        plist.set(target, "Force body yaw value", (self.globals.resolver_data[target].side) > 0 and 60 or -60)
                        self.globals.resolver_data[target].lastplistupdate = globals.tickcount() + 10
                        self.state[target] = "CENTER"
                      --  resolver_flag[target] = "JITTER"
                    elseif math.abs(yaw_delta) >= 33 then
                        plist.set(target, "Force body yaw", true)
                        plist.set(target, "Force body yaw value", (yaw_delta) > 0 and 60 or -60)
                        self.state[target] = "CENTER"
                      --  resolver_flag[target] = "JITTER"
                        self.globals.resolver_data[target].lastplistupdate = globals.tickcount() + 10
                    elseif self.globals.resolver_data[target].lastplistupdate < globals.tickcount() then
                        plist.set(target, "Force body yaw", false)
                        self.state[target] = ""
                      --  resolver_flag[target] = ""
                    else
                        plist.set(target, "Force body yaw", false)
                        self.state[target] = ""
                      --  resolver_flag[target] = ""
                    end

                end
            elseif resolver2 == "On" then
                if resolver == "On" then 
                    print("Disable AI Resolver before Recode!")
                end
                local players = entity.get_players(true)    
                if #players == 0 then
                    return
                end
                for _, i in next, players do

                    local target = i
                    if self.globals.resolver_data[target] == nil then
                        local data = self.helpers:fetch_data(target)
                        self.globals.resolver_data[target] = {
                            current = data,
                            last_valid_record = data
                        }
                    else
                        local simulation_time = self.helpers:time_to_ticks(entity.get_prop(target, "m_flSimulationTime"))
                        if simulation_time ~= self.globals.resolver_data[target].current.simulation_time then
                            table.insert(self.globals.resolver_data[target], 1, self.globals.resolver_data[target].current)
                            local data = self.helpers:fetch_data(target)
                            if simulation_time - self.globals.resolver_data[target].current.simulation_time >= 1 then
                                self.globals.resolver_data[target].last_valid_record = data
                            end
                            self.globals.resolver_data[target].current = data
                            for i = #self.globals.resolver_data[target], 1, -1 do
                                if #self.globals.resolver_data[target] > 16 then 
                                    table.remove(self.globals.resolver_data[target], i)
                                end
                            end
                        end
                    end

                    if self.globals.resolver_data[target][1] == nil or self.globals.resolver_data[target][2] == nil or self.globals.resolver_data[target][3] == nil or self.globals.resolver_data[target][6] == nil or self.globals.resolver_data[target][7] == nil then
                        return
                    end
                    
                    local yaw_delta = self.helpers:normalize(self.globals.resolver_data[target].current.eye_angles.y - self.globals.resolver_data[target][1].eye_angles.y)
                    local yaw_delta2 = self.helpers:normalize(self.globals.resolver_data[target][2].eye_angles.y - self.globals.resolver_data[target][3].eye_angles.y)
                    local yaw_delta3 = self.helpers:normalize(self.globals.resolver_data[target][6].eye_angles.y - self.globals.resolver_data[target][7].eye_angles.y)

                    if math.abs(yaw_delta) >= 33 then
                        self.globals.resolver_data[target].lastyawupdate = globals.tickcount() + 10
                        self.globals.resolver_data[target].side = yaw_delta
                    end
                    

                    if self.globals.resolver_data[target].lastyawupdate == nil then self.globals.resolver_data[target].lastyawupdate = 0 end
                    if self.globals.resolver_data[target].lastplistupdate == nil then self.globals.resolver_data[target].lastplistupdate = 0 end
                    if self.globals.resolver_data[target].skitterupdate == nil then self.globals.resolver_data[target].skitterupdate = 0 end

                    if math.abs(yaw_delta2 - yaw_delta3) > 90 then
                        self.globals.resolver_data[target].skitterupdate = globals.tickcount() + 10
                    end
                    if self.globals.resolver_data[target].skitterupdate - globals.tickcount() > 0 then
                        self.state[target] = "SKITTER"
                        if math.abs(yaw_delta2 - yaw_delta3) == 0 then
                            plist.set(target, "Force body yaw value", 0)
                        else
                            plist.set(target, "Force body yaw value", yaw_delta)
                        end
                    elseif self.globals.resolver_data[target].lastyawupdate > globals.tickcount() and yaw_delta == 0 and self.globals.resolver_data[target].skitterupdate - globals.tickcount() < 0 then
                        plist.set(target, "Force body yaw", true)
                       -- plist.set(target, "Force body yaw value", (self.globals.resolver_data[target].side) > 0 and 60 or -60)
                        plist.set(target, "Force body yaw value", (self.globals.resolver_data[target].side) > 0 and 60 or -60)
                        self.globals.resolver_data[target].lastplistupdate = globals.tickcount() + 10
                        self.state[target] = "CENTER"
                    elseif math.abs(yaw_delta) >= 33 then
                        plist.set(target, "Force body yaw", true)
                        plist.set(target, "Force body yaw value", yaw_delta)
                        self.state[target] = "CENTER"
                        self.globals.resolver_data[target].lastplistupdate = globals.tickcount() + 10
                    elseif self.globals.resolver_data[target].lastplistupdate < globals.tickcount() then
                        plist.set(target, "Force body yaw", false)
                        self.state[target] = ""
                    else
                        plist.set(target, "Force body yaw", false)
                        self.state[target] = ""

                    end
                end
            end

        end,
    }
    for _, eid in ipairs({
        {
            "net_update_start", function()
                ctx.resolver:jitterhelper()
            end
        },
        {
            "paint_ui", function()
                ctx.helpers:menu_visibility(false)
            end
        },
        {
            "load", function()
                ctx.ui:execute()
            end
        },
    }) do
        if eid[1] == "load" then
            eid[2]()
        else
            client.set_event_callback(eid[1], eid[2])
        end
    end

local lua = {}
lua.database = {
    configs = ":" .. lua_name .. "::configs:"
}
local presets = {}
-- @region USERDATA end

ffi.cdef [[
    typedef unsigned long dword;
    typedef unsigned int size_t;

    typedef struct {
        uint8_t r, g, b, a;
    } color_t;

    struct c_animstate { 
        char pad[ 3 ];
        char m_bForceWeaponUpdate; //0x4
        char pad1[ 91 ];
        void* m_pBaseEntity; //0x60
        void* m_pActiveWeapon; //0x64
        void* m_pLastActiveWeapon; //0x68
        float m_flPrevCycle; //0x001C
        float m_flWeight; //0x0020
        float m_flWeightDeltaRate; //0x0024
        float m_flPlaybackRate; //0x0028
        float m_flLastClientSideAnimationUpdateTime; //0x6C
        int m_iLastClientSideAnimationUpdateFramecount; //0x70
        float m_flAnimUpdateDelta; //0x74
        float m_flEyeYaw; //0x78
        float m_flPitch; //0x7C
        float m_flGoalFeetYaw; //0x80
        float m_flCurrentFeetYaw; //0x84   
        float m_flCurrentTorsoYaw; //0x88
        float m_flUnknownVelocityLean; //0x8C
        float m_flLeanAmount; //0x90
        char pad2[ 4 ];
        float m_flFeetCycle; //0x98
        float m_flFeetYawRate; //0x9C
        char pad3[ 4 ];
        float m_fDuckAmount; //0xA4
        float m_fLandingDuckAdditiveSomething; //0xA8
        char pad4[ 4 ];
        float m_vOriginX; //0xB0
        float m_vOriginY; //0xB4
        float m_vOriginZ; //0xB8
        float m_vLastOriginX; //0xBC
        float m_vLastOriginY; //0xC0
        float m_vLastOriginZ; //0xC4
        float m_vVelocityX; //0xC8
        float m_vVelocityY; //0xCC
        char pad5[ 4 ];
        float m_flUnknownFloat1; //0xD4
        char pad6[ 8 ];
        float m_flUnknownFloat2; //0xE0
        float m_flUnknownFloat3; //0xE4
        float m_flUnknown; //0xE8
        float m_flSpeed2D; //0xEC
        float m_flUpVelocity; //0xF0
        float m_flSpeedNormalized; //0xF4
        float m_flFeetSpeedForwardsOrSideWays; //0xF8
        float m_flFeetSpeedUnknownForwardOrSideways; //0xFC
        float m_flTimeSinceStartedMoving; //0x100
        float m_flTimeSinceStoppedMoving; //0x104
        bool m_bOnGround; //0x108
        bool m_bInHitGroundAnimation; //0x109
        float m_flTimeSinceInAir; //0x10A
        float m_flLastOriginZ; //0x10E
        float m_flHeadHeightOrOffsetFromHittingGroundAnimation; //0x112
        float m_flStopToFullRunningFraction; //0x116
        char pad7[ 4 ]; //0x11A
        float m_flMagicFraction; //0x11E
        char pad8[ 60 ]; //0x122
        float m_flWorldForce; //0x15E
        char pad9[ 462 ]; //0x162
        float m_flMaxYaw; //0x334
    };
]]

local classptr = ffi.typeof('void***')
local rawientitylist = client.create_interface('client.dll', 'VClientEntityList003') or
                           error('VClientEntityList003 wasnt found', 2)

local ientitylist = ffi.cast(classptr, rawientitylist) or error('rawientitylist is nil', 2)
local get_client_networkable = ffi.cast('void*(__thiscall*)(void*, int)', ientitylist[0][0]) or
                                   error('get_client_networkable_t is nil', 2)
local get_client_entity = ffi.cast('void*(__thiscall*)(void*, int)', ientitylist[0][3]) or
                              error('get_client_entity is nil', 2)

local rawivmodelinfo = client.create_interface('engine.dll', 'VModelInfoClient004')
local ivmodelinfo = ffi.cast(classptr, rawivmodelinfo) or error('rawivmodelinfo is nil', 2)
local get_studio_model = ffi.cast('void*(__thiscall*)(void*, const void*)', ivmodelinfo[0][32])

local seq_activity_sig = client.find_signature('client.dll', '\x55\x8B\xEC\x53\x8B\x5D\x08\x56\x8B\xF1\x83')

to_draw = "no"
to_up = "no"
to_draw_ticks = 0

function defensive_indicator()

    local diff_mmeme = var_table.sim_diff()

    if diff_mmeme <= -1 then
        to_draw = "yes"
        to_up = "yes"
    end
end 

local function GetAnimationState(player)
    if not (player) then
        return
    end
    local player_ptr = ffi.cast("void***", get_client_entity(ientitylist, player))
    local animstate_ptr = ffi.cast("char*", player_ptr) + 0x9960
    local state = ffi.cast("struct c_animstate**", animstate_ptr)[0]

    return state
end

local solus_render = LPH_NO_VIRTUALIZE(function()
    local solus_m = {}

    local Box = function(x, y, w, h, r, g, b, a, radius)
        renderer.rectangle(x, y + radius, w, h - radius, r, g, b, a) -- down
        renderer.rectangle(x + radius, y, w - radius * 2, radius, r, g, b, a) -- up

        renderer.circle(x + radius, y + radius, r, g, b, a, radius, 180, 0.25) --<
        renderer.circle(x + w - radius, y + radius, r, g, b, a, radius, 90, 0.25) -->
    end

    local n = 70

    local OutlineBox = function(x, y, w, h, r, g, b, a, radius)
        local n = a / 255 * n
        renderer.rectangle(x, y + h - 1, w, 1, r, g, b, a) -- down
        renderer.rectangle(x + radius, y, w - radius * 2 + 1, 1, r, g, b, n) -- up

        renderer.gradient(x, y + radius, 1, h - radius, r, g, b, n, r, g, b, a, false) --<
        renderer.gradient(x + w, y + radius, 1, h - radius, r, g, b, n, r, g, b, a, false) -->
        renderer.gradient(x, y + h - 1, w + 1, 6, r, g, b, n, r, g, b, 0, false) -- down

        renderer.circle_outline(x + radius, y + radius, r, g, b, n, radius, 180, 0.25, 1) --<
        renderer.circle_outline(x + w - radius + 1, y + radius, r, g, b, n, radius, 270, 0.25, 1) --> 
  end

    solus_m.container = function(x, y, w, h, r, g, b, a, radius, aa)
        if aa > 20 and radius < 6 then
            renderer.blur(x, y, w, h)
        end

        Box(x, y, w, h, 17, 17, 17, a, radius)
        OutlineBox(x, y, w, h, r, g, b, aa, radius)
    end

    return solus_m
end)()

-- @region REFERENCES start
local refs = {
    legit = ui.reference("LEGIT", "Aimbot", "Enabled"),
    dmgOverride = {ui.reference("RAGE", "Aimbot", "Minimum damage override")},
    fakeDuck = ui.reference("RAGE", "Other", "Duck peek assist"),
    minDmg = ui.reference("RAGE", "Aimbot", "Minimum damage"),
    hitChance = ui.reference("RAGE", "Aimbot", "Minimum hit chance"),
    safePoint = ui.reference("RAGE", "Aimbot", "Force safe point"),
    forceBaim = ui.reference("RAGE", "Aimbot", "Force body aim"),
    dtLimit = ui.reference("RAGE", "Aimbot", "Double tap fake lag limit"),
    quickPeek = {ui.reference("RAGE", "Other", "Quick peek assist")},
    dt = {ui.reference("RAGE", "Aimbot", "Double tap")},
    enabled = ui.reference("AA", "Anti-aimbot angles", "Enabled"),
    pitch = {ui.reference("AA", "Anti-aimbot angles", "pitch")},
    roll = ui.reference("AA", "Anti-aimbot angles", "roll"),
    yawBase = ui.reference("AA", "Anti-aimbot angles", "Yaw base"),
    yaw = {ui.reference("AA", "Anti-aimbot angles", "Yaw")},
    flLimit = ui.reference("AA", "Fake lag", "Limit"),
    fsBodyYaw = ui.reference("AA", "anti-aimbot angles", "Freestanding body yaw"),
    edgeYaw = ui.reference("AA", "Anti-aimbot angles", "Edge yaw"),
    yawJitter = {ui.reference("AA", "Anti-aimbot angles", "Yaw jitter")},
    bodyYaw = {ui.reference("AA", "Anti-aimbot angles", "Body yaw")},
    freeStand = {ui.reference("AA", "Anti-aimbot angles", "Freestanding")},
    os = {ui.reference("AA", "Other", "On shot anti-aim")},
    slow = {ui.reference("AA", "Other", "Slow motion")},
    fakeLag = {ui.reference("AA", "Fake lag", "Limit")},
    legMovement = ui.reference("AA", "Other", "Leg movement"),
    indicators = {ui.reference("VISUALS", "Other ESP", "Feature indicators")},
    ping = {ui.reference("MISC", "Miscellaneous", "Ping spike")},
}
local vars = {
    localPlayer = 0,
    hitgroup_names = { 'Generic', 'Head', 'Chest', 'Stomach', 'Left arm', 'Right arm', 'Left leg', 'Right leg', 'Neck', '?', 'Gear' },
    aaStates = {"Global", "Stand", "Move", "Slowwalk", "Crouch", "Aero", "Aero + Crouch", "Legit-AA"},
    pStates = {"G", "S", "M", "SW", "C", "A", "AC", "LA"},
	sToInt = {["Global"] = 1, ["Stand"] = 2, ["Move"] = 3, ["Slowwalk"] = 4, ["Crouch"] = 5, ["Aero"] = 6, ["Aero + Crouch"] = 7,["Legit-AA"] = 8},
    intToS = {[1] = "Global", [2] = "Stand", [3] = "Move", [4] = "Slowwalk", [5] = "Crouch", [6] = "Aero", [7] = "Aero+C", [8] = "Legit"},
    currentTab = 1,
    activeState = 1,
    pState = 1,
    should_disable = false,
    defensive_until = 0,
    defensive_prev_sim = 0,
    fs = false,
    choke1 = 0,
    choke2 = 0,
    choke3 = 0,
    choke4 = 0,
    switch = false,
}


local kill = {

	'      ',
	'i live and laugh knowing u die.',
	'my spotlight is bigger then united states of  ',
	'I AM LEGEND TO MY FAMILY',
	'tommorow lighton will suffer his last blow after gsense ban',
	'     ',
	'       ',
	'   "VAX"    """"',
	'after killing "ReDD"     ',
	'by funny color player',
    'you think you are   but no.',
    'neverlose will always use as long father esotartliko has my back.',
    'after winning 1vALL i went on vacation to  ',
    'i superior resolver(selling shoppy.gg/@KURAC))',
    '     ',
    'once this game started   ',
    'WOMANBOSS VS (,,,,,,,)',
	'   !',
	'    .',
	'     ',
	'weak gay femboy "cho" is depression after lose https://gamesense.pub/forums/viewtopic.php?id=35658',
	'after ban from galaxy i go on all servers to       ',
	' ( )    ',
	'    ,   .',
	' 666    ',
	'           ',
	'my config better than your',
	'1 STFU NN WHO.RU $$$ UFF YA UID?',
	'  .',
	'     ',
	'game vs you is free win',
	'          ',
	'./@    ',
	'     $',
	'       ',
	'      ',
	'     = ',
	'g      & ',
	'ur lua cracked like egg',
	'i am america after doing u like japan in HVH',
	'winning not possibility, sry.',
	'after this  i become sigma',
	'      ',
	'    ',
	'        ',
	'    $     .',
	'i am KING go slave for me',
	'Don"t cry, say   and smile.',
	'My request for 150 ETH was not filled in. It passed almost 48 hours, I gave them 72...',
    '   ()     .',
    '      ()',
   	'    +  ',
    '      ',
    '     ** ',
   	'    ',
   	'   ""      ',
    '    .',
    '       ',
	'     ',
	'    ',
	'   ./',
	'()  enjoy this H$ and spectate me ',
	'    (_)',
	'    .',
    ' $  ',
	' ',
	'     ',
    '   =  $',
	'          ',
	'  .   .   .',
	'cu@gsense/spotlight section of forum by MOGYORO',
	'u die while i talk with prezident of  making $$$',
	'my coinbase is thicker then the hs i gave u',
	'olympics every 4 years next chance to kill me is in 100',
	'stop talk u *DEAD*',
	'   "yerebko"',
	'     ',
	'        ',
	'$$       2001',
	'       ,   ',
	'    ,     (_) ',
	'   $',
	'  ,  ',
	'1',
	',,   ,         ',
	' ',
	'        ',
	' ,  .',
	'   ( 0)   33',
	'     ',
	'    ',
	'    _',
	'     ',
	'UHQ DoorDash logs tap in!',
	'cheap mcdonald giftcard method _ selly.gg/mcsauce',
	'womanboss>all',
	'      ?',
	'drain balls for superior womanboss.technology invite',
	'  t       ',
	'       ',
	'       ',
	'died to a womn',
	'get fucked in the ass by serb gods, u can freely commit genocide just like eren yeager did $$$ kukubra simulator inreallif',
	'weak dog attend quandale dingle academic',
	'24 btc`d',
	'  I LOVE VALORATN   Glory to China long live Xi Jinping',
	'     ',
	'Black nigga balls HD',
	'when round is end i kill ghost.',
	'i swim entire mediterranean sea and atlantic ocean to 1 weak NA dogs',
	'    .',
	'sowwy >_<',
	'Approved feminist  _',
	'   (_)',
	'so i recive KILLSEY BOOST SYSTEM and now it"S dead all',
	'                  FREE HELL TIKET',
	'              ',
	':   . :   10.244   .',
	's:    s',
	'.  404      _',
	'game-sense is a reaaly good against nevelooss and some other',
	'the server shivers when the when   connect..',
	'    ',
	'               ',
	'           ',
	' +         ',
	'  -   .',
	'    ',
	'          _',
	'+    .',
	'      ',
	'       ',
	'  +          ',
	'            _',
	'()  fnayed ',
	'      _',
	'         ',
	'        ..',
	'      @./',
	' -  +',
	'--  !',
	'! -',
	'!  !',
	' !',
	' freddy fazbear',
	'          _',
	'             ',
	'                    _',
	'.  ',
	'   , %   ... _',
	'FATALITY.WIN Finish Him and Everyone',
	'        ,      ',
	'     :...',
	'               _',
	'      ...',
	'      _',
	'      ...',
	'         _',
	'       ()      -  _',
	'      ...    ',
	'     ?! ( )',
	'UNDERAGE? CALL ME',
	'           ',
	'go buy Nixware for the best hacker facing hacker gone wrong experience.',
	'UFF SilenZIO$$$ U have Ben 1TAPED by PORTUGAL Technology',
	'you"re are poor go bay beter turkish cheat (onetap su) ',
	'Romanian Technology I steal real model and REZOLVE.',
	':        ',
	'BICH...dont test gangster in me',
	'   x(?)       ',
	'    ?',
	'scrabble bot owned by wordle king',
	'          ""    ""',
	'   10   " ',
	'           ',
	'          ',
	'ROLL VS ME? I KILL YOUR MOTHER FATHER SISTER BROTHER BUTCHER THEM AND ROLL ON THEIR GRAVE',
	'brutality,onlybaim,godeless,nuk3s,maverick it dont matter... all will dye to womanboss',
	'          ',
	'GIGACHAD FEMALE DETECTED, GAME DODGED GIGACHAD FEMALE DETECTED, GAME DODGED GIGACHAD FEMALE DETECTED, GAME DODGED GIGACHAD FEMALE DETECTED, GAME DODGED',
	'it ain"t gonna suck itself',
	'  $CRN$ H   $',
	'dont play roll vs me,im miss there',
	'no rare fish no talk',
	'god may forgive you but gamesense resolver won"t (_)',
	'You Just Got Tapped! #fyp #foryou #viral #fy',
	'      s,     t    ',
	'    _  .. ....    ',
	'   ',
	'        ..',
	'     ',
	'   -   ...     ',
	' "   "   , "   ,    ',
	',         , , ,   .',
	'it"s morbin" time',
	'    ',
	'it"s just a game" is such a weak mindset',
	'Keep calm and tap on.',
	'2 lines a day keeps the doctor away',
	'They ain"t believe in us, GOD DID',
	'don"t problem',
	'Headshots speak louder than words',
	'Every tap is a step closer to glory',
	'once you tap you can"t stop',
	'When the tap success, victory follows suit',
	'       ',
	'Turning cheats into defeat, one headshot at a time',
	'The way of wins is dont losing',
	'       ,   .',
	'Baiming win rounds, headshots win hearts',
	'    ,  ',
	'What is happened on cs2 is remain on cs2 (_)',
	'           ',
	'           ',
	'   s   ss  s       s ',
	'       ',
	'                ',
	'                ',
	'          ',
	'        ',
	'       ',
	'       ',
	'      ',
	' 1 V 0',

}

local js = panorama.open()
local MyPersonaAPI, LobbyAPI, PartyListAPI, SteamOverlayAPI = js.MyPersonaAPI, js.LobbyAPI, js.PartyListAPI, js.SteamOverlayAPI
-- @region VARIABLES end

-- @region FUNCS start
local func = {
    fclamp = function(x, min, max)
        return math.max(min, math.min(x, max));
    end,
    frgba = function(hex)
        hex = hex:gsub("#", "");
    
        local r = tonumber(hex:sub(1, 2), 16);
        local g = tonumber(hex:sub(3, 4), 16);
        local b = tonumber(hex:sub(5, 6), 16);
        local a = tonumber(hex:sub(7, 8), 16) or 255;
    
        return r, g, b, a;
    end,
    render_text = function(x, y, ...)
        local x_Offset = 0
        
        local args = {...}
    
        for i, line in pairs(args) do
            local r, g, b, a, text = unpack(line)
            local size = vector(renderer.measure_text("-d", text))
            renderer.text(x + x_Offset, y, r, g, b, a, "-d", 0, text)
            x_Offset = x_Offset + size.x
        end
    end,
    easeInOut = function(t)
        return (t > 0.5) and 4*((t-1)^3)+1 or 4*t^3;
    end,
    rec = function(x, y, w, h, radius, color)
        radius = math.min(x/2, y/2, radius)
        local r, g, b, a = unpack(color)
        renderer.rectangle(x, y + radius, w, h - radius*2, r, g, b, a)
        renderer.rectangle(x + radius, y, w - radius*2, radius, r, g, b, a)
        renderer.rectangle(x + radius, y + h - radius, w - radius*2, radius, r, g, b, a)
        renderer.circle(x + radius, y + radius, r, g, b, a, radius, 180, 0.25)
        renderer.circle(x - radius + w, y + radius, r, g, b, a, radius, 90, 0.25)
        renderer.circle(x - radius + w, y - radius + h, r, g, b, a, radius, 0, 0.25)
        renderer.circle(x + radius, y - radius + h, r, g, b, a, radius, -90, 0.25)
    end,
    rec_outline = function(x, y, w, h, radius, thickness, color)
        radius = math.min(w/2, h/2, radius)
        local r, g, b, a = unpack(color)
        if radius == 1 then
            renderer.rectangle(x, y, w, thickness, r, g, b, a)
            renderer.rectangle(x, y + h - thickness, w , thickness, r, g, b, a)
        else
            renderer.rectangle(x + radius, y, w - radius*2, thickness, r, g, b, a)
            renderer.rectangle(x + radius, y + h - thickness, w - radius*2, thickness, r, g, b, a)
            renderer.rectangle(x, y + radius, thickness, h - radius*2, r, g, b, a)
            renderer.rectangle(x + w - thickness, y + radius, thickness, h - radius*2, r, g, b, a)
            renderer.circle_outline(x + radius, y + radius, r, g, b, a, radius, 180, 0.25, thickness)
            renderer.circle_outline(x + radius, y + h - radius, r, g, b, a, radius, 90, 0.25, thickness)
            renderer.circle_outline(x + w - radius, y + radius, r, g, b, a, radius, -90, 0.25, thickness)
            renderer.circle_outline(x + w - radius, y + h - radius, r, g, b, a, radius, 0, 0.25, thickness)
        end
    end,
    clamp = function(x, min, max)
        return x < min and min or x > max and max or x
    end,
    includes = function(tbl, value)
        for i = 1, #tbl do
            if tbl[i] == value then
                return true
            end
        end
        return false
    end,
    setAATab = function(ref)
        ui.set_visible(refs.enabled, ref)
        ui.set_visible(refs.pitch[1], ref)
        ui.set_visible(refs.pitch[2], ref)
        ui.set_visible(refs.roll, ref)
        ui.set_visible(refs.yawBase, ref)
        ui.set_visible(refs.yaw[1], ref)
        ui.set_visible(refs.yaw[2], ref)
        ui.set_visible(refs.yawJitter[1], ref)
        ui.set_visible(refs.yawJitter[2], ref)
        ui.set_visible(refs.bodyYaw[1], ref)
        ui.set_visible(refs.bodyYaw[2], ref)
        ui.set_visible(refs.freeStand[1], ref)
        ui.set_visible(refs.freeStand[2], ref)
        ui.set_visible(refs.fsBodyYaw, ref)
        ui.set_visible(refs.edgeYaw, ref)
    end,
    findDist = function (x1, y1, z1, x2, y2, z2)
        return math.sqrt((x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2)
    end,
    resetAATab = function()
        ui.set(refs.enabled, false)
        ui.set(refs.pitch[1], "Off")
        ui.set(refs.pitch[2], 0)
        ui.set(refs.roll, 0)
        ui.set(refs.yawBase, "local view")
        ui.set(refs.yaw[1], "Off")
        ui.set(refs.yaw[2], 0)
        ui.set(refs.yawJitter[1], "Off")
        ui.set(refs.yawJitter[2], 0)
        ui.set(refs.bodyYaw[1], "Off")
        ui.set(refs.bodyYaw[2], 0)
        ui.set(refs.freeStand[1], false)
        ui.set(refs.freeStand[2], "On hotkey")
        ui.set(refs.fsBodyYaw, false)
        ui.set(refs.edgeYaw, false)
    end,
    type_from_string = function(input)
        if type(input) ~= "string" then return input end

        local value = input:lower()

        if value == "true" then
            return true
        elseif value == "false" then
            return false
        elseif tonumber(value) ~= nil then
            return tonumber(value)
        else
            return tostring(input)
        end
    end,
    lerp = function(start, vend, time)
        return start + (vend - start) * time
    end,
    vec_angles = function(angle_x, angle_y)
        local sy = math.sin(math.rad(angle_y))
        local cy = math.cos(math.rad(angle_y))
        local sp = math.sin(math.rad(angle_x))
        local cp = math.cos(math.rad(angle_x))
        return cp * cy, cp * sy, -sp
    end,
    hex = function(arg)
        local result = "\a"
        for key, value in next, arg do
            local output = ""
            while value > 0 do
                local index = math.fmod(value, 16) + 1
                value = math.floor(value / 16)
                output = string.sub("0123456789ABCDEF", index, index) .. output 
            end
            if #output == 0 then 
                output = "00" 
            elseif #output == 1 then 
                output = "0" .. output 
            end 
            result = result .. output
        end 
        return result .. "FF"
    end,
    split = function( inputstr, sep)
        if sep == nil then
                sep = "%s"
        end
        local t={}
        for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
                table.insert(t, str)
        end
        return t
    end,
    RGBAtoHEX = function(redArg, greenArg, blueArg, alphaArg)
        return string.format('%.2x%.2x%.2x%.2x', redArg, greenArg, blueArg, alphaArg)
    end,
    create_color_array = function(r, g, b, string)
        local colors = {}
        for i = 0, #string do
            local color = {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime() / 4 + i * 5 / 30))}
            table.insert(colors, color)
        end
        return colors
    end,
    textArray = function(string)
        local result = {}
        for i=1, #string do
            result[i] = string.sub(string, i, i)
        end
        return result
    end,
    gradient_text = function(r1, g1, b1, a1, r2, g2, b2, a2, text)
        local output = ''
    
        local len = #text-1
    
        local rinc = (r2 - r1) / len
        local ginc = (g2 - g1) / len
        local binc = (b2 - b1) / len
        local ainc = (a2 - a1) / len
    
        for i=1, len+1 do
            output = output .. ('\a%02x%02x%02x%02x%s'):format(r1, g1, b1, a1, text:sub(i, i))
    
            r1 = r1 + rinc
            g1 = g1 + ginc
            b1 = b1 + binc
            a1 = a1 + ainc
        end
    
        return output
    end,    
    time_to_ticks = function(t)
        return math.floor(0.5 + (t / globals.tickinterval()))
    end,
    headVisible = function(enemy)
        local local_player = entity.get_local_player()
        if local_player == nil then return end
        local ex, ey, ez = entity.hitbox_position(enemy, 1)
    
        local hx, hy, hz = entity.hitbox_position(local_player, 1)
        local head_fraction, head_entindex_hit = client.trace_line(enemy, ex, ey, ez, hx, hy, hz)
        if head_entindex_hit == local_player or head_fraction == 1 then return true else return false end
    end,
    defensive = {
        cmd = 0,
        check = 0,
        defensive = 0,
    },
    aa_clamp = function(x) if x == nil then return 0 end x = (x % 360 + 360) % 360 return x > 180 and x - 360 or x end,
}

client.set_event_callback("run_command", function(e)
    func.defensive.cmd = e.command_number
end)
-- client.set_event_callback("predict_command", function(e)
--     if e.command_number == func.defensive.cmd then
--         local tickbase = entity.get_prop(entity.get_local_player(), "m_nTickBase")
--         func.defensive.defensive = math.abs(tickbase - func.defensive.check)
--         func.defensive.check = math.max(tickbase, func.defensive.check or 0)
--         func.defensive.cmd = 0
        
--     end
-- end)

-- client.set_event_callback("level_init", function() func.defensive.check, func.defensive.defensive = 0, 0 end)


-- render = function()
--     local x, y = client.screen_size()
--     local to_remove = {}
--     local Offset = 0
--     for i = 1, #data do
--         local notif = data[i]

--         local data = {rounding = 3, size = 2, glow = 2, time = 2}

--         if notif.time + data.time - globals.curtime() > 0 then
--             notif.fraction = func.clamp(notif.fraction + globals.frametime() / anim_time, 0, 1)
--         else
--             notif.fraction = func.clamp(notif.fraction - globals.frametime() / anim_time, 0, 1)
--         end

--         if notif.fraction <= 0 and notif.time + data.time - globals.curtime() <= 0 then
--             table.insert(to_remove, i)
--         end

--         if i > 7 then
--             table.remove(notif, i)
--         end

--         local fraction = func.easeInOut(notif.fraction)

--         local r, g, b, a = unpack(notif.color)
--         local string = color_text(notif.string, r, g, b, a * fraction)

--         local strw, strh = renderer.measure_text("", string)
--         local strw2 = renderer.measure_text("b", "")

--         local paddingx, paddingy = 7, data.size
--         local offsetY = y /2 - 350 --ui.get(menu.visualsTab.logOffset)
--         local icon_size = 35
--         local watermarkClr = {}
--         watermarkClr.r, watermarkClr.g, watermarkClr.b = ui.get(menu.visualsTab.indicatorsClr)
--         local width2 = vector(renderer.measure_text('', ("xo-yaw for gamesense | %s"):format(login.build)));


--         if ui.get(menu.visualsTab.logs_style) == "Default" then
--             Offset = Offset + (strh + paddingy*2 + 	math.sqrt(data.glow/10)*10 + 5) 
--             solus_render.container(x/2 - (strw + strw2)/2 * fraction - paddingx,y - offsetY - Offset * fraction - 10, (strw + strw2) + 10, 21,  watermarkClr.r, watermarkClr.g, watermarkClr.b, 50 * 1, 5, 255)
--             --logo:draw(x/2 + (strw/2 + 19) * fraction - paddingx, y - offsetY - Offset - (icon_size/2) + 2 - paddingy + 5, icon_size, nil,  watermarkClr.r, watermarkClr.g, watermarkClr.b, 255, true)
--             logo:draw(x/2 - (strw/2 + 40) * fraction - paddingx, y - offsetY - Offset - (icon_size/2) - paddingy + 3, icon_size, nil,  watermarkClr.r, watermarkClr.g, watermarkClr.b, 255, true)
--             --glow_module(x/2 - (strw + strw2)/2 - paddingx * fraction , y - offsetY - strh/2 - paddingy - Offset * fraction, strw + strw2 + paddingx*2, strh + paddingy*2, data.glow, data.rounding, {r, g, b, 155 * fraction}, {25,25,25,155 * fraction})
--             renderer.text(x/2 + strw2/2 * fraction, y - offsetY - Offset * fraction, 255, 255, 255, 255 * fraction, "c", 0, string)
--         elseif ui.get(menu.visualsTab.logs_style) == "OG" then
--             Offset = Offset + (strh + paddingy*2 + 	math.sqrt(data.glow/10)*10 + 9) 
--             render_ogskeet_border(x/2 - (strw/2), y - offsetY - Offset * fraction - 10, strw, 13, 255 * fraction, string)
--             --renderer.text(x/2 - (strw/2), y - offsetY - Offset * fraction - 10, 255, 255, 255, 255 * fraction, "c", 0, string)
--         elseif ui.get(menu.visualsTab.logs_style) == "Normal" then
--             Offset = Offset + (strh + paddingy*2 + 	math.sqrt(data.glow/10)*8) 
--             renderer.text(x/2, y - offsetY - Offset * fraction - 10, 255, 255, 255, 255 * fraction, "c", 0, string)
--         end
--     end
    

--     for i = #to_remove, 1, -1 do
--         table.remove(data, to_remove[i])
--     end
-- end,

client.set_event_callback( "net_update_start", function(  )
    local to_remove = {}
    for i = 1, #data do
        local native_GetClientEntity = vtable_bind("client.dll", "VClientEntityList003", 3, "uintptr_t(__thiscall*)(void*, int)");
        local player = entity.get_local_player( )

        if player == nil then
            return
        end

        local ptr = native_GetClientEntity(player);

        local m_flSimulationTime = entity.get_prop(player, "m_flSimulationTime");
        local m_flOldSimulationTime = ffi.cast("float*", ptr + 0x26C)[0];

        if (m_flSimulationTime - m_flOldSimulationTime < 0) then
            func.defensive.defensive_ticks = globals.tickcount() + toticks(.200);
            func.defensive.defensive = func.defensive.defensive_ticks
        end
    end

    for i = #to_remove, 1, -1 do
        table.remove(data, to_remove[i])
    end

end)



local clantag_anim = function(text, indices)
    local text_anim = "               " .. text ..                       "" 
    local tickinterval = globals.tickinterval()
    local tickcount = globals.tickcount() + func.time_to_ticks(client.latency())
    local i = tickcount / func.time_to_ticks(0.3)
    i = math.floor(i % #indices)
    i = indices[i+1]+1
    return string.sub(text_anim, i, i+15)
end

local trashtalk = function(e)

    local victim_userid, attacker_userid = e.userid, e.attacker
    if victim_userid == nil or attacker_userid == nil then
        return
    end

    local victim_entindex   = client.userid_to_entindex(victim_userid)
    local attacker_entindex = client.userid_to_entindex(attacker_userid)
    if attacker_entindex == entity.get_local_player() and entity.is_enemy(victim_entindex) then
        local phrase = kill[math.random(1, #kill)]
        local say = 'say ' .. phrase
        client.exec(say)
    end
end

local color_text = function( string, r, g, b, a)
    local accent = "\a" .. func.RGBAtoHEX(r, g, b, a)
    local white = "\a" .. func.RGBAtoHEX(255, 255, 255, a)

    local str = ""
    for i, s in ipairs(func.split(string, "$")) do
        str = str .. (i % 2 ==( string:sub(1, 1) == "$" and 0 or 1) and white or accent) .. s
    end

    return str
end

local animate_text = function(time, string, r, g, b, a)
    local t_out, t_out_iter = { }, 1

    local l = string:len( ) - 1

    local r_add = (255 - r)
    local g_add = (255 - g)
    local b_add = (255 - b)
    local a_add = (165 - a)

    for i = 1, #string do
        local iter = (i - 1)/(#string - 1) + time
        t_out[t_out_iter] = "\a" .. func.RGBAtoHEX( r + r_add * math.abs(math.cos( iter )), g + g_add * math.abs(math.cos( iter )), b + b_add * math.abs(math.cos( iter )), a + a_add * math.abs(math.cos( iter )) )

        t_out[t_out_iter + 1] = string:sub( i, i )

        t_out_iter = t_out_iter + 2
    end

    return t_out
end

local glow_module = function(x, y, w, h, width, rounding, accent, accent_inner)
    local thickness = 1
    local Offset = 1
    local r, g, b, a = unpack(accent)
    if accent_inner then
        func.rec(x, y, w, h + 1, rounding, accent_inner)
    end
    for k = 0, width do
        if a * (k/width)^(1) > 5 then
            local accent = {r, g, b, a * (k/width)^(2)}
            func.rec_outline(x + (k - width - Offset)*thickness, y + (k - width - Offset) * thickness, w - (k - width - Offset)*thickness*2, h + 1 - (k - width - Offset)*thickness*2, rounding + thickness * (width - k + Offset), thickness, accent)
        end
    end
end

local colorful_text = {
    lerp = function(self, from, to, duration)
        if type(from) == 'table' and type(to) == 'table' then
            return { 
                self:lerp(from[1], to[1], duration), 
                self:lerp(from[2], to[2], duration), 
                self:lerp(from[3], to[3], duration) 
            };
        end
    
        return from + (to - from) * duration;
    end,
    console = function(self, ...)
        for i, v in ipairs({ ... }) do
            if type(v[1]) == 'table' and type(v[2]) == 'table' and type(v[3]) == 'string' then
                for k = 1, #v[3] do
                    local l = self:lerp(v[1], v[2], k / #v[3]);
                    client.color_log(l[1], l[2], l[3], v[3]:sub(k, k) .. '\0');
                end
            elseif type(v[1]) == 'table' and type(v[2]) == 'string' then
                client.color_log(v[1][1], v[1][2], v[1][3], v[2] .. '\0');
            end
        end
    end,
    text = function(self, ...)
        local menu = false;
        local alpha = 255
        local f = '';
        
        for i, v in ipairs({ ... }) do
            if type(v) == 'boolean' then
                menu = v;
            elseif type(v) == 'number' then
                alpha = v;
            elseif type(v) == 'string' then
                f = f .. v;
            elseif type(v) == 'table' then
                if type(v[1]) == 'table' and type(v[2]) == 'string' then
                    f = f .. ('\a%02x%02x%02x%02x'):format(v[1][1], v[1][2], v[1][3], alpha) .. v[2];
                elseif type(v[1]) == 'table' and type(v[2]) == 'table' and type(v[3]) == 'string' then
                    for k = 1, #v[3] do
                        local g = self:lerp(v[1], v[2], k / #v[3])
                        f = f .. ('\a%02x%02x%02x%02x'):format(g[1], g[2], g[3], alpha) .. v[3]:sub(k, k)
                    end
                end
            end
        end
    
        return ('%s\a%s%02x'):format(f, (menu) and 'cdcdcd' or 'ffffff', alpha);
    end,
    log = function(self, ...)
        for i, v in ipairs({ ... }) do
            if type(v) == 'table' then
                if type(v[1]) == 'table' then
                    if type(v[2]) == 'string' then
                        self:console({ v[1], v[1], v[2] })
                        if (v[3]) then
                            self:console({ { 255, 255, 255 }, '\n' })
                        end
                    elseif type(v[2]) == 'table' then
                        self:console({ v[1], v[2], v[3] })
                        if v[4] then
                            self:console({ { 255, 255, 255 }, '\n' })
                        end
                    end
                elseif type(v[1]) == 'string' then
                    self:console({ { 205, 205, 205 }, v[1] });
                    if v[2] then
                        self:console({ { 255, 255, 255 }, '\n' })
                    end
                end
            end
        end
    end
}


local tab, container = "AA", "Anti-aimbot angles"
local masterSwitch = ui.new_checkbox(tab, container, "TAB\adec3c3ffSENSE - "..login.username.."")
local aaTabs = ui.new_combobox(tab, container, "\nAA Tabs", "Builder", "Keybinds", "Other")


local menu = {

    keys = {
        --Bindyhehe = ui.new_combobox(tab, "other", "\n", "Binds", "Other"),
       -- enable_key = ui.new_checkbox(tab, "other", "Key\adec3c3ffbinds"),
        freestandHotkey = ui.new_hotkey(tab, container, "Freest\adec3c3ffanding"),
        edgeYawHotkey = ui.new_hotkey(tab, container, "Edge\adec3c3ff Yaw"),
        manualTab = {
            manualLeft = ui.new_hotkey(tab, container, "Manual " .. func.hex({200,200,200}) .. "\adec3c3ffleft"),
            manualRight = ui.new_hotkey(tab, container, "Manual\adec3c3ff " .. func.hex({200,200,200}) .. "\adec3c3ffright"),
            manualForward = ui.new_hotkey(tab, container, "Manual\adec3c3ff " .. func.hex({200,200,200}) .. "\adec3c3ffforward"),
        },
        freestandDisablers = ui.new_multiselect(tab, container, "Freestand\adec3c3ff Disablers", {"Aero", "Duck", "Manual"}),
    },

    aaTab = {
        lol = ui.new_multiselect(tab, container, "Extra\adec3c3ff", {"Safe Knife", "Avoid Backstab", "Static on Manual"}),
    },

    --("\badffff\bfacfff[TAB]\n"
    resolver = {
        xddd = ui.new_multiselect("Players", "Adjustments", "Vis\abfacffffuals", {"Debug Panel"}),
        debug_style = ui.new_combobox("Players", "Adjustments", "Debug \abfacffffstyle", {"Default", "Skeet border"}),
        other_menu = ui.new_multiselect("Players", "Adjustments", "Oth\abfacffffer", {"Defensive Resolver", "Math Random Resolver"}),
        --resolver_disabler = ui.new_multiselect("Players", "Adjustments", "Resolver Disabler", {"CORRECTION ACTIVE","STAND", "MOVE", "CROUCH", "INAIR", "SLOWWALK"}),
    },


    builderTab = {
        PresetComboBox = ui.new_combobox(tab, "Fake Lag", "Pres\adec3c3ffets", "Disabled", "Unmatched", "Community"),
       -- buttonPresets = ui.new_button(tab, "Fake Lag", "Pres\adec3c3ffets", function() end),
        LogicComboBox = ui.new_combobox(tab, "Fake Lag", "logica\adec3c3ff secret", "1", "2"),
        buttonBuilder = ui.new_button(tab, "Fake Lag", "Builder", function() end),
        state = ui.new_combobox(tab, container, "Anti-aim state", vars.aaStates)
    },
    visualsTab = {
        indicators = ui.new_combobox(tab, container, " Indic\adec3c3ffators", "Disabled", "New", "Second"),
        indicatorsClr = ui.new_color_picker(tab, container, " Main \adec3c3ffColor", lua_color.r, lua_color.g, lua_color.b, 255),
        defensive_indicator = ui.new_multiselect(tab, container, "Select \adec3c3ffIndicator", "Defensive", "Slowdown", "Kibit"),
        defensive_indicatorClr = ui.new_color_picker(tab, container, " Indicators \adec3c3ffColor", lua_color.r, lua_color.g, lua_color.b, 255),
        arrows = ui.new_checkbox(tab, container, " Arr\adec3c3ffows"),
        arrowClr = ui.new_color_picker(tab, container, "Arrow Color", lua_color.r, lua_color.g, lua_color.b, 255),
        arrowIndicatorStyle = ui.new_combobox(tab, container, "\n arrows style", "-", "Teamskeet", "Normal"),
        velocity_ada = ui.new_checkbox(tab, container, " Velocity \adec3c3ffadaptive"),
        watermark = ui.new_checkbox(tab, container, " Water\adec3c3ffmark"),
        watermark_pos = ui.new_combobox(tab, container, " Water\adec3c3ffmark posiotion", {"left", "right", "bottom", "top"}),
        watermark_opt = ui.new_checkbox(tab, container, " Remove \adec3c3ffspaces"),
        watermarkClr = ui.new_color_picker(tab, container, " Watermark\adec3c3ff Color", lua_color.r, lua_color.g, lua_color.b, 255),
        watermark_og_opt = ui.new_multiselect(tab, container, " Watermark\adec3c3ff Options", {"fps", "ping", "time"}),
        logs = ui.new_checkbox(tab, container, " Screen\adec3c3ff Hit Logs"),
        logsClr = ui.new_color_picker(tab, container, "Logs\adec3c3ff Color", lua_color.r, lua_color.g, lua_color.b, 255),
        logs_style = ui.new_combobox(tab,container, "Logs\adec3c3ff Style", {"Default", "OG", "Normal"}),
    },
    miscTab = {
        trashTalk = ui.new_checkbox(tab, container, " Trash\adec3c3ffTalk"),
        fastLadderEnabled = ui.new_checkbox(tab, container, " Fast\adec3c3ff ladder"),
        fastLadder = ui.new_multiselect(tab, container, "\n  fast\adec3c3ff ladder", "Ascending", "Descending"),
        animationsEnabled = ui.new_checkbox(tab, container, " Local\adec3c3ff animations"),
        animations = ui.new_multiselect(tab, container, "\n  animation\adec3c3ff breakers", "Break legs while in Aero", "Reset pitch on land", "Leg fucker", "Be Micheal Jackson"),
    },
    configTab = {
        list = ui.new_listbox(tab, container, "Configs", ""),
        name = ui.new_textbox(tab, container, "Name", ""),
        load = ui.new_button(tab, container, "Load", function() end),
        save = ui.new_button(tab, container, "Save", function() end),
        delete = ui.new_button(tab, container, "Delete", function() end),
        import = ui.new_button(tab, container, "Import Settings", function() end),
        export = ui.new_button(tab, container, "Share", function() end)
    },
}

local aaBuilder = {}
local aaContainer = {}
for i=1, #vars.aaStates do
    aaContainer[i] = func.hex({200,200,200}) .. "(" .. func.hex({222,55,55}) .. "" .. vars.pStates[i] .. "" .. func.hex({200,200,200}) .. ")" .. func.hex({155,155,155}) .. " "
    aaBuilder[i] = {
--    aa_builder[i].pitch = group:combobox("\v"..aa_state_full[i].."\r  Pitch", "Off", "Down", "Up")


        enableState = ui.new_checkbox(tab, container, "Enable " .. func.hex({lua_color.r, lua_color.g, lua_color.b}) .. vars.aaStates[i] .. func.hex({200,200,200})),
        pitch = ui.new_combobox(tab, container, " Pitch\n" .. aaContainer[i], "Off", "Default", "Minimal", "Up", "Custom"),
        pitchSlider = ui.new_slider(tab, container, "\n Pitch add" .. aaContainer[i], -89, 89, 0, true, "", 1),
        yawBase = ui.new_combobox(tab, container, " View\n" .. aaContainer[i], "Local view", "At targets"),
   --     'Off', '180', 'Spin', 'Static', '180 Z', 'Crosshair'
        yaw = ui.new_combobox(tab, container, " Yaw\n" .. aaContainer[i], 'Off', '180', 'Spin', 'Static', '180 Z', 'Crosshair'),
        yawCondition = ui.new_combobox(tab, container, " Yaw modes\n" .. aaContainer[i], "Static", "L & R", "Delay", "Tickbased"),
        yawStatic = ui.new_slider(tab, container, " Amount\n" .. aaContainer[i], -180, 180, 0, true, "", 1),
        yawLeft = ui.new_slider(tab, container, " L\n" .. aaContainer[i], -180, 180, 0, true, "", 1),
        yawRight = ui.new_slider(tab, container, " R\n" .. aaContainer[i], -180, 180, 0, true, "", 1),
        yawSpeed = ui.new_slider(tab, container, " Delay\n" .. aaContainer[i], 1, 14, 6, 0),
        yawJitter = ui.new_combobox(tab, container, " Yaw jitter mode\n" .. aaContainer[i], "Off", "Offset", "Center", "Random", "Sync", "TabJitter"),
        yawJitterCondition = ui.new_combobox(tab, container, " Conditions\n" .. aaContainer[i], "Static", "L & R"),
        yawJitterStatic = ui.new_slider(tab, container, "\nyaw jitter limit" .. aaContainer[i], -180, 180, 0, true, "", 1),
        yawJitterLeft = ui.new_slider(tab, container, " L\nyaw jitter" .. aaContainer[i], -180, 180, 0, true, "", 1),
        yawJitterRight = ui.new_slider(tab, container, " R\nyaw jitter" .. aaContainer[i], -180, 180, 0, true, "", 1),
        bodyYaw = ui.new_combobox(tab, container, " Body yaw\n" .. aaContainer[i], "Off", "Opposite", "Jitter", "Static"),
        bodyYawSlider = ui.new_slider(tab, container, "\n body yaw limit" .. aaContainer[i], -180, 180, 0, true, "", 1),
        enabledefensive = ui.new_checkbox(tab, container, "Enable Defensive\n" .. aaContainer[i]),
        defensiveOpt = ui.new_combobox(tab, container, " Defensive Mode\n" .. aaContainer[i], "None", "Always on", "Time to ticks", "Hold Ticks"),
        defensiveYaw = ui.new_combobox(tab, container, " Defensive Type\n" .. aaContainer[i], "None", "Jitter", "Flick", "Spin", "Custom"),
        defensiveYawSlider = ui.new_slider(tab, container, "\n DefensiveYawSlider" .. aaContainer[i], -180, 180, 0, true, "", 1),
        defensivePitch = ui.new_combobox(tab, container, " Defensive pitch\n" .. aaContainer[i], "None", "Up", "Swap", "Custom", "Random"),
        defensivePitchSlider = ui.new_slider(tab, container, "\nDefensivePitchSlider" .. aaContainer[i], -89, 89, 0, true, "", 1),
    }
end

local function getConfig(name)
    local database = database.read(lua.database.configs) or {}

    for i, v in pairs(database) do
        if v.name == name then
            return {
                config = v.config,
                index = i
            }
        end
    end

    for i, v in pairs(presets) do
        if v.name == name then
            return {
                config = v.config,
                index = i
            }
        end
    end

    return false
end
local function saveConfig(name)
    local db = database.read(lua.database.configs) or {}
    local config = {}

    if name:match("[^%w]") ~= nil then
        return
    end

    for key, value in pairs(vars.pStates) do
        config[value] = {}
        for k, v in pairs(aaBuilder[key]) do
            config[value][k] = ui.get(v)
        end
    end

    local cfg = getConfig(name)

    if not cfg then
        table.insert(db, { name = name, config = config })
    else
        db[cfg.index].config = config
    end

    database.write(lua.database.configs, db)
end
local function deleteConfig(name)
    local db = database.read(lua.database.configs) or {}

    for i, v in pairs(db) do
        if v.name == name then
            table.remove(db, i)
            break
        end
    end

    for i, v in pairs(presets) do
        if v.name == name then
            return false
        end
    end

    database.write(lua.database.configs, db)
end
local function getConfigList()
    local database = database.read(lua.database.configs) or {}
    local config = {}

    for i, v in pairs(presets) do
        table.insert(config, v.name)
    end

    for i, v in pairs(database) do
        table.insert(config, v.name)
    end

    return config
end
local function typeFromString(input)
    if type(input) ~= "string" then return input end

    local value = input:lower()

    if value == "true" then
        return true
    elseif value == "false" then
        return false
    elseif tonumber(value) ~= nil then
        return tonumber(value)
    else
        return tostring(input)
    end
end
local inspect = try_require('gamesense/inspect')
local function loadSettings(e)
    for key, value in pairs(vars.pStates) do
        for k, v in pairs(aaBuilder[key]) do
            if (e[value][k] ~= nil) then
                ui.set(v, e[value][k])
            end
        end 
    end
end
local alph = "base64"
local function importSettings()
    local frombuffer = clipboard.get()
    local decode = base64.decode(frombuffer, alph)
    local toTable = json.parse(decode)
    loadSettings(toTable.config)
end
local function importPreset()
    local frombuffer = "eyJpbmRleCI6MiwiY29uZmlnIjp7IkxBIjp7InBpdGNoIjoiT2ZmIiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOjAsInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJ5YXdMZWZ0IjowLCJkZWZlbnNpdmVQaXRjaCI6Ik5vbmUiLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOmZhbHNlLCJkZWZlbnNpdmVZYXciOiJOb25lIiwieWF3UmlnaHQiOjAsImJvZHlZYXciOiJPZmYiLCJ5YXciOiJPZmYiLCJ5YXdTdGF0aWMiOjAsInlhd0NvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlciI6Ik9mZiIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6Ik5vbmUiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJTdGF0aWMiLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJMb2NhbCB2aWV3In0sIlNXIjp7InBpdGNoIjoiRGVmYXVsdCIsInBpdGNoU2xpZGVyIjowLCJib2R5WWF3U2xpZGVyIjotMTksInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJ5YXdMZWZ0IjotMTksImRlZmVuc2l2ZVBpdGNoIjoiTm9uZSIsImVuYWJsZWRlZmVuc2l2ZSI6ZmFsc2UsImRlZmVuc2l2ZVBpdGNoU2xpZGVyIjowLCJlbmFibGVTdGF0ZSI6dHJ1ZSwiZGVmZW5zaXZlWWF3IjoiTm9uZSIsInlhd1JpZ2h0IjoyNywiYm9keVlhdyI6IkppdHRlciIsInlhdyI6IjE4MCIsInlhd1N0YXRpYyI6MCwieWF3Q29uZGl0aW9uIjoiTCAmIFIiLCJ5YXdKaXR0ZXIiOiJDZW50ZXIiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjoyNywiZGVmZW5zaXZlT3B0IjoiTm9uZSIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiUyI6eyJwaXRjaCI6IkRlZmF1bHQiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6LTE5LCJ5YXdKaXR0ZXJMZWZ0IjozOCwieWF3Sml0dGVyUmlnaHQiOjQxLCJ5YXdMZWZ0IjotMTUsImRlZmVuc2l2ZVBpdGNoIjoiTm9uZSIsImVuYWJsZWRlZmVuc2l2ZSI6ZmFsc2UsImRlZmVuc2l2ZVBpdGNoU2xpZGVyIjowLCJlbmFibGVTdGF0ZSI6dHJ1ZSwiZGVmZW5zaXZlWWF3IjoiTm9uZSIsInlhd1JpZ2h0Ijo5LCJib2R5WWF3IjoiSml0dGVyIiwieWF3IjoiMTgwIiwieWF3U3RhdGljIjowLCJ5YXdDb25kaXRpb24iOiJMICYgUiIsInlhd0ppdHRlciI6IkNlbnRlciIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6Ik5vbmUiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJMICYgUiIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiQUMiOnsicGl0Y2giOiJEZWZhdWx0IiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOi0xOSwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsInlhd0xlZnQiOi00MSwiZGVmZW5zaXZlUGl0Y2giOiJOb25lIiwiZW5hYmxlZGVmZW5zaXZlIjpmYWxzZSwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjp0cnVlLCJkZWZlbnNpdmVZYXciOiJOb25lIiwieWF3UmlnaHQiOi0yOCwiYm9keVlhdyI6IkppdHRlciIsInlhdyI6IjE4MCIsInlhd1N0YXRpYyI6MCwieWF3Q29uZGl0aW9uIjoiTCAmIFIiLCJ5YXdKaXR0ZXIiOiJPZmZzZXQiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjo2MSwiZGVmZW5zaXZlT3B0IjoiTm9uZSIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiQSI6eyJwaXRjaCI6IkRlZmF1bHQiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6LTIxLCJ5YXdKaXR0ZXJMZWZ0IjowLCJ5YXdKaXR0ZXJSaWdodCI6MCwieWF3TGVmdCI6LTQxLCJkZWZlbnNpdmVQaXRjaCI6Ik5vbmUiLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOnRydWUsImRlZmVuc2l2ZVlhdyI6Ik5vbmUiLCJ5YXdSaWdodCI6MjgsImJvZHlZYXciOiJKaXR0ZXIiLCJ5YXciOiIxODAiLCJ5YXdTdGF0aWMiOjAsInlhd0NvbmRpdGlvbiI6IkwgJiBSIiwieWF3Sml0dGVyIjoiT2Zmc2V0IiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6NSwiZGVmZW5zaXZlT3B0IjoiTm9uZSIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiTSI6eyJwaXRjaCI6IkRlZmF1bHQiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6LTE5LCJ5YXdKaXR0ZXJMZWZ0IjowLCJ5YXdKaXR0ZXJSaWdodCI6MCwieWF3TGVmdCI6LTMyLCJkZWZlbnNpdmVQaXRjaCI6Ik5vbmUiLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOnRydWUsImRlZmVuc2l2ZVlhdyI6Ik5vbmUiLCJ5YXdSaWdodCI6MjcsImJvZHlZYXciOiJKaXR0ZXIiLCJ5YXciOiIxODAiLCJ5YXdTdGF0aWMiOjAsInlhd0NvbmRpdGlvbiI6IkwgJiBSIiwieWF3Sml0dGVyIjoiQ2VudGVyIiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6MTAsImRlZmVuc2l2ZU9wdCI6Ik5vbmUiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJTdGF0aWMiLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJBdCB0YXJnZXRzIn0sIkMiOnsicGl0Y2giOiJEZWZhdWx0IiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOi0xOSwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsInlhd0xlZnQiOi0yNSwiZGVmZW5zaXZlUGl0Y2giOiJOb25lIiwiZW5hYmxlZGVmZW5zaXZlIjpmYWxzZSwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjp0cnVlLCJkZWZlbnNpdmVZYXciOiJOb25lIiwieWF3UmlnaHQiOjE0LCJib2R5WWF3IjoiSml0dGVyIiwieWF3IjoiMTgwIiwieWF3U3RhdGljIjowLCJ5YXdDb25kaXRpb24iOiJMICYgUiIsInlhd0ppdHRlciI6Ik9mZnNldCIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjM0LCJkZWZlbnNpdmVPcHQiOiJOb25lIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiU3RhdGljIiwiZGVmZW5zaXZlWWF3U2xpZGVyIjowLCJ5YXdCYXNlIjoiQXQgdGFyZ2V0cyJ9LCJHIjp7InBpdGNoIjoiRGVmYXVsdCIsInBpdGNoU2xpZGVyIjowLCJib2R5WWF3U2xpZGVyIjotMSwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsInlhd0xlZnQiOi00NiwiZGVmZW5zaXZlUGl0Y2giOiJSYW5kb20iLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOnRydWUsImRlZmVuc2l2ZVlhdyI6IkppdHRlciIsInlhd1JpZ2h0IjozOSwiYm9keVlhdyI6IkppdHRlciIsInlhdyI6IjE4MCIsInlhd1N0YXRpYyI6MCwieWF3Q29uZGl0aW9uIjoiTCAmIFIiLCJ5YXdKaXR0ZXIiOiJPZmYiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjowLCJkZWZlbnNpdmVPcHQiOiJIb2xkIFRpY2tzIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiTCAmIFIiLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJBdCB0YXJnZXRzIn19fQ=="
    local decode = base64.decode(frombuffer, alph)
    local toTable = json.parse(decode)
    loadSettings(toTable.config)
end
local function importPresetClear()
    local frombuffer = "eyJpbmRleCI6OCwiY29uZmlnIjp7IkxBIjp7InBpdGNoIjoiT2ZmIiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOjAsInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJib2R5WWF3IjoiT2ZmIiwiZGVmZW5zaXZlUGl0Y2giOiItIiwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjpmYWxzZSwiZGVmZW5zaXZlWWF3IjoiLSIsInlhd1JpZ2h0IjowLCJ5YXdKaXR0ZXJEaXNhYmxlcnMiOnt9LCJ5YXdTdGF0aWMiOjAsInlhdyI6Ik9mZiIsInlhd0NvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlciI6Ik9mZiIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6e30sInlhd0xlZnQiOjAsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkxvY2FsIHZpZXcifSwiU1ciOnsicGl0Y2giOiJPZmYiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6MCwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsImJvZHlZYXciOiJPZmYiLCJkZWZlbnNpdmVQaXRjaCI6Ii0iLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOmZhbHNlLCJkZWZlbnNpdmVZYXciOiItIiwieWF3UmlnaHQiOjAsInlhd0ppdHRlckRpc2FibGVycyI6e30sInlhd1N0YXRpYyI6MCwieWF3IjoiT2ZmIiwieWF3Q29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyIjoiT2ZmIiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6MCwiZGVmZW5zaXZlT3B0Ijp7fSwieWF3TGVmdCI6MCwiZGVmZW5zaXZlWWF3U2xpZGVyIjowLCJ5YXdCYXNlIjoiTG9jYWwgdmlldyJ9LCJTIjp7InBpdGNoIjoiT2ZmIiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOjAsInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJib2R5WWF3IjoiT2ZmIiwiZGVmZW5zaXZlUGl0Y2giOiItIiwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjpmYWxzZSwiZGVmZW5zaXZlWWF3IjoiLSIsInlhd1JpZ2h0IjowLCJ5YXdKaXR0ZXJEaXNhYmxlcnMiOnt9LCJ5YXdTdGF0aWMiOjAsInlhdyI6Ik9mZiIsInlhd0NvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlciI6Ik9mZiIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6e30sInlhd0xlZnQiOjAsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkxvY2FsIHZpZXcifSwiQUMiOnsicGl0Y2giOiJPZmYiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6MCwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsImJvZHlZYXciOiJPZmYiLCJkZWZlbnNpdmVQaXRjaCI6Ii0iLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOmZhbHNlLCJkZWZlbnNpdmVZYXciOiItIiwieWF3UmlnaHQiOjAsInlhd0ppdHRlckRpc2FibGVycyI6e30sInlhd1N0YXRpYyI6MCwieWF3IjoiT2ZmIiwieWF3Q29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyIjoiT2ZmIiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6MCwiZGVmZW5zaXZlT3B0Ijp7fSwieWF3TGVmdCI6MCwiZGVmZW5zaXZlWWF3U2xpZGVyIjowLCJ5YXdCYXNlIjoiTG9jYWwgdmlldyJ9LCJBIjp7InBpdGNoIjoiT2ZmIiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOjAsInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJib2R5WWF3IjoiT2ZmIiwiZGVmZW5zaXZlUGl0Y2giOiItIiwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjpmYWxzZSwiZGVmZW5zaXZlWWF3IjoiLSIsInlhd1JpZ2h0IjowLCJ5YXdKaXR0ZXJEaXNhYmxlcnMiOnt9LCJ5YXdTdGF0aWMiOjAsInlhdyI6Ik9mZiIsInlhd0NvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlciI6Ik9mZiIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6e30sInlhd0xlZnQiOjAsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkxvY2FsIHZpZXcifSwiTSI6eyJwaXRjaCI6Ik9mZiIsInBpdGNoU2xpZGVyIjowLCJib2R5WWF3U2xpZGVyIjowLCJ5YXdKaXR0ZXJMZWZ0IjowLCJ5YXdKaXR0ZXJSaWdodCI6MCwiYm9keVlhdyI6Ik9mZiIsImRlZmVuc2l2ZVBpdGNoIjoiLSIsImRlZmVuc2l2ZVBpdGNoU2xpZGVyIjowLCJlbmFibGVTdGF0ZSI6ZmFsc2UsImRlZmVuc2l2ZVlhdyI6Ii0iLCJ5YXdSaWdodCI6MCwieWF3Sml0dGVyRGlzYWJsZXJzIjp7fSwieWF3U3RhdGljIjowLCJ5YXciOiJPZmYiLCJ5YXdDb25kaXRpb24iOiJTdGF0aWMiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJTdGF0aWMiLCJ5YXdKaXR0ZXIiOiJPZmYiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjowLCJkZWZlbnNpdmVPcHQiOnt9LCJ5YXdMZWZ0IjowLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJMb2NhbCB2aWV3In0sIkMiOnsicGl0Y2giOiJPZmYiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6MCwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsImJvZHlZYXciOiJPZmYiLCJkZWZlbnNpdmVQaXRjaCI6Ii0iLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOmZhbHNlLCJkZWZlbnNpdmVZYXciOiItIiwieWF3UmlnaHQiOjAsInlhd0ppdHRlckRpc2FibGVycyI6e30sInlhd1N0YXRpYyI6MCwieWF3IjoiT2ZmIiwieWF3Q29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyIjoiT2ZmIiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6MCwiZGVmZW5zaXZlT3B0Ijp7fSwieWF3TGVmdCI6MCwiZGVmZW5zaXZlWWF3U2xpZGVyIjowLCJ5YXdCYXNlIjoiTG9jYWwgdmlldyJ9LCJHIjp7InBpdGNoIjoiT2ZmIiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOjAsInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJib2R5WWF3IjoiT2ZmIiwiZGVmZW5zaXZlUGl0Y2giOiItIiwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjp0cnVlLCJkZWZlbnNpdmVZYXciOiItIiwieWF3UmlnaHQiOjAsInlhd0ppdHRlckRpc2FibGVycyI6e30sInlhd1N0YXRpYyI6MCwieWF3IjoiT2ZmIiwieWF3Q29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyIjoiT2ZmIiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6MCwiZGVmZW5zaXZlT3B0Ijp7fSwieWF3TGVmdCI6MCwiZGVmZW5zaXZlWWF3U2xpZGVyIjowLCJ5YXdCYXNlIjoiTG9jYWwgdmlldyJ9fX0="
    local decode = base64.decode(frombuffer, alph)
    local toTable = json.parse(decode)
    loadSettings(toTable.config)
end
local function importPreset2()
    local frombuffer = "eyJpbmRleCI6MiwiY29uZmlnIjp7IkxBIjp7InBpdGNoIjoiT2ZmIiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOjAsInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJ5YXdMZWZ0IjowLCJkZWZlbnNpdmVQaXRjaCI6Ik5vbmUiLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOmZhbHNlLCJkZWZlbnNpdmVZYXciOiJOb25lIiwieWF3UmlnaHQiOjAsImJvZHlZYXciOiJPZmYiLCJ5YXciOiJPZmYiLCJ5YXdTdGF0aWMiOjAsInlhd0NvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlciI6Ik9mZiIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6Ik5vbmUiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJTdGF0aWMiLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJMb2NhbCB2aWV3In0sIlNXIjp7InBpdGNoIjoiRGVmYXVsdCIsInBpdGNoU2xpZGVyIjowLCJib2R5WWF3U2xpZGVyIjotMTksInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJ5YXdMZWZ0IjotMTksImRlZmVuc2l2ZVBpdGNoIjoiTm9uZSIsImVuYWJsZWRlZmVuc2l2ZSI6ZmFsc2UsImRlZmVuc2l2ZVBpdGNoU2xpZGVyIjowLCJlbmFibGVTdGF0ZSI6dHJ1ZSwiZGVmZW5zaXZlWWF3IjoiTm9uZSIsInlhd1JpZ2h0IjoyNywiYm9keVlhdyI6IkppdHRlciIsInlhdyI6IjE4MCIsInlhd1N0YXRpYyI6MCwieWF3Q29uZGl0aW9uIjoiTCAmIFIiLCJ5YXdKaXR0ZXIiOiJDZW50ZXIiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjoyNywiZGVmZW5zaXZlT3B0IjoiTm9uZSIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiUyI6eyJwaXRjaCI6IkRlZmF1bHQiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6LTE5LCJ5YXdKaXR0ZXJMZWZ0IjozOCwieWF3Sml0dGVyUmlnaHQiOjQxLCJ5YXdMZWZ0IjotMTUsImRlZmVuc2l2ZVBpdGNoIjoiTm9uZSIsImVuYWJsZWRlZmVuc2l2ZSI6ZmFsc2UsImRlZmVuc2l2ZVBpdGNoU2xpZGVyIjowLCJlbmFibGVTdGF0ZSI6dHJ1ZSwiZGVmZW5zaXZlWWF3IjoiTm9uZSIsInlhd1JpZ2h0Ijo5LCJib2R5WWF3IjoiSml0dGVyIiwieWF3IjoiMTgwIiwieWF3U3RhdGljIjowLCJ5YXdDb25kaXRpb24iOiJMICYgUiIsInlhd0ppdHRlciI6IkNlbnRlciIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6Ik5vbmUiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJMICYgUiIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiQUMiOnsicGl0Y2giOiJEZWZhdWx0IiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOi0xOSwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsInlhd0xlZnQiOi00MSwiZGVmZW5zaXZlUGl0Y2giOiJOb25lIiwiZW5hYmxlZGVmZW5zaXZlIjpmYWxzZSwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjp0cnVlLCJkZWZlbnNpdmVZYXciOiJOb25lIiwieWF3UmlnaHQiOi0yOCwiYm9keVlhdyI6IkppdHRlciIsInlhdyI6IjE4MCIsInlhd1N0YXRpYyI6MCwieWF3Q29uZGl0aW9uIjoiTCAmIFIiLCJ5YXdKaXR0ZXIiOiJPZmZzZXQiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjo2MSwiZGVmZW5zaXZlT3B0IjoiTm9uZSIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiQSI6eyJwaXRjaCI6IkRlZmF1bHQiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6LTIxLCJ5YXdKaXR0ZXJMZWZ0IjowLCJ5YXdKaXR0ZXJSaWdodCI6MCwieWF3TGVmdCI6LTQxLCJkZWZlbnNpdmVQaXRjaCI6Ik5vbmUiLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOnRydWUsImRlZmVuc2l2ZVlhdyI6Ik5vbmUiLCJ5YXdSaWdodCI6MjgsImJvZHlZYXciOiJKaXR0ZXIiLCJ5YXciOiIxODAiLCJ5YXdTdGF0aWMiOjAsInlhd0NvbmRpdGlvbiI6IkwgJiBSIiwieWF3Sml0dGVyIjoiT2Zmc2V0IiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6NSwiZGVmZW5zaXZlT3B0IjoiTm9uZSIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiTSI6eyJwaXRjaCI6IkRlZmF1bHQiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6LTE5LCJ5YXdKaXR0ZXJMZWZ0IjowLCJ5YXdKaXR0ZXJSaWdodCI6MCwieWF3TGVmdCI6LTMyLCJkZWZlbnNpdmVQaXRjaCI6Ik5vbmUiLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOnRydWUsImRlZmVuc2l2ZVlhdyI6Ik5vbmUiLCJ5YXdSaWdodCI6MjcsImJvZHlZYXciOiJKaXR0ZXIiLCJ5YXciOiIxODAiLCJ5YXdTdGF0aWMiOjAsInlhd0NvbmRpdGlvbiI6IkwgJiBSIiwieWF3Sml0dGVyIjoiQ2VudGVyIiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6MTAsImRlZmVuc2l2ZU9wdCI6Ik5vbmUiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJTdGF0aWMiLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJBdCB0YXJnZXRzIn0sIkMiOnsicGl0Y2giOiJEZWZhdWx0IiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOi0xOSwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsInlhd0xlZnQiOi0yNSwiZGVmZW5zaXZlUGl0Y2giOiJOb25lIiwiZW5hYmxlZGVmZW5zaXZlIjpmYWxzZSwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjp0cnVlLCJkZWZlbnNpdmVZYXciOiJOb25lIiwieWF3UmlnaHQiOjE0LCJib2R5WWF3IjoiSml0dGVyIiwieWF3IjoiMTgwIiwieWF3U3RhdGljIjowLCJ5YXdDb25kaXRpb24iOiJMICYgUiIsInlhd0ppdHRlciI6Ik9mZnNldCIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjM0LCJkZWZlbnNpdmVPcHQiOiJOb25lIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiU3RhdGljIiwiZGVmZW5zaXZlWWF3U2xpZGVyIjowLCJ5YXdCYXNlIjoiQXQgdGFyZ2V0cyJ9LCJHIjp7InBpdGNoIjoiRGVmYXVsdCIsInBpdGNoU2xpZGVyIjowLCJib2R5WWF3U2xpZGVyIjotMSwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsInlhd0xlZnQiOi00NiwiZGVmZW5zaXZlUGl0Y2giOiJSYW5kb20iLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOnRydWUsImRlZmVuc2l2ZVlhdyI6IkppdHRlciIsInlhd1JpZ2h0IjozOSwiYm9keVlhdyI6IkppdHRlciIsInlhdyI6IjE4MCIsInlhd1N0YXRpYyI6MCwieWF3Q29uZGl0aW9uIjoiTCAmIFIiLCJ5YXdKaXR0ZXIiOiJPZmYiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjowLCJkZWZlbnNpdmVPcHQiOiJIb2xkIFRpY2tzIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiTCAmIFIiLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJBdCB0YXJnZXRzIn19fQ=="
    local decode = base64.decode(frombuffer, alph)
    local toTable = json.parse(decode)
    loadSettings(toTable.config)
end

local function exportSettings(name)
    local config = getConfig(name)
    local toString = json.stringify(config)
    local toExport = base64.encode(toString, alph)
    clipboard.set(toExport)
end
local function loadConfig(name)
    local config = getConfig(name)
    loadSettings(config.config)
end

local function initDatabase()
    if database.read(lua.database.configs) == nil then
        database.write(lua.database.configs, {})
    end

    local link = "https://pastebin.com/raw/afg2YkEv"

    http.get(link, function(success, response)
        if not success then
            print("Failed to load config [422]")
            return
        end
    
        local data = json.parse(response.body)
    
        for i, preset in pairs(data.presets) do
            table.insert(presets, { name = "*"..preset.name, config = preset.config})
            ui.set(menu.configTab.name, "*"..preset.name)
        end
        ui.update(menu.configTab.list, getConfigList())
    end)
end
initDatabase()

local anim_time = 0.3
local max_notifs = 6
local data = {}
local notifications = {

    new = function(string, r, g, b)
        table.insert(data, {
            time = globals.curtime(),
            string = string,
            color = {r, g, b, 255},
            fraction = 0
        })
        local time = 5
        for i = #data, 1, -1 do
            local notif = data[i]
            if #data - i + 1 > max_notifs and notif.time + time - globals.curtime() > 0 then
                notif.time = globals.curtime() - time
            end
        end
    end,

    render = function()
        local x, y = client.screen_size()
        local to_remove = {}
        local Offset = 0
        for i = 1, #data do
            local notif = data[i]

            local data = {rounding = 3, size = 2, glow = 2, time = 2}

            if notif.time + data.time - globals.curtime() > 0 then
                notif.fraction = func.clamp(notif.fraction + globals.frametime() / anim_time, 0, 1)
            else
                notif.fraction = func.clamp(notif.fraction - globals.frametime() / anim_time, 0, 1)
            end

            if notif.fraction <= 0 and notif.time + data.time - globals.curtime() <= 0 then
                table.insert(to_remove, i)
            end

            if i > 7 then
                table.remove(notif, i)
            end

            local fraction = func.easeInOut(notif.fraction)

            local r, g, b, a = unpack(notif.color)
            local string = color_text(notif.string, r, g, b, a * fraction)

            local strw, strh = renderer.measure_text("", string)
            local strw2 = renderer.measure_text("b", "")

            local paddingx, paddingy = 7, data.size
            local offsetY = y /2 - 350 --ui.get(menu.visualsTab.logOffset)
            local icon_size = 35
            local watermarkClr = {}
            watermarkClr.r, watermarkClr.g, watermarkClr.b = ui.get(menu.visualsTab.indicatorsClr)
            local width2 = vector(renderer.measure_text('', ("xo-yaw for gamesense | %s"):format(login.build)));


            if ui.get(menu.visualsTab.logs_style) == "Default" then
                Offset = Offset + (strh + paddingy*2 + 	math.sqrt(data.glow/10)*10 + 5) 
                solus_render.container(x/2 - (strw + strw2)/2 * fraction - paddingx,y - offsetY - Offset * fraction - 10, (strw + strw2) + 10, 21,  watermarkClr.r, watermarkClr.g, watermarkClr.b, 50 * 1, 5, 255)
                --logo:draw(x/2 + (strw/2 + 19) * fraction - paddingx, y - offsetY - Offset - (icon_size/2) + 2 - paddingy + 5, icon_size, nil,  watermarkClr.r, watermarkClr.g, watermarkClr.b, 255, true)
                logo:draw(x/2 - (strw/2 + 40) * fraction - paddingx, y - offsetY - Offset - (icon_size/2) - paddingy + 3, icon_size, nil,  watermarkClr.r, watermarkClr.g, watermarkClr.b, 255, true)
                --glow_module(x/2 - (strw + strw2)/2 - paddingx * fraction , y - offsetY - strh/2 - paddingy - Offset * fraction, strw + strw2 + paddingx*2, strh + paddingy*2, data.glow, data.rounding, {r, g, b, 155 * fraction}, {25,25,25,155 * fraction})
                renderer.text(x/2 + strw2/2 * fraction, y - offsetY - Offset * fraction, 255, 255, 255, 255 * fraction, "c", 0, string)
            elseif ui.get(menu.visualsTab.logs_style) == "OG" then
                Offset = Offset + (strh + paddingy*2 + 	math.sqrt(data.glow/10)*10 + 9) 
                render_ogskeet_border(x/2 - (strw/2), y - offsetY - Offset * fraction - 10, strw, 13, 255 * fraction, string)
                --renderer.text(x/2 - (strw/2), y - offsetY - Offset * fraction - 10, 255, 255, 255, 255 * fraction, "c", 0, string)
            elseif ui.get(menu.visualsTab.logs_style) == "Normal" then
                Offset = Offset + (strh + paddingy*2 + 	math.sqrt(data.glow/10)*8) 
                renderer.text(x/2, y - offsetY - Offset * fraction - 10, 255, 255, 255, 255 * fraction, "c", 0, string)
            end
        end
        

        for i = #to_remove, 1, -1 do
            table.remove(data, to_remove[i])
        end
    end,

    clear = function()
        data = {}
    end
}



local function onHit(e)
    local group = vars.hitgroup_names[e.hitgroup + 1] or '?'
	local r, g, b, a = ui.get(menu.visualsTab.indicatorsClr)
	notifications.new(string.format("Hit %s's $%s$ for $%d$ damage", entity.get_player_name(e.target), group:lower(), e.damage), r, g, b) 
    --	notifications.new(string.format("Hit %s's $%s$ for $%d$ damage ($%d$ health remaining)", entity.get_player_name(e.target), group:lower(), e.damage, entity.get_prop(e.target, 'm_iHealth')), r, g, b) 


end

local function onMiss(e)
    local group = vars.hitgroup_names[e.hitgroup + 1] or '?'
    local ping = math.min(999, client.real_latency() * 1000)
    local ping_col = (ping >= 100) and { 255, 0, 0 } or { 150, 200, 60 }
    local hc = math.floor(e.hit_chance + 0.5);
    local hc_col = (hc < ui.get(refs.hitChance)) and { 255, 0, 0 } or { 150, 200, 60 };
    e.reason = e.reason == "?" and "resolver" or e.reason
	notifications.new(string.format("Missed %s's $%s$ due to $%s$", entity.get_player_name(e.target), group:lower(), e.reason), 255, 120, 120)
    --	notifications.new(string.format("Hit %s's $%s$ for $%d$ damage ($%d$ health remaining)", entity.get_player_name(e.target), group:lower(), e.damage, entity.get_prop(e.target, 'm_iHealth')), r, g, b) 

end

local aa = {
	ignore = false,
	manualAA= 0,
	input = 0,
}
client.set_event_callback("player_connect_full", function() 
	aa.ignore = false
	aa.manualAA= 0
	aa.input = globals.curtime()
end)

local clantag = {
    steam = steamworks.ISteamFriends,
    prev_ct = "",
    orig_ct = "",
    enb = false,
}

local function get_original_clantag()
    local clan_id = cvar.cl_clanid.get_int()
    if clan_id == 0 then return "\0" end

    local clan_count = clantag.steam.GetClanCount()
    for i = 0, clan_count do 
        local group_id = clantag.steam.GetClanByIndex(i)
        if group_id == clan_id then
            return clantag.steam.GetClanTag(group_id)
        end
    end
end

local prev_simulation_time = 0

local tick = 0
local ticker = 0
local lerp_alpha = 0




local current_tick = func.time_to_ticks(globals.realtime())
client.set_event_callback("setup_command", function(cmd)
    vars.localPlayer = entity.get_local_player()

    if not vars.localPlayer or not entity.is_alive(vars.localPlayer) or not ui.get(masterSwitch) then return end
	local flags = entity.get_prop(vars.localPlayer, "m_fFlags")
    local onground = bit.band(flags, 1) ~= 0 and cmd.in_jump == 0
	local valve = entity.get_prop(entity.get_game_rules(), "m_bIsValveDS")
	local origin = vector(entity.get_prop(vars.localPlayer, "m_vecOrigin"))
	local velocity = vector(entity.get_prop(vars.localPlayer, "m_vecVelocity"))
	local camera = vector(client.camera_angles())
	local eye = vector(client.eye_position())
	local speed = math.sqrt((velocity.x * velocity.x) + (velocity.y * velocity.y) + (velocity.z * velocity.z))
    local weapon = entity.get_player_weapon()
	local pStill = math.sqrt(velocity.x ^ 2 + velocity.y ^ 2) < 5
    local bodyYaw = entity.get_prop(vars.localPlayer, "m_flPoseParameter", 11) * 120 - 60

    local weapon = entity.get_player_weapon(vars.localPlayer)

    local isSlow = ui.get(refs.slow[1]) and ui.get(refs.slow[2])
	local isOs = ui.get(refs.os[1]) and ui.get(refs.os[2])
	local isFd = ui.get(refs.fakeDuck)
	local isDt = ui.get(refs.dt[1]) and ui.get(refs.dt[2])
    local isLegitAA = ui.get(aaBuilder[8].enableState) and client.key_state(0x45)
    local isDefensive = (func.defensive.defensive > 1 and func.defensive.defensive < 14)
    local safeKnife =  func.includes(ui.get(menu.aaTab.lol), "Safe Knife") and entity.get_classname(weapon) == "CKnife"

    -- search for states
    vars.pState = 1
    if pStill then vars.pState = 2 end
    if not pStill then vars.pState = 3 end
    if isSlow then vars.pState = 4 end
    if entity.get_prop(vars.localPlayer, "m_flDuckAmount") > 0.1 then vars.pState = 5 end
    if not onground then vars.pState = 6 end
    if not onground and entity.get_prop(vars.localPlayer, "m_flDuckAmount") > 0.1 then vars.pState = 7 end

    if ui.get(aaBuilder[vars.pState].enableState) == false and vars.pState ~= 1 then
        vars.pState = 1
    end

    if isLegitAA and not vars.should_disable then
        vars.pState = 8
    end

    local nextAttack = entity.get_prop(vars.localPlayer, "m_flNextAttack")
    local nextPrimaryAttack = entity.get_prop(entity.get_player_weapon(vars.localPlayer), "m_flNextPrimaryAttack")
    local dtActive = false
    local isFl = ui.get(ui.reference("AA", "Fake lag", "Enabled"))
    if nextPrimaryAttack ~= nil then
        dtActive = not (math.max(nextPrimaryAttack, nextAttack) > globals.curtime())
    end

    local side_yaw = 2
    if cmd.chokedcommands == 0 then
        vars.choke1 = vars.choke1 + 1
        vars.choke2 = vars.choke2 + 1
        vars.choke3 = vars.choke3 + 1
        vars.choke4 = vars.choke4 + 1
    end
    if vars.choke1 >= 5 then
        vars.choke1 = 0
    end
    if vars.choke2 >= 8 then
        vars.choke2 = 0
    end
    if vars.choke3 >= 8 then
        vars.choke3 = 5
    end

    if globals.tickcount() % ui.get(aaBuilder[vars.pState].yawSpeed) == 1 then
        vars.switch = not vars.switch
    end

    local tickcount = globals.tickcount()

    local side = bodyYaw > 0 and 1 or -1

        -- manual aa
        local isStatic = func.includes(ui.get(menu.aaTab.lol), "Static on Manual")

        ui.set(menu.keys.manualTab.manualLeft, "On hotkey")
        ui.set(menu.keys.manualTab.manualRight, "On hotkey")
        ui.set(menu.keys.manualTab.manualForward, "On hotkey")

        if aa.input + 0.182 < globals.curtime() then
            if aa.manualAA == 0 then
                if ui.get(menu.keys.manualTab.manualLeft) then
                    aa.manualAA = 1
                    aa.input = globals.curtime()    
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))
                elseif ui.get(menu.keys.manualTab.manualRight) then
                    aa.manualAA = 2
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))
                elseif ui.get(menu.keys.manualTab.manualForward) then
                    aa.manualAA = 3
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))   
                end
            elseif aa.manualAA == 1 then
                if ui.get(menu.keys.manualTab.manualRight) then
                    aa.manualAA = 2
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                elseif ui.get(menu.keys.manualTab.manualForward) then
                    aa.manualAA = 3
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                elseif ui.get(menu.keys.manualTab.manualLeft) then
                    aa.manualAA = 0
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                end
            elseif aa.manualAA == 2 then
                if ui.get(menu.keys.manualTab.manualLeft) then
                    aa.manualAA = 1
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                elseif ui.get(menu.keys.manualTab.manualForward) then
                    aa.manualAA = 3
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                elseif ui.get(menu.keys.manualTab.manualRight) then
                    aa.manualAA = 0
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                end
            elseif aa.manualAA == 3 then
                if ui.get(menu.keys.manualTab.manualForward) then
                    aa.manualAA = 0
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                elseif ui.get(menu.keys.manualTab.manualLeft) then
                    aa.manualAA = 1
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                elseif ui.get(menu.keys.manualTab.manualRight) then
                    aa.manualAA = 2
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                end
            end

            if aa.manualAA == 1 or aa.manualAA == 2 or aa.manualAA == 3 then
                aa.ignore = true

                if isStatic then
                    ui.set(refs.yawJitter[1], "Off")
                    ui.set(refs.yawJitter[2], 0)
                    ui.set(refs.bodyYaw[1], "Static")
                    ui.set(refs.bodyYaw[2], 180)

                    if aa.manualAA == 1 then
                        ui.set(refs.yawBase, "local view")
                        ui.set(refs.yaw[1], "180")
                        ui.set(refs.yaw[2], -90)
                    elseif aa.manualAA == 2 then
                        ui.set(refs.yawBase, "local view")
                        ui.set(refs.yaw[1], "180")
                        ui.set(refs.yaw[2], 90)
                    elseif aa.manualAA == 3 then
                        ui.set(refs.yawBase, "local view")
                        ui.set(refs.yaw[1], "180")
                        ui.set(refs.yaw[2], 180)
                    end
                elseif not isStatic and ui.get(aaBuilder[vars.pState].enableState) then
                    if ui.get(aaBuilder[vars.pState].yawJitter) == "Sync" then
                        -- ui.set(refs.yawJitter[1], "Center")
                        -- ui.set(refs.yawJitter[2], (side == 1 and ui.get(aaBuilder[vars.pState].yawJitterLeft)*math.random(-1, 1)  or ui.get(aaBuilder[vars.pState].yawJitterRight)*math.random(-1, 1) ))
                        ui.set(refs.yawJitter[1], "Center")
                        local ways = {
                            2,
                            6,
                            10
                        }
                        ui.set(refs.yawJitter[2], ways[(globals.tickcount() % 3) + 1] )
                    elseif ui.get(aaBuilder[vars.pState].yawJitter) == "L & R" then
                        ui.set(refs.yawJitter[1], "Center")
                        ui.set(refs.yawJitter[2], (side == 1 and ui.get(aaBuilder[vars.pState].yawJitterLeft) or ui.get(aaBuilder[vars.pState].yawJitterRight)))
                    else
                        ui.set(refs.yawJitter[1], ui.get(aaBuilder[vars.pState].yawJitter))
                        ui.set(refs.yawJitter[2], ui.get(aaBuilder[vars.pState].yawJitterStatic))
                    end

                    if ui.get(aaBuilder[vars.pState].yawCondition) == "L & R" then
                        ui.set(refs.bodyYaw[1], "Jitter")
                        ui.set(refs.bodyYaw[2], -1)
                    else
                        ui.set(refs.bodyYaw[1], "Static")
                        ui.set(refs.bodyYaw[2], -180)
                    end

                    if aa.manualAA == 1 then
                        ui.set(refs.yawBase, "local view")
                        ui.set(refs.yaw[1], "180")
                        ui.set(refs.yaw[2], -90)
                    elseif aa.manualAA == 2 then
                        ui.set(refs.yawBase, "local view")
                        ui.set(refs.yaw[1], "180")     
                        ui.set(refs.yaw[2], 90)
                    elseif aa.manualAA == 3 then
                        ui.set(refs.yawBase, "local view")
                        ui.set(refs.yaw[1], "180")
                        ui.set(refs.yaw[2], 180)
                    end
                end
            else
                aa.ignore = false
            end
        elseif aa.input > globals.curtime() then
        --    aa.ignore = false
        --    aa.manualAA = 0
            aa.input = globals.curtime()
        end

    -- check height advantage and head safety
    local heightAdvantage = false
    local safetyAlert = false
    local enemies = entity.get_players(true)
	for i=1, #enemies do
        if entity.is_dormant(enemies[i]) then heightAlert = false sidewaysAlert = false return end
		local playerX, playerY, playerZ  = entity.get_prop(enemies[i], "m_vecOrigin")
		local playerFlags = entity.get_prop(enemies[i], "m_fFlags")
		local playerOnGround = bit.band(playerFlags, 1) ~= 0
		local lengthDistance = math.sqrt((playerX - origin.x)^2 + (playerY - origin.y)^2 + (playerZ - origin.z)^2)
		if ((playerZ + 100 < origin.z) and lengthDistance <= 300) then
			heightAdvantage = true
		else
			heightAdvantage = false
		end

        if ((bodyYaw >= 40 or bodyYaw <= -40) and func.headVisible(enemies[i])) then
			safetyAlert = true
		else
			safetyAlert = false
		end
	end

    if ui.get(aaBuilder[vars.pState].enableState) then
        if ui.get(aaBuilder[vars.pState].enabledefensive) and ui.get(refs.dt[1]) and ui.get(refs.dt[2]) then
            if ui.get(aaBuilder[vars.pState].defensiveOpt) == "None" and ui.get(refs.dt[1]) and ui.get(refs.dt[2]) then
                cmd.force_defensive = false
            else
            cmd.force_defensive = globals.tickcount() % 20 < 3
            end
        end
        
        if ui.get(aaBuilder[vars.pState].defensiveOpt) == "Time to ticks" then
            if ui.get(aaBuilder[vars.pState].defensiveOpt) == "None" and not ui.get(refs.dt[1]) and not ui.get(refs.dt[2])  then
                cmd.force_defensive = false
            else
            cmd.force_defensive = globals.tickcount() % 10 < 3
            end
        end

        if ui.get(aaBuilder[vars.pState].defensiveOpt) == "Hold Ticks" then
            if ui.get(aaBuilder[vars.pState].defensiveOpt) == "None" and not ui.get(refs.dt[1]) and not ui.get(refs.dt[2])  then
                cmd.force_defensive = false
            else
            cmd.force_defensive = globals.tickcount() % 15 < 3
            end
        end
        
        
        if cmd.chokedcommands > 1 then
            cmd.allow_send_packet = false
        else
            cmd.allow_send_packet = true
        end
        
        
        if cmd.force_defensive == true then isDefensive = true end
        
        
        if aa.ignore then return end
        
        if ui.get(aaBuilder[vars.pState].defensivePitch) == "Custom" and isDefensive then
            ui.set(refs.pitch[1], "Custom")
            ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].defensivePitchSlider))
        elseif ui.get(aaBuilder[vars.pState].defensivePitch) == "Random" and isDefensive then
            ui.set(refs.pitch[1], "Custom")
            ui.set(refs.pitch[2], math.random(-89,89))
        elseif ui.get(aaBuilder[vars.pState].defensivePitch) == "Up" and isDefensive then
            ui.set(refs.pitch[1], "up")
        elseif ui.get(aaBuilder[vars.pState].defensivePitch) == "Swap" and isDefensive then
            ui.set(refs.pitch[1], "Custom")
            ui.set(refs.pitch[2], math.random(39, -39))
        else
            ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
            ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))
        end    
        
        
        ui.set(refs.yawBase, ui.get(aaBuilder[vars.pState].yawBase))
        
        ui.set(refs.yaw[1], ui.get(aaBuilder[vars.pState].yaw))
        
        if ui.get(aaBuilder[vars.pState].defensiveYaw) == "Jitter" and isDefensive then
            ui.set(refs.yaw[2], tickcount % 3 == 0 and client.random_int(90, -90) or tickcount % 3 == 1 and 180 or tickcount % 3 == 2 and client.random_int(-90, 90) or 0)
        elseif ui.get(aaBuilder[vars.pState].defensiveYaw) == "Custom" and isDefensive then
            ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].defensiveYawSlider))
        elseif ui.get(aaBuilder[vars.pState].defensiveYaw) == "Spin" and isDefensive then
            ui.set(refs.yaw[1], "Spin")
        elseif ui.get(aaBuilder[vars.pState].defensiveYaw) == "Flick" and isDefensive then
        --    ui.set(refs.yawJitter[2], ui.get(aaBuilder[vars.pState].yawJitterStatic)*math.random(-1, 1) )
            ui.set(refs.pitch[1], "up")
            ui.set(refs.yaw[2], (globals.tickcount() % 6 > 3) and 111 or -111)
        elseif ui.get(aaBuilder[vars.pState].defensiveYaw) == "Slow Jitter" and isDefensive then
            ui.set(refs.yaw[2], switch and ui.get(aaBuilder[vars.pState].yawJitterRight) or ui.get(aaBuilder[vars.pState].yawJitterLeft))
        elseif ui.get(aaBuilder[vars.pState].yawCondition) == "L & R" then

            ui.set(refs.yaw[2],(side == 1 and ui.get(aaBuilder[vars.pState].yawLeft) or ui.get(aaBuilder[vars.pState].yawRight)))

        elseif ui.get(aaBuilder[vars.pState].yawCondition) == "Tickbased" then

            if vars.choke2 == 0 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawRight))
            elseif vars.choke2 == 1 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawLeft))
            elseif vars.choke2 == 2 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawLeft))
            elseif vars.choke2 == 3 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawLeft))
            elseif vars.choke2 == 4 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawRight))
            elseif vars.choke2 == 5 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawLeft))
            elseif vars.choke2 == 6 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawRight))
            elseif vars.choke2 == 7 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawRight))
            end

            

        elseif ui.get(aaBuilder[vars.pState].yawCondition) == "Delay" then
            ui.set(refs.yaw[1], "180")
            ui.set(refs.yaw[2], vars.switch and ui.get(aaBuilder[vars.pState].yawLeft) or ui.get(aaBuilder[vars.pState].yawRight))
            side_yaw = 0
        else
            ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawStatic))
            side_yaw = 2
        end

        local switch = false
        if ui.get(aaBuilder[vars.pState].yawJitter) == "Sync" then
            ui.set(refs.yawJitter[1], "Center")
        elseif ui.get(aaBuilder[vars.pState].yawJitter) == "TabJitter" then
            ui.set(refs.yawJitter[1], "Center")
            ui.set(refs.yawJitter[2], (side == 1 and ui.get(aaBuilder[vars.pState].yawJitterLeft) or ui.get(aaBuilder[vars.pState].yawJitterRight)) * math.random(-10, 10))
        else
            ui.set(refs.yawJitter[1], ui.get(aaBuilder[vars.pState].yawJitter))
        end
        if ui.get(aaBuilder[vars.pState].yawJitterCondition) == "L & R" then
            if ui.get(aaBuilder[vars.pState].yawJitter) == "Sync" then
                ui.set(refs.yawJitter[2], (side == 1 and ui.get(aaBuilder[vars.pState].yawJitterLeft)*math.random(-1, 1)  or ui.get(aaBuilder[vars.pState].yawJitterRight)*math.random(-1, 1) ))
            elseif ui.get(aaBuilder[vars.pState].yawJitter) == "Slow Jitter" then
                ui.set(refs.yaw[2], switch and ui.get(aaBuilder[vars.pState].yawJitterRight) or ui.get(aaBuilder[vars.pState].yawJitterLeft))
            else
                ui.set(refs.yawJitter[2], (side == 1 and ui.get(aaBuilder[vars.pState].yawJitterLeft) or ui.get(aaBuilder[vars.pState].yawJitterRight)))
            end
            
        else
            if  ui.get(aaBuilder[vars.pState].yawJitter) == "Sync" then
                ui.set(refs.yawJitter[2], ui.get(aaBuilder[vars.pState].yawJitterStatic)*math.random(-1, 1) )
            elseif ui.get(aaBuilder[vars.pState].yawJitter) == "Slow Jitter" then
                ui.set(refs.yaw[2], switch and ui.get(aaBuilder[vars.pState].yawJitterStatic) or -ui.get(aaBuilder[vars.pState].yawJitterStatic))
            else
                ui.set(refs.yawJitter[2], ui.get(aaBuilder[vars.pState].yawJitterStatic) )
            end
        end
        
        if ui.get(aaBuilder[vars.pState].yawCondition) == "Delay" then
            ui.set(refs.bodyYaw[1], "Static")
            ui.set(refs.bodyYaw[2], 0)
        elseif ui.get(aaBuilder[vars.pState].yawCondition) == "Tickbased" then
            ui.set(refs.bodyYaw[1], "Static")
            ui.set(refs.bodyYaw[2], 0)
        else
            ui.set(refs.bodyYaw[1], ui.get(aaBuilder[vars.pState].bodyYaw))
            ui.set(refs.bodyYaw[2], ui.get(aaBuilder[vars.pState].bodyYawSlider))
        end

        if reversed and ui.get(aaBuilder[vars.pState].antiBruteSet) then
            ui.set(refs.yaw[2], angle)
        end

        ui.set(refs.fsBodyYaw, false)
    elseif not ui.get(aaBuilder[vars.pState].enableState) then
        ui.set(refs.pitch[1], "Off")
        ui.set(refs.yawBase, "Local view")
        ui.set(refs.yaw[1], "Off")
        ui.set(refs.yaw[2], 0)
        ui.set(refs.yawJitter[1], "Off")
        ui.set(refs.yawJitter[2], 0)
        ui.set(refs.bodyYaw[1], "Off")
        ui.set(refs.bodyYaw[2], 0)
        ui.set(refs.fsBodyYaw, false)
        ui.set(refs.edgeYaw, false)
        ui.set(refs.roll, 0)
    end

    --safe safe
    if func.includes(ui.get(menu.aaTab.lol), "Safe Knife") then
        if entity.get_classname(entity.get_player_weapon(entity.get_local_player())) == "CKnife" and vars.pState == 7 then
            ui.set(refs.pitch[1], "Default")
            ui.set(refs.yawBase, "At targets")
            ui.set(refs.yaw[1], "180")
            ui.set(refs.yaw[2], 0)
            ui.set(refs.yawJitter[1], "Off")
            ui.set(refs.yawJitter[2], 0)
            ui.set(refs.bodyYaw[1], "Static")
            ui.set(refs.bodyYaw[2], 0)
            ui.set(refs.fsBodyYaw, false)
            ui.set(refs.edgeYaw, false)
            ui.set(refs.roll, 0)
        end
    end

    -- -- fix hideshots
	-- if ui.get(menu.aaTab.fixHideshots) then
	-- 	if isOs and not isDt and not isFd then
    --         if not hsSaved then
    --             hsValue = ui.get(refs.fakeLag[1])
    --             hsSaved = true
    --         end
	-- 		ui.set(refs.fakeLag[1], 1)
	-- 	elseif hsSaved then
	-- 		ui.set(refs.fakeLag[1], hsValue)
    --         hsSaved = false
	-- 	end
	-- end

    distance_knife = {}
    distance_knife.anti_knife_dist = function (x1, y1, z1, x2, y2, z2)
        return math.sqrt((x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2)
    end

----resolver 


    -- Avoid backstab
    if  func.includes(ui.get(menu.aaTab.lol), "Avoid Backstab") then
        local players = entity.get_players(true)
        local lx, ly, lz = entity.get_prop(entity.get_local_player(), "m_vecOrigin")
        if players == nil then return end
        for i=1, #players do
            local x, y, z = entity.get_prop(players[i], "m_vecOrigin")
            local distance = distance_knife.anti_knife_dist(lx, ly, lz, x, y, z)
            local weapon = entity.get_player_weapon(players[i])
            if entity.get_classname(weapon) == "CKnife" and distance <= 200 then
                ui.set(refs.yaw[2], 180)
                ui.set(refs.yawBase, "At targets")
            end
        end
    end
    
    
    -- fast ladder
    if ui.get(menu.miscTab.fastLadderEnabled) then
        local pitch, yaw = client.camera_angles()
        if entity.get_prop(vars.localPlayer, "m_MoveType") == 9 then
            cmd.yaw = math.floor(cmd.yaw+0.5)
            cmd.roll = 0
    
            if func.includes(ui.get(menu.miscTab.fastLadder), "Ascending") then
                if cmd.forwardmove > 0 then
                    if pitch < 45 then
                        cmd.pitch = 89
                        cmd.in_moveright = 1
                        cmd.in_moveleft = 0
                        cmd.in_forward = 0
                        cmd.in_back = 1
                        if cmd.sidemove == 0 then
                            cmd.yaw = cmd.yaw + 90
                        end
                        if cmd.sidemove < 0 then
                            cmd.yaw = cmd.yaw + 150
                        end
                        if cmd.sidemove > 0 then
                            cmd.yaw = cmd.yaw + 30
                        end
                    end 
                end
            end
            if func.includes(ui.get(menu.miscTab.fastLadder), "Descending") then
                if cmd.forwardmove < 0 then
                    cmd.pitch = 89
                    cmd.in_moveleft = 1
                    cmd.in_moveright = 0
                    cmd.in_forward = 1
                    cmd.in_back = 0
                    if cmd.sidemove == 0 then
                        cmd.yaw = cmd.yaw + 90
                    end
                    if cmd.sidemove > 0 then
                        cmd.yaw = cmd.yaw + 150
                    end
                    if cmd.sidemove < 0 then
                        cmd.yaw = cmd.yaw + 30
                    end
                end
            end
        end
    end

    -- edgeyaw
    ui.set(refs.edgeYaw, ui.get(menu.keys.edgeYawHotkey))
end)

client.set_event_callback("setup_command", function(e)
    if not vars.localPlayer or not entity.is_alive(vars.localPlayer) or not ui.get(masterSwitch) then return end
	local flags = entity.get_prop(vars.localPlayer, "m_fFlags")
    local onground = bit.band(flags, 1) ~= 0 and e.in_jump == 0
    local isSlow = ui.get(refs.slow[1]) and ui.get(refs.slow[2])

    local Aero = func.includes(ui.get(menu.keys.freestandDisablers), "Aero") and not onground
    local duck = func.includes(ui.get(menu.keys.freestandDisablers), "Duck") and entity.get_prop(vars.localPlayer, "m_flDuckAmount") > 0.1
    local manul = func.includes(ui.get(menu.keys.freestandDisablers), "Manual") and (aa.manualAA == 2 or aa.manualAA == 1) and aa.ignore
    local fs_disabler = Aero or duck

    if ui.get(menu.keys.freestandHotkey) and not fs_disabler then
        vars.fs = true
        ui.set(refs.freeStand[2], "Always on")
        ui.set(refs.freeStand[1], true)
    else
        vars.fs = false
        ui.set(refs.freeStand[1], false)
        ui.set(refs.freeStand[2], "On hotkey")
    end    
end)

client.set_event_callback("setup_command", function(cmd)
    local using = true
    local defusing = false
    vars.should_disable = false

    if entity.get_classname(entity.get_player_weapon(vars.localPlayer)) == "CC4" then
        vars.should_disable = true
        return
    end

    local planted_bomb = entity.get_all("CPlantedC4")[1]
    local classnames = {"CWorld","CCSPlayer","CFuncBrush","CPropDoorRotating","CHostage"}

    if planted_bomb ~= nil then
        local bomb_distance = vector(entity.get_origin(vars.localPlayer)):dist(vector(entity.get_origin(planted_bomb)))
        
        if bomb_distance <= 64 and entity.get_prop(vars.localPlayer, "m_iTeamNum") == 3 then
            vars.should_disable = true
            defusing = true
        end
    end

    local pitch, yaw = client.camera_angles()
    local direct_vec = vector(func.vec_angles(pitch, yaw))

    local eye_pos = vector(client.eye_position())
    local fraction, ent = client.trace_line(vars.localPlayer, eye_pos.x, eye_pos.y, eye_pos.z, eye_pos.x + (direct_vec.x * 8192), eye_pos.y + (direct_vec.y * 8192), eye_pos.z + (direct_vec.z * 8192))

    local using = true

    if ent ~= nil and ent ~= -1 then
        for i=0, #classnames do
            if entity.get_classname(ent) == classnames[i] then
                using = false
            end
        end
    end

    if not vars.should_disable and client.key_state(0x45) and not using and not defusing and ui.get(aaBuilder[8].enableState) then
        cmd.in_use = 0
    end

--    local key = ui.get(menu.aaTab.BombEfix)
end)




-- local function clantag_set()
--     local lua_name = "#T@b$eNsE"
--     if ui.get(menu.miscTab.clanTag) then
--         if ui.get(ui.reference("Misc", "Miscellaneous", "Clan tag spammer")) then return end

-- 		local clan_tag = clantag_anim(lua_name, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 11, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25})

--         if entity.get_prop(entity.get_game_rules(), "m_gamePhase") == 5 then
--             clan_tag = clantag_anim('#T@b$eNsE', {13})
--             client.set_clan_tag(clan_tag)
--         elseif entity.get_prop(entity.get_game_rules(), "m_timeUntilNextPhaseStarts") ~= 0 then
--             clan_tag = clantag_anim('#T@b$eNsE', {13})
--             client.set_clan_tag(clan_tag)
--         elseif clan_tag ~= clantag.prev_ct  then
--             client.set_clan_tag(clan_tag)
--         end

--         clantag.prev_ct = clan_tag
--         clantag.enb = true
--     elseif clantag.enb == true then
--         client.set_clan_tag(get_original_clantag())
--         clantag.enb = false
--     end
-- end

-- clantag.paint = function()
--     if entity.get_local_player() ~= nil then
--         if globals.tickcount() % 2 == 0 then
--             clantag_set()
--         end
--     end
-- end

-- clantag.run_command = function(e)
--     if entity.get_local_player() ~= nil then 
--         if e.chokedcommands == 0 then
--             clantag_set()
--         end
--     end
-- end

-- clantag.player_connect_full = function(e)
--     if client.userid_to_entindex(e.userid) == entity.get_local_player() then 
--         clantag.orig_ct = get_original_clantag()
--     end
-- end

-- clantag.shutdown = function()
--     client.set_clan_tag(get_original_clantag())
-- end

-- client.set_event_callback("paint", clantag.paint)
-- client.set_event_callback("run_command", clantag.run_command)
-- client.set_event_callback("player_connect_full", clantag.player_connect_full)
-- client.set_event_callback("shutdown", clantag.shutdown)

ui.set_callback(menu.miscTab.trashTalk, function() 
    local callback = ui.get(menu.miscTab.trashTalk) and client.set_event_callback or client.unset_event_callback
    callback('player_death', trashtalk)
end)

ui.set_callback(menu.visualsTab.logs, function() 
    local callback = ui.get(menu.visualsTab.logs) and client.set_event_callback or client.unset_event_callback
    callback("aim_miss", onMiss)
    callback("aim_hit", onHit)
end)

client.set_event_callback("player_death", function(e)
    local v, a = e.userid, e.attacker
    local lp_death = client.userid_to_entindex(v)
    if lp_death ~= entity.get_local_player() then return end
    client.delay_call(1, notifications.clear)
end)

client.set_event_callback("player_connect_full", function(e)
    if client.userid_to_entindex(e.userid) == entity.get_local_player() then 
        notifications.clear()
    end
end)

local legsTypes = {[1] = "Off", [2] = "Always slide", [3] = "Never slide"}
local ground_ticks = 0
client.set_event_callback("setup_command", function(e)
    local is_on_ground = e.in_jump == 0
    if func.includes(ui.get(menu.miscTab.animations), "Leg fucker") then
        if func.includes(ui.get(menu.miscTab.animations), "Leg fucker") then
            ui.set(refs.legMovement, e.command_number % 3 == 0 and "Off" or "Always slide")
        end
    end
end)

function rgba_to_hex(b,c,d,e)
    return string.format('%02x%02x%02x%02x',b,c,d,e)
end

client.set_event_callback("pre_render", function()
    local lp = entity.get_local_player()
    if not lp then return end
    if ui.get(menu.miscTab.animationsEnabled) == false then return end
    local flags = entity.get_prop(lp, "m_fFlags")
    ground_ticks = bit.band(flags, 1) == 0 and 0 or (ground_ticks < 5 and ground_ticks + 1 or ground_ticks)

    if func.includes(ui.get(menu.miscTab.animations), "Break legs while in Aero") and bit.band(flags, 1) == 0 then
        entity.set_prop(lp, "m_flPoseParameter", 1, 6) 
    end

    if func.includes(ui.get(menu.miscTab.animations), "Leg fucker") then
        entity.set_prop(lp, "m_flPoseParameter", 1, globals.tickcount() % 4 > 1 and 5 / 10 or 1)
    end

    if func.includes(ui.get(menu.miscTab.animations), "Reset pitch on land") then
        ground_ticks = bit.band(flags, 1) == 1 and ground_ticks + 1 or 0

        if ground_ticks > 20 and ground_ticks < 150 then
            entity.set_prop(lp, "m_flPoseParameter", 0.5, 12)
        end
    end

    if func.includes(ui.get(menu.miscTab.animations), "Be Micheal Jackson") then
        entity.set_prop(lp, "m_flPoseParameter", 1, 7)
        ui.set(refs.legMovement, "Never slide")
    end
    
end)


-- @region AA_CALLBACKS end

-- @region INDICATORS start
local alpha = 0
local scopedFraction = 0
local scopedFraction2 = 0
local defensiveFraction = 0
local activeFraction = 0
local inactiveFraction = 0
local hideFraction = 0
local hideInactiveFraction = 0
local dtPos = {y = 0}
local osPos = {y = 0}

local mainIndClr = {r = 0, g = 0, b = 0, a = 0}
local dtClr = {r = 0, g = 0, b = 0, a = 0}
local chargeClr = {r = 0, g = 0, b = 0, a = 0}
local chargeInd = {w = 0, x = 0, y = 25}
local psClr = {r = 0, g = 0, b = 0, a = 0}
local dtInd = {w = 0, x = 0, y = 25}
local qpInd = {w = 0, x = 0, y = 25, a = 0}
local fdInd = {w = 0, x = 0, y = 25, a = 0}
local spInd = {w = 0, x = 0, y = 25, a = 0}
local baInd = {w = 0, x = 0, y = 25, a = 0}
local fsInd = {w = 0, x = 0, y = 25, a = 0}
local osInd = {w = 0, x = 0, y = 25, a = 0}
local psInd = {w = 0, x = 0, y = 25}
local wAlpha = 0
local value = 0
local once1 = false
local once2 = false
local dt_a = 0
local dt_y = 45
local dt_x = 0
local dt_w = 0
local os_a = 0
local os_y = 45
local os_x = 0
local os_w = 0
local fs_a = 0
local fs_y = 45
local fs_x = 0
local fs_w = 0
local n_x = 0
local n2_x = 0
local n3_x = 0
local n4_x = 0
local testx = 0
local aaa = 0
local lele = 0
local hitler = {}
hitler.lerp = function(start, vend, time)
    return start + (vend - start) * time
end

function normalize_yaw(yaw)
	while yaw > 180 do yaw = yaw - 360 end
	while yaw < -180 do yaw = yaw + 360 end
	return yaw
end

function ang_on_screen(x, y)
	if x == 0 and y == 0 then return 0 end

	return math.deg(math.atan2(y, x))
end

local best_enemy = nil
function get_best_enemy()
    best_enemy = nil

    local enemies = entity.get_players(true)
    local best_fov = 180

    local lx, ly, lz = client.eye_position()
    local view_x, view_y, roll = client.camera_angles()
    
    for i=1, #enemies do
        local cur_x, cur_y, cur_z = entity.get_prop(enemies[i], "m_vecOrigin")
        local cur_fov = math.abs(normalize_yaw(ang_on_screen(lx - cur_x, ly - cur_y) - view_y + 180))
        if cur_fov < best_fov then
            best_fov = cur_fov
            best_enemy = enemies[i]
        end
    end
end

client.set_event_callback("setup_command", function()
    defensive_indicator()
end)

client.set_event_callback("paint", function()
    local local_player = entity.get_local_player()
    if local_player == nil or entity.is_alive(local_player) == false then return end
    local sizeX, sizeY = client.screen_size()
    local weapon = entity.get_player_weapon(local_player)
    local bodyYaw = entity.get_prop(local_player, "m_flPoseParameter", 11) * 120 - 60
    local side = bodyYaw > 0 and 1 or -1
    local state = vars.intToS[vars.pState]:upper()
    local mainClr = {}
    mainClr.r, mainClr.g, mainClr.b, mainClr.a = ui.get(menu.visualsTab.indicatorsClr)
    local arrowClr = {}
    arrowClr.r, arrowClr.g, arrowClr.b, arrowClr.a = ui.get(menu.visualsTab.arrowClr)
    local fake = math.floor(antiaim_funcs.get_desync(1))
    local isDefensive = (func.defensive.defensive > 1 and func.defensive.defensive < 14)

    local function get_velocity(player)
        local x, y, z = entity.get_prop(player, "m_vecVelocity")
        if x == nil then
            return
        end
        return math.sqrt(x * x + y * y + z * z)
    end
    
    local function clamp(value, minVal, maxVal)
        return math.max(minVal, math.min(value, maxVal))
    end




    local aa_functions = {
        aa_number = "Stand",
        jitter_way_number = 1,
        old_weapon = 0,
        actual_weapon = 0,
        actual_tick = 0,
        to_start = false,
        to_jitter = false,  
        bomb_was_bombed = false,
        bomb_was_defused = false,
        can_defensive = false,
        def_ticks = 0,
    }

    local prev_simulation_time = 0
    function aa_functions:sim_diff() 
        local current_simulation_time = math.floor(0.5 + (entity.get_prop(entity.get_local_player(), "m_flSimulationTime") / globals.tickinterval())) 
        local diff = current_simulation_time - prev_simulation_time
        prev_simulation_time = current_simulation_time
        return diff
    end
      
    local indicators = 0

    local function gradient_text(text, col, speed)
        local final_text = ''
        local curtime = globals.curtime()
        local r, g, b, a = col.r, col.g, col.b, col.a
        local center = math.floor(#text / 2) + 1  -- calculate the center of the text
        for i=1, #text do
            -- calculate the distance from the center character
            local distance = math.abs(i - center)
            -- calculate the alpha based on the distance and the speed and time
            a = 255 - math.abs(255 * math.sin(speed * curtime / 4 - distance * 4 / 20))
            local col = color.new(r, g, b, a):hex()
            final_text = final_text .. '\a' .. col .. text:sub(i, i)
        end
        return final_text
    end

    local watermarkClr = {}
    watermarkClr.r, watermarkClr.g, watermarkClr.b = ui.get(menu.visualsTab.watermarkClr)

    local w,h = client.screen_size()
    local wm = { ui.get(menu.visualsTab.watermarkClr) }
    local float = math.sin(globals.realtime() * 2.3) * 15

    local screensize = { client.screen_size() };
    local center = { screensize[1] / 2, screensize[2] / 2 };
    local x = center[1]
    local y = center[2]
    local width2 = vector(renderer.measure_text('cb', gradient_text("TABSENSE",color.new(wm[1], wm[2], wm[3], wm[4]), 5),"", " ["..string.upper(login.build), "]"))
    local x = (screensize[1] - width2.x) / 2;
    local y = screensize[2] / 1.019;


    function text_fade_animation(speed, r, g, b, a, text)
        local final_text = ''
        local curtime = globals.curtime()
        for i=0, #text do
            local color = rgba_to_hex(r, g, b, a*math.abs(1*math.cos(2*speed*curtime/4+i*5/30)))
            final_text = final_text..'\a'..color..text:sub(i, i)
        end
        return final_text
    end
    
    function text_fade_animation_guwno(speed, r, g, b, a, text)
        local final_text = ''
        local curtime = globals.curtime()
        for i = 0, #text do
            local color = rgba_to_hex(r, g, b, a * math.abs(1 * math.cos(2 * speed * curtime / 4 - i * 5 / 30)))
            final_text = final_text .. '\a' .. color .. text:sub(i, i)
        end
        return final_text
    end
    
    if ui.get(menu.visualsTab.watermark) then
        local watermark_colorek = {}
        local r,g,b = wm[1], wm[2], wm[3]

        local text = "\affffffe5tab\a"..rgba_to_hex(r,g,b,230).."sense\affffffe5 | "..login.username..""
        if func.includes(ui.get(menu.visualsTab.watermark_og_opt), "fps") then
            text = text .. " | " .. get_fps() .. " fps"
        end
        
        if func.includes(ui.get(menu.visualsTab.watermark_og_opt), "ping") then
            local fr_r, fr_g, fr_b = lerp_color_yellow_red(client.latency(), 210, 240, 300, {255,255,255})
            text = text .. " | \a"..rgba_to_hex(fr_r,fr_g,fr_b,229).."".. round(client.latency()*1000, 0) .. "ms\affffffe5"
        end

        if func.includes(ui.get(menu.visualsTab.watermark_og_opt), "time") then
            local hours, minutes, seconds, milliseconds = client.system_time()
            hours, minutes = string.format("%02d", hours), string.format("%02d", minutes)
            text = text .. " | ".. hours .. ":" .. minutes .. ""
        end

        local text_size = vector(renderer.measure_text("", text))

        render_ogskeet_border(X - text_size.x - 20, 55, text_size.x + 2, 12, 255, text)
    else
       local text = "\a"..rgba_to_hex(wm[1], wm[2], wm[3], 220).."T A B "..text_fade_animation_guwno(2,255,255,255,220,"S E N S E") .."\a"..rgba_to_hex(wm[1], wm[2], wm[3], 220).." ["..string.upper(login.build).. "]"
       local text_size = vector(renderer.measure_text("c", text))
       if ui.get(menu.visualsTab.watermark_opt) then
        text = text:gsub(" ", "")
       end

       if ui.get(menu.visualsTab.watermark_pos) == "left" then
        renderer.text(text_size.x/2+10, Y/2 - 10, 255 , 255, 255, 255, "c",  nil, text)
       elseif ui.get(menu.visualsTab.watermark_pos) == "right" then
        renderer.text(X - text_size.x /2 - 10, Y/2 - 10, 255 , 255, 255, 255, "c",  nil, text)
       elseif ui.get(menu.visualsTab.watermark_pos) == "bottom" then  
        renderer.text(X / 2, Y - 15, 255 , 255, 255, 255, "c",  nil, text)
       elseif ui.get(menu.visualsTab.watermark_pos) == "top" then
        renderer.text(X / 2, 70, 255 , 255, 255, 255, "c",  nil, text)
       end
    end



    if func.includes(ui.get(menu.visualsTab.defensive_indicator), "Defensive") then
        icon_size = 30
    
        local r,g,b,a = ui.get(menu.visualsTab.defensive_indicatorClr)

        if to_draw == "yes" then
    
            draw_art = to_draw_ticks * 100 / 40
        
            renderer.text(X / 2 , Y / 2  * 0.5 - 10 , 255, 255, 255, 255, "c", 0, string.format("\aFFFFFFFFdefensive \a%schoking", rgba_to_hex(255, 255, 255, 255)))
            script.renderer:glow_module(X / 2 - 50, Y / 2  * 0.5,100,3, 14,2,{r,g,b,50}, {30,30,30,255})
            renderer.rectangle(X / 2, Y / 2  * 0.5 +1,draw_art / 2,2,r,g,b,255)
            renderer.rectangle(X / 2, Y / 2  * 0.5 + 1,-draw_art / 2,2,r,g,b,255)
            --renderer.rectangle(w / 2 - 55, h / 2  - 265, 110, 10, 8, 8, 8, lerp_alpha <= 150 and lerp_alpha or 150)
           -- renderer.texture(tex_id, w / 2 - 55, h / 2 - 265, 110,10, 255, 255, 255, 255, "r")
            --renderer.texture(tex_id, w / 2 - 55, h / 2 - 262, 110,10, 255, 255, 255, 255, "r")
            --renderer.text(w / 2 - 2, h / 2 - 240 ,255,255,255,lerp_alpha,"c-",0, isDefensive and " DEFENSIVE ")
            --renderer.gradient(w / 2 -55, h / 2 - 265 , 110,1, 59, 175, 222, 255, 202, 70, 205, 255,true)
           -- renderer.gradient(w / 2 -55, h / 2 - 252 , 110,1, 59, 175, 222, 255, 202, 70, 205, 255,true)
            logo:draw(X / 2 - icon_size / 2, Y / 2 * 0.46 - (icon_size/2), icon_size, nil, r,g,b,a, true)
    

            if to_draw_ticks == 39 then
                to_draw_ticks = 0
                to_draw = "no"
                lerp_alpha = lerp(lerp_alpha,0, globals.frametime() * 30)
            end
            to_draw_ticks = to_draw_ticks + 1
            ---print(to_draw_ticks)
        end
    end

    calculatePercentage = function(ticks, przez)
        local percentage = (ticks / przez) * 100
        return percentage
    end

    if func.includes(ui.get(menu.visualsTab.defensive_indicator), "Slowdown") then
        local is_defensive = to_draw == "yes" and ui.get(refs.dt[2])
        local slowed_down_value = entity.get_prop(entity.get_local_player(),"m_flVelocityModifier") * 100
        local size_bar = slowed_down_value * 98 / 100
        local r,g,b,a = ui.get(menu.visualsTab.defensive_indicatorClr)

        if slowed_down_value < 100 then
            renderer.text(X / 2 , is_defensive and Y / 2 * 0.55 - 10 or Y / 2  * 0.5 - 10 , 255, 255, 255, 255, "c", 0, string.format("\aFFFFFFFFslowed down \aFFFFFFFF(\a%s%s%%\aFFFFFFFF)", rgba_to_hex(255,255,255, 255), math.floor(calculatePercentage(size_bar, 100))))
            --renderer.rectangle(X / 2 - 50, Y / 2  * 0.5 + 0.3,100,4,50,50,50,255)
            --ctx.m_render:glow_module(X / 2 - 50, is_defensive and Y / 2 * 0.55 or Y / 2 * 0.5,100,3, 14,2,{r,g,b,50}, {30,30,30,255})
            script.renderer:glow_module(X / 2 - 50, is_defensive and Y / 2 * 0.55 or Y / 2 * 0.5,100,3, 14,2,{r,g,b,50}, {30,30,30,255})
            renderer.rectangle(X / 2, is_defensive and Y / 2 * 0.55 + 1 or Y / 2 * 0.5 + 1,size_bar / 2,2,r,g,b,255)
            renderer.rectangle(X / 2, is_defensive and Y / 2 * 0.55 + 1 or Y / 2 * 0.5 + 1,-size_bar / 2,2,r,g,b,255)
        end
    end

    if ui.is_menu_open() then
        local is_defensive = true
        local slowed_down_value = entity.get_prop(entity.get_local_player(),"m_flVelocityModifier") * 100
        local size_bar = to_draw_ticks * 100 / 40
        local r,g,b,a = ui.get(menu.visualsTab.defensive_indicatorClr)


        renderer.text(X / 2 , is_defensive and Y / 2 * 0.55 - 10 or Y / 2  * 0.5 - 10 , 255, 255, 255, 255, "c", 0, string.format("\aFFFFFFFFslowed down \aFFFFFFFF(\a%s%s%%\aFFFFFFFF)", rgba_to_hex(255,255,255, 255), math.floor(calculatePercentage(size_bar, 100))))
        --renderer.rectangle(X / 2 - 50, Y / 2  * 0.5 + 0.3,100,4,50,50,50,255)
        --ctx.m_render:glow_module(X / 2 - 50, is_defensive and Y / 2 * 0.55 or Y / 2 * 0.5,100,3, 14,2,{r,g,b,50}, {30,30,30,255})
        script.renderer:glow_module(X / 2 - 50, is_defensive and Y / 2 * 0.55 or Y / 2 * 0.5,100,3, 14,2,{r,g,b,50}, {30,30,30,255})
        renderer.rectangle(X / 2, is_defensive and Y / 2 * 0.55 + 1 or Y / 2 * 0.5 + 1,size_bar / 2,2,r,g,b,255)
        renderer.rectangle(X / 2, is_defensive and Y / 2 * 0.55 + 1 or Y / 2 * 0.5 + 1,-size_bar / 2,2,r,g,b,255)


        draw_art = to_draw_ticks * 100 / 40
        
        renderer.text(X / 2 , Y / 2  * 0.5 - 10 , 255, 255, 255, 255, "c", 0, string.format("\aFFFFFFFFdefensive \a%schoking", rgba_to_hex(255, 255, 255, 255)))
        script.renderer:glow_module(X / 2 - 50, Y / 2  * 0.5,100,3, 14,2,{r,g,b,50}, {30,30,30,255})
        renderer.rectangle(X / 2, Y / 2  * 0.5 +1,draw_art / 2,2,r,g,b,255)
        renderer.rectangle(X / 2, Y / 2  * 0.5 + 1,-draw_art / 2,2,r,g,b,255)
        --renderer.rectangle(w / 2 - 55, h / 2  - 265, 110, 10, 8, 8, 8, lerp_alpha <= 150 and lerp_alpha or 150)
       -- renderer.texture(tex_id, w / 2 - 55, h / 2 - 265, 110,10, 255, 255, 255, 255, "r")
        --renderer.texture(tex_id, w / 2 - 55, h / 2 - 262, 110,10, 255, 255, 255, 255, "r")
        --renderer.text(w / 2 - 2, h / 2 - 240 ,255,255,255,lerp_alpha,"c-",0, isDefensive and " DEFENSIVE ")
        --renderer.gradient(w / 2 -55, h / 2 - 265 , 110,1, 59, 175, 222, 255, 202, 70, 205, 255,true)
       -- renderer.gradient(w / 2 -55, h / 2 - 252 , 110,1, 59, 175, 222, 255, 202, 70, 205, 255,true)
        --logo:draw(X / 2 - icon_size / 2, Y / 2 * 0.46 - (icon_size/2), icon_size, nil, r,g,b,a, true)


        if to_draw_ticks == 39 then
            to_draw_ticks = 0
            to_draw = "no"
            lerp_alpha = lerp(lerp_alpha,0, globals.frametime() * 30)
        end
        to_draw_ticks = to_draw_ticks + 1
    end

    local vel_adap = (ui.get(menu.visualsTab.velocity_ada) and get_velocity(entity.get_local_player()) * 45 / 450)  or 0
    
    if ui.get(menu.visualsTab.arrows) then
        if ui.get(menu.visualsTab.arrowIndicatorStyle) == "Normal" then
            alpha = (aa.manualAA == 2 or aa.manualAA == 1) and func.lerp(alpha, 255, globals.frametime() * 20) or func.lerp(alpha, 0, globals.frametime() * 20)
            renderer.text(sizeX / 2 + 45, sizeY / 2 - 2.5, aa.manualAA == 2 and arrowClr.r or 200, aa.manualAA == 2 and arrowClr.g or 200, aa.manualAA == 2 and arrowClr.b or 200, alpha, "c+", 0, '>')
            renderer.text(sizeX / 2 - 45, sizeY / 2 - 2.5, aa.manualAA == 1 and arrowClr.r or 200, aa.manualAA == 1 and arrowClr.g or 200, aa.manualAA == 1 and arrowClr.b or 200, alpha, "c+", 0, '<')
        end
    
        if ui.get(menu.visualsTab.arrowIndicatorStyle) == "Teamskeet" then
            renderer.triangle(sizeX / 2 + 55 + vel_adap, sizeY / 2 + 2, sizeX / 2 + 42 + vel_adap, sizeY / 2 - 7, sizeX / 2 + 42 + vel_adap, sizeY / 2 + 11, 
            aa.manualAA == 2 and arrowClr.r or 25, 
            aa.manualAA == 2 and arrowClr.g or 25, 
            aa.manualAA == 2 and arrowClr.b or 25, 
            aa.manualAA == 2 and arrowClr.a or 160)
    
            renderer.triangle(sizeX / 2 - 55 + -vel_adap, sizeY / 2 + 2, sizeX / 2 - 42 + -vel_adap, sizeY / 2 - 7, sizeX / 2 - 42 + -vel_adap, sizeY / 2 + 11, 
            aa.manualAA == 1 and arrowClr.r or 25, 
            aa.manualAA == 1 and arrowClr.g or 25, 
            aa.manualAA == 1 and arrowClr.b or 25, 
            aa.manualAA == 1 and arrowClr.a or 160)
        
            renderer.rectangle(sizeX / 2 + 38 + vel_adap, sizeY / 2 - 7, 2, 18, 
            bodyYaw < -10 and arrowClr.r or 25,
            bodyYaw < -10 and arrowClr.g or 25,
            bodyYaw < -10 and arrowClr.b or 25,
            bodyYaw < -10 and arrowClr.a or 160)
            renderer.rectangle(sizeX / 2 - 40 + -vel_adap, sizeY / 2 - 7, 2, 18,			
            bodyYaw > 10 and arrowClr.r or 25,
            bodyYaw > 10 and arrowClr.g or 25,
            bodyYaw > 10 and arrowClr.b or 25,
            bodyYaw > 10 and arrowClr.a or 160)
        end
    end

    local scopeLevel = entity.get_prop(weapon, 'm_zoomLevel')
    local scoped = entity.get_prop(local_player, 'm_bIsScoped') == 1
    local resumeZoom = entity.get_prop(local_player, 'm_bResumeZoom') == 1
    local isValid = weapon ~= nil and scopeLevel ~= nil
    local act = isValid and scopeLevel > 0 and scoped and not resumeZoom
    local time = globals.frametime() * 30

    if act then
        if scopedFraction < 1 then
            scopedFraction = func.lerp(scopedFraction, 1 + 0.1, time)
            scopedFraction2  = func.lerp(scopedFraction, 1 + 0.1, time)
        else
            scopedFraction = 1
            scopedFraction2 = 1.45
        end
    else
        scopedFraction = func.lerp(scopedFraction, 0, time)
        scopedFraction2 = func.lerp(scopedFraction, 0, time)
    end

    -- if ui.get(menu.visualsTab.indicators) == "Default" then
    --     local dpi = ui.get(ui.reference("MISC", "Settings", "DPI scale")):gsub('%%', '') - 100
    --     local globalFlag = "cd"
    --     local globalMoveY = globalFlag == "cd-" and 5 + dpi/10 or 9 + dpi/10
    --     local indX, indY = renderer.measure_text(globalFlag, "DT")
    --     local yDefault = 18 or 9
    --     local indCount = 0
    --     indY = globalFlag == "cd-" and indY - 3 or indY - 2
    
    --     local isCharged = antiaim_funcs.get_double_tap()
    --     local isFs = ui.get(menu.keys.freestandHotkey)
    --     local isBa = ui.get(refs.forceBaim)
    --     local isSp = ui.get(refs.safePoint)
    --     local isQp = ui.get(refs.quickPeek[2])
    --     local isSlow = ui.get(refs.slow[1]) and ui.get(refs.slow[2])
    --     local isOs = ui.get(refs.os[1]) and ui.get(refs.os[2])
    --     local isFd = ui.get(refs.fakeDuck)
    --     local isDt = ui.get(refs.dt[1]) and ui.get(refs.dt[2])
    
    --     local state = vars.intToS[vars.pState]:lower()
    
    --         indicators = indicators + 1
    --         local namex, namey = renderer.measure_text(globalFlag, globalFlag == "cd-" and lua_name:lower() or lua_name:lower())
    --         local logo = animate_text(globals.curtime(), globalFlag == "cd-" and lua_name:lower() or lua_name:lower(), mainClr.r, mainClr.g, mainClr.b, 255)
    
    --         renderer.text(sizeX/2 + ((namex + 2)/2) * scopedFraction, sizeY/2 + 20 - dpi/10, 255, 255, 255, 255, globalFlag, nil, unpack(logo))

    
    --         indicators = indicators + 1
    --         local namex, namey = renderer.measure_text(globalFlag, globalFlag == "cd-" and lua_name:lower() or lua_name:lower())
    --         local stateX, stateY = renderer.measure_text(globalFlag, state:lower())
    --         local string = state:lower()
    --         renderer.text(sizeX/2 + (stateX + 2)/2 * scopedFraction, sizeY/2 + 20 + namey/1.2, 255, 255, 255, 255, globalFlag, 0, string)
    
    --         indicators = indicators + 1
    --         if isDt then 
    --             dtClr.a = func.lerp(dtClr.a, 255, time)
    --             if dtInd.y < yDefault + indY * indCount then
    --                 dtInd.y = func.lerp(dtInd.y, yDefault + indY * indCount + 1, time)
    --             else
    --                 dtInd.y = yDefault + indY * indCount
    --             end
    --             chargeInd.w = 0.1
    --             if not isCharged and func.defensive.defensive > 1 then
    --                 dtClr.r = func.lerp(dtClr.r, 144, time)
    --                 dtClr.g = func.lerp(dtClr.g, 238, time)
    --                 dtClr.b = func.lerp(dtClr.b, 144, time)
    --             elseif not isCharged then
    --                 dtClr.r = func.lerp(dtClr.r, 222, time)
    --                 dtClr.g = func.lerp(dtClr.g, 55, time)
    --                 dtClr.b = func.lerp(dtClr.b, 55, time)
    --             else
    --                 dtClr.r = func.lerp(dtClr.r, 144, time)
    --                 dtClr.g = func.lerp(dtClr.g, 238, time)
    --                 dtClr.b = func.lerp(dtClr.b, 144, time)
    --             end
    --             indCount = indCount + 1
    --         elseif not isDt then 
    --             dtClr.a = func.lerp(dtClr.a, 0, time)
    --             dtInd.y = func.lerp(dtInd.y, yDefault - 5, time)
    --         end
    
    --         renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "DT" or "dt") + 2)/2) * scopedFraction , sizeY / 2 + dtInd.y + 13 + globalMoveY, dtClr.r, dtClr.g, dtClr.b, dtClr.a, globalFlag, dtInd.w, globalFlag == "cd-" and "DT" or "dt")
    
    --         indicators = indicators + 1
    --         if isOs then 
    --             osInd.a = func.lerp(osInd.a, 255, time)
    --             if osInd.y < yDefault + indY * indCount then
    --                 osInd.y = func.lerp(osInd.y, yDefault + indY * indCount + 1, time)
    --             else
    --                 osInd.y = yDefault + indY * indCount
    --             end
        
    --             indCount = indCount + 1
    --         elseif not isOs then
    --             osInd.a = func.lerp(osInd.a, 0, time)
    --             osInd.y = func.lerp(osInd.y, yDefault - 5, time)
    --         end
    --         renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "HS" or "hs") + 2)/2) * scopedFraction, sizeY / 2 + osInd.y + 13 + globalMoveY, 255, 255, 255, osInd.a, globalFlag, osInd.w, globalFlag == "cd-" and "HS" or "hs")
    
    --         indicators = indicators + 1
    --         if isFs then 
    --             fsInd.a = func.lerp(fsInd.a, 255, time)
    --             if fsInd.y < yDefault + indY * indCount then
    --                 fsInd.y = func.lerp(fsInd.y, yDefault + indY * indCount + 1, time)
    --             else
    --                 fsInd.y = yDefault + indY * indCount
    --             end
    --             indCount = indCount + 1
    --         elseif not isFs then 
    --             fsInd.a = func.lerp(fsInd.a, 0, time)
    --             fsInd.y = func.lerp(fsInd.y, yDefault - 5, time)
    --         end
    --         local fs_col = vars.fs and {255,255,255} or {222,55,55}
    --         renderer.text(sizeX / 2 + fsInd.x + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "FS" or "fs") + 2)/2) * scopedFraction, sizeY / 2 + fsInd.y + 13 + globalMoveY, fs_col[1], fs_col[2], fs_col[3], fsInd.a, globalFlag, fsInd.w, globalFlag == "cd-" and "FS" or "fs")
    

    --         indicators = indicators + 1
    --         if isSp then 
    --             spInd.a = func.lerp(spInd.a, 255, time)
    --             if spInd.y < yDefault + indY * indCount then
    --                 spInd.y = func.lerp(spInd.y, yDefault + indY * indCount + 1, time)
    --             else
    --                 spInd.y = yDefault + indY * indCount
    --             end
    --             indCount = indCount + 1
    --         elseif not isSp then 
    --             spInd.a = func.lerp(spInd.a, 0, time)
    --             spInd.y = func.lerp(spInd.y, yDefault - 5, time)
    --         end
    --         renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "SP" or "sp") + 2)/2) * scopedFraction, sizeY / 2 + spInd.y + 13 + globalMoveY, 255, 255, 255, spInd.a, globalFlag, 0, globalFlag == "cd-" and "SP" or "sp")

    

    --         indicators = indicators + 1
    --         if isBa then
    --             baInd.a = func.lerp(baInd.a, 255, time)
    --             if baInd.y < yDefault + indY * indCount then
    --                 baInd.y = func.lerp(baInd.y, yDefault + indY * indCount + 1, time)
    --             else
    --                 baInd.y = yDefault + indY * indCount
    --             end
    --             indCount = indCount + 1
    --         elseif not isBa then 
    --             baInd.a = func.lerp(baInd.a, 0, time)
    --             baInd.y = func.lerp(baInd.y, yDefault - 5, time)
    --         end
    --         renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "BA" or "ba") + 2)/2) * scopedFraction, sizeY / 2 + baInd.y + 13 + globalMoveY, 255, 255, 255, baInd.a, globalFlag, 0, globalFlag == "cd-" and "BA" or "ba")

    

    --         indicators = indicators + 1
    --         if isFd then
    --             fdInd.a = func.lerp(fdInd.a, 255, time)
    --             if fdInd.y < yDefault + indY * indCount then
    --                 fdInd.y = func.lerp(fdInd.y, yDefault + indY * indCount + 1, time)
    --             else
    --                 fdInd.y = yDefault + indY * indCount
    --             end
    --             indCount = indCount + 1
    --         elseif not isFd then 
    --             fdInd.a = func.lerp(fdInd.a, 0, time)
    --             fdInd.y = func.lerp(fdInd.y, yDefault - 5, time)
    --         end
    --         renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "FD" or "fd") + 2)/2) * scopedFraction, sizeY / 2 + fdInd.y + 13 + globalMoveY, 255, 255, 255, fdInd.a, globalFlag, 0, globalFlag == "cd-" and "FD" or "fd")
        if ui.get(menu.visualsTab.indicators) == "New" then
            local dpi = ui.get(ui.reference("MISC", "Settings", "DPI scale")):gsub('%%', '') - 100
            local globalFlag3 = "cd"
            local globalFlag2 = "cb"
            local globalFlag = "cd"
            local globalMoveY = globalFlag == "cd-" and 5 + dpi/10 or 9 + dpi/10
            local indX, indY = renderer.measure_text(globalFlag, "DT")
            local yDefault = 18 or 9
            local indCount = 0
            indY = globalFlag == "cd-" and indY - 3 or indY - 2
        
            local isCharged = antiaim_funcs.get_double_tap()
            local isFs = ui.get(menu.keys.freestandHotkey)
            local isBa = ui.get(refs.forceBaim)
            local isSp = ui.get(refs.safePoint)
            local isQp = ui.get(refs.quickPeek[2])
            local isSlow = ui.get(refs.slow[1]) and ui.get(refs.slow[2])
            local isOs = ui.get(refs.os[1]) and ui.get(refs.os[2])
            local isFd = ui.get(refs.fakeDuck)
            local isDt = ui.get(refs.dt[1]) and ui.get(refs.dt[2])
            local state = vars.intToS[vars.pState]:lower()

            local logo = animate_text(globals.curtime(), globalFlag2 == "cd-" and login.build:lower() or login.build:lower(), mainClr.r, mainClr.g, mainClr.b, 255)
            local namex, namey = renderer.measure_text(globalFlag2, globalFlag2 == "cd-" and lua_name:lower() or lua_name:lower())

            renderer.text(sizeX/2 + ((namex + 2)/2) * scopedFraction, sizeY/2 + 20 - dpi/10, 255, 255, 255, 255, globalFlag2, nil, unpack(logo))
    
            indicators = indicators + 1
            local namex, namey = renderer.measure_text(globalFlag3, globalFlag3 == "cd-" and lua_name:upper() or lua_name:lower())
            local logo = animate_text(globals.curtime(), globalFlag3 == "cd-" and lua_name:lower() or lua_name:lower(), mainClr.r, mainClr.g, mainClr.b, 255)
    
            renderer.text(sizeX/2 + ((namex + 2)/2) * scopedFraction, sizeY/2 + 31 - dpi/10, 255, 255, 255, 255, globalFlag3, nil, unpack(logo))

    
            indicators = indicators + 1
            local namex, namey = renderer.measure_text(globalFlag3, globalFlag3 == "cd-" and lua_name:lower() or lua_name:lower())
            local stateX, stateY = renderer.measure_text(globalFlag3, state:lower())
            local string = state:lower()

    
    
            indicators = indicators + 1
            if isDt then 
                dtClr.a = func.lerp(dtClr.a, 255, time)
                if dtInd.y < yDefault + indY * indCount then
                    dtInd.y = func.lerp(dtInd.y, yDefault + indY * indCount + 1, time)
                else
                    dtInd.y = yDefault + indY * indCount
                end
                chargeInd.w = 0.1
                if not isCharged and func.defensive.defensive > 1 then
                    dtClr.r = func.lerp(dtClr.r, 144, time)
                    dtClr.g = func.lerp(dtClr.g, 238, time)
                    dtClr.b = func.lerp(dtClr.b, 144, time)
                elseif not isCharged then
                    dtClr.r = func.lerp(dtClr.r, 222, time)
                    dtClr.g = func.lerp(dtClr.g, 55, time)
                    dtClr.b = func.lerp(dtClr.b, 55, time)
                else
                    dtClr.r = func.lerp(dtClr.r, 144, time)
                    dtClr.g = func.lerp(dtClr.g, 238, time)
                    dtClr.b = func.lerp(dtClr.b, 144, time)
                end
                indCount = indCount + 1
            elseif not isDt then 
                dtClr.a = func.lerp(dtClr.a, 0, time)
                dtInd.y = func.lerp(dtInd.y, yDefault - 5, time)
            end
    
            renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "doubletap" or "doubletap") + 2)/2) * scopedFraction , sizeY / 2 + dtInd.y + 16 + globalMoveY, dtClr.r, dtClr.g, dtClr.b, dtClr.a, globalFlag, dtInd.w, globalFlag == "cd-" and "doubletap" or "doubletap")
    
            indicators = indicators + 1
            if isOs then 
                osInd.a = func.lerp(osInd.a, 255, time)
                if osInd.y < yDefault + indY * indCount then
                    osInd.y = func.lerp(osInd.y, yDefault + indY * indCount + 1, time)
                else
                    osInd.y = yDefault + indY * indCount
                end
        
                indCount = indCount + 1
            elseif not isOs then
                osInd.a = func.lerp(osInd.a, 0, time)
                osInd.y = func.lerp(osInd.y, yDefault - 5, time)
            end
            --renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "hideshots" or "hideshots") + 2)/2) * scopedFraction, sizeY / 2 + osInd.y + 20 + globalMoveY, 255, 255, 255, osInd.a, globalFlag, osInd.w, globalFlag == "cd-" and "hideshots" or "hideshots")
    
            indicators = indicators + 1
            if isFs then 
                fsInd.a = func.lerp(fsInd.a, 255, time)
                if fsInd.y < yDefault + indY * indCount then
                    fsInd.y = func.lerp(fsInd.y, yDefault + indY * indCount + 1, time)
                else
                    fsInd.y = yDefault + indY * indCount
                end
                indCount = indCount + 1
            elseif not isFs then 
                fsInd.a = func.lerp(fsInd.a, 0, time)
                fsInd.y = func.lerp(fsInd.y, yDefault - 5, time)
            end
            local fs_col = vars.fs and {255,255,255} or {222,55,55}
            renderer.text(sizeX / 2 + fsInd.x + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "freestanding" or "freestanding") + 2)/2) * scopedFraction, sizeY / 2 + fsInd.y + 18 + globalMoveY, fs_col[1], fs_col[2], fs_col[3], fsInd.a, globalFlag, fsInd.w, globalFlag == "cd-" and "freestanding" or "freestanding")

    

            indicators = indicators + 1
            if isBa then
                baInd.a = func.lerp(baInd.a, 255, time)
                if baInd.y < yDefault + indY * indCount then
                    baInd.y = func.lerp(baInd.y, yDefault + indY * indCount + 1, time)
                else
                    baInd.y = yDefault + indY * indCount
                end
                indCount = indCount + 1
            elseif not isBa then 
                baInd.a = func.lerp(baInd.a, 0, time)
                baInd.y = func.lerp(baInd.y, yDefault - 5, time)
            end
            renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "baim" or "baim") + 2)/2) * scopedFraction, sizeY / 2 + baInd.y + 19 + globalMoveY, 255, 255, 255, baInd.a, globalFlag, 0, globalFlag == "cd-" and "baim" or "baim")

    

            indicators = indicators + 1
            if isFd then
                fdInd.a = func.lerp(fdInd.a, 255, time)
                if fdInd.y < yDefault + indY * indCount then
                    fdInd.y = func.lerp(fdInd.y, yDefault + indY * indCount + 1, time)
                else
                    fdInd.y = yDefault + indY * indCount
                end
                indCount = indCount + 1
            elseif not isFd then 
                fdInd.a = func.lerp(fdInd.a, 0, time)
                fdInd.y = func.lerp(fdInd.y, yDefault - 5, time)
            end
            renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "fakeduck" or "fakeduck") + 2)/2) * scopedFraction, sizeY / 2 + fdInd.y + 18 + globalMoveY, 255, 255, 255, fdInd.a, globalFlag, 0, globalFlag == "cd-" and "fakeduck" or "fakeduck")

        elseif ui.get(menu.visualsTab.indicators) == "Second" then

            local nextAttack = entity.get_prop(vars.localPlayer, "m_flNextAttack")
            local nextPrimaryAttack = entity.get_prop(entity.get_player_weapon(vars.localPlayer), "m_flNextPrimaryAttack")
            local dtActive = false
            if nextPrimaryAttack ~= nil then
                dtActive = not (math.max(nextPrimaryAttack, nextAttack) > globals.curtime())
            end

            local dpi = ui.get(ui.reference("MISC", "Settings", "DPI scale")):gsub('%%', '') - 100
            local globalFlag3 = "cd"
            local globalFlag2 = "cd"
            local globalFlag = "cd"
            local globalMoveY = globalFlag == "cd" and 5 + dpi/10 or 9 + dpi/10
            local indX, indY = renderer.measure_text(globalFlag, "DT")
            local yDefault = 18 or 9
            local indCount = 0
            indY = globalFlag == "cd" and indY - 3 or indY - 2
            local isCharged = dtActive
            
        
         --   local isCharged = antiaim_funcs.get_double_tap()
            local isFs = ui.get(menu.keys.freestandHotkey)
            local isBa = ui.get(refs.forceBaim)
            local isSp = ui.get(refs.safePoint)
            local isQp = ui.get(refs.quickPeek[2])
            local isSlow = ui.get(refs.slow[1]) and ui.get(refs.slow[2])
            local isOs = ui.get(refs.os[1]) and ui.get(refs.os[2])
            local isFd = ui.get(refs.fakeDuck)
            local isDt = ui.get(refs.dt[1]) and ui.get(refs.dt[2])
            local state = vars.intToS[vars.pState]:lower()
            local strike_w, strike_h = renderer.measure_text("-cd", lua_name)
            local logo = animate_text(globals.curtime(), string.upper("T  A  B  S  E  N  S  E"), mainClr.r, mainClr.g, mainClr.b, 255)
    
            glow_module(sizeX/2 + ((strike_w)/2) * scopedFraction2 - strike_w/2 + 2, sizeY/2 + 20 - dpi/10, strike_w - 0, 0, 12, 0, {mainClr.r, mainClr.g, mainClr.b, 100 * math.abs(math.cos(globals.curtime()*2))}, {mainClr.r, mainClr.g, mainClr.b, 200 * math.abs(math.cos(globals.curtime()*2))})
            renderer.text(sizeX/2 + ((strike_w + 2)/2) * scopedFraction2, sizeY/2 + 20 - dpi/10, 255, 255, 255, 255, "-cd", nil, unpack(logo))
    
            local count = 0
    
            if isDt and dtActive and isDefensive == false then
                activeFraction = func.clamp(activeFraction + globals.frametime()/0.15, 0, 1)
                if dtPos.y < indY * count then
                    dtPos.y = func.lerp(dtPos.y, indY * count + 0.1, time)
                else
                    dtPos.y = indY * count
                end
                count = count + 1
            else
                activeFraction = func.clamp(activeFraction - globals.frametime()/0.15, 0, 1)
            end
    
            if isDt and dtActive and isDefensive then
                defensiveFraction = func.clamp(defensiveFraction + globals.frametime()/0.15, 0, 1)
                if dtPos.y < indY * count then
                    dtPos.y = func.lerp(dtPos.y, indY * count + 0.1, time)
                else
                    dtPos.y = indY * count
                end
                count = count + 1
            else
                defensiveFraction = func.clamp(defensiveFraction - globals.frametime()/0.15, 0, 1)
                isDefensive = false
            end
    
            if isDt and not dtActive then
                inactiveFraction = func.clamp(inactiveFraction + globals.frametime()/0.15, 0, 1)
                if dtPos.y < indY * count then
                    dtPos.y = func.lerp(dtPos.y, indY * count + 0.1, time)
                else
                    dtPos.y = indY * count
                end
                count = count + 1
            else
                inactiveFraction = func.clamp(inactiveFraction - globals.frametime()/0.15, 0, 1)
            end
    
            if isOs and ui.get(ui.reference("Rage", "Other", "Silent aim")) and isDt then
                hideInactiveFraction = func.clamp(hideInactiveFraction + globals.frametime()/0.15, 0, 1)
                if osPos.y < indY * count then
                    osPos.y = func.lerp(osPos.y, indY * count + 0.1, time)
                else
                    osPos.y = indY * count
                end
                count = count + 1
            else
                hideInactiveFraction = func.clamp(hideInactiveFraction - globals.frametime()/0.15, 0, 1)
            end
    
            if isOs and ui.get(ui.reference("Rage", "Other", "Silent aim")) and not isDt then
                hideFraction = func.clamp(hideFraction + globals.frametime()/0.15, 0, 1)
                if osPos.y < indY * count then
                    osPos.y = func.lerp(osPos.y, indY * count + 0.1, time)
                else
                    osPos.y = indY * count
                end
                count = count + 1
            else
                hideFraction = func.clamp(hideFraction - globals.frametime()/0.15, 0, 1)
            end
    
            local globalMarginX, globalMarginY = renderer.measure_text("-cd", "DSAD")
            globalMarginY = globalMarginY - 2
            local dt_size = renderer.measure_text("-cd", "DT ")
            local ready_size = renderer.measure_text("-cd", "READY")
            renderer.text(sizeX/2 + ((dt_size + ready_size + 2)/2) * scopedFraction, sizeY/2 + 30 + globalMarginY + dtPos.y, 255, 255, 255, activeFraction * 255, "-cd", dt_size + activeFraction * ready_size + 1, "DT ", "\a" .. func.RGBAtoHEX(155, 255, 155, 255 * activeFraction) .. "READY")
    
            local charging_size = renderer.measure_text("-cd", "CHARGING")
            local ret = animate_text(globals.curtime(), "CHARGING", 255, 100, 100, 255)
            renderer.text(sizeX/2 + ((dt_size + charging_size + 2)/2) * scopedFraction, sizeY/2 + 30 + globalMarginY + dtPos.y, 255, 255, 255, inactiveFraction * 255, "-cd", dt_size + inactiveFraction * charging_size + 1, "DT ", unpack(ret))
    
            local defensive_size = renderer.measure_text("-cd", "DEFENSIVE")
            local def = animate_text(globals.curtime(), "DEFENSIVE", mainClr.r, mainClr.g, mainClr.b, 255)
            renderer.text(sizeX/2 + ((dt_size + defensive_size + 2)/2) * scopedFraction, sizeY/2 + 30 + globalMarginY + dtPos.y, 255, 255, 255, defensiveFraction * 255, "-cd", dt_size + defensiveFraction * defensive_size + 1, "DT ", unpack(def))
    
            local hide_size = renderer.measure_text("-cd", "OSAA ")
            local active_size = renderer.measure_text("-cd", "ACTIVE")
            renderer.text(sizeX/2 + ((hide_size + active_size + 2)/2) * scopedFraction, sizeY/2 + 30 + globalMarginY + osPos.y, 255, 255, 255, hideFraction * 255, "-cd", hide_size + hideFraction * active_size + 1, "OSAA ", "\a" .. func.RGBAtoHEX(155, 255, 155, 255 * hideFraction) .. "ACTIVE")
            
            local inactive_size = renderer.measure_text("-cd", "INACTIVE")
            local osin = animate_text(globals.curtime(), "INACTIVE", 255, 100, 100, 255)
            renderer.text(sizeX/2 + ((hide_size + inactive_size + 2)/2) * scopedFraction, sizeY/2 + 30 + globalMarginY + osPos.y, 255, 255, 255, hideInactiveFraction * 255, "-cd", hide_size + hideInactiveFraction * inactive_size + 1, "OSAA ", unpack(osin))
        
            local state_size = renderer.measure_text("-cd", '>' .. string.upper(state) .. '<')
            renderer.text(sizeX/2 + ((state_size + 2)/2) * scopedFraction, sizeY/2 + 30 , 255, 255, 255, 255, "-cd", 0, '>' .. string.upper(state) .. '<')
        end

    if func.includes(ui.get(menu.visualsTab.defensive_indicator), "Kibit") and entity.get_classname(weapon) ~= "CKnife" and ui.get(refs.dmgOverride[1]) and ui.get(refs.dmgOverride[2]) then
        local dmg = ui.get(refs.dmgOverride[3])
        renderer.text(sizeX / 2 + 2, sizeY / 2 - 14, 255, 255, 255, 255, "d", 0, dmg)
    end

    if func.includes(ui.get(menu.resolver.xddd), "Debug Panel") then
        get_best_enemy()
        local target = best_enemy
        local desync_amount = antiaim_funcs.get_desync(2)
        local xd = antiaim_funcs.get_tickbase_shifting()
        local xd2 = antiaim_funcs.get_body_yaw(2)
        local text_size = vector(renderer.measure_text("", "tabsense.lua - " .. string.lower(login.username)))

        if client.key_state(0x01) and ui.is_menu_open() then
            local mouse_pos = { ui.mouse_position() }
            if intersect(debug_x - 5, debug_y - 60, text_size.x + 12, 83 + 34) then
                debug_x = mouse_pos[1] - 65
                debug_y = mouse_pos[2]
            end
        end

        if ui.get(menu.resolver.debug_style) == "Skeet border" then
            render_ogskeet_border(debug_x, debug_y, text_size.x + 7, 83 + 9, 255, "")
        end


        renderer.text(debug_x, debug_y - 44 + 4, 255, 255, 255, 255, "", 0, "tabsense.lua - " .. string.lower(login.username))
        renderer.text(debug_x, debug_y - 44 + 14, 255, 255, 255, 255, "", 0, "version: \a" ..rgba_to_hex(255,255,255,255 * math.abs(math.cos(globals.curtime()*2))) .. string.lower(login.build))
        renderer.text(debug_x, debug_y - 44 + 24, 255, 255, 255, 255, "", 0, "target: " .. string.lower(entity.get_player_name(target)))
        renderer.text(debug_x, debug_y - 44 + 34, 255, 255, 255, 255, "", 0, "enemy yaw: " .. yaw_save)
        renderer.text(debug_x, debug_y - 44 + 44, 255, 255, 255, 255, "", 0, "old target value: " .. yaw_save / 2 or yaw_save * 2)
        renderer.text(debug_x, debug_y - 44 + 54, 255, 255, 255, 255, "", 0, "body yaw: " .. math.floor(xd2))
        renderer.text(debug_x, debug_y - 44 + 64, 255, 255, 255, 255, "", 0, "exploit charge: " .. xd) 
        renderer.text(debug_x, debug_y - 44 + 74, 255, 255, 255, 255, "", 0, "choke: " .. globals.chokedcommands())
        renderer.text(debug_x, debug_y - 44 + 84, 255, 255, 255, 255, "", 0, "overlap: " .. math.floor(antiaim_funcs.get_overlap() * 100))
    end


    if indicators == 0 then
        local watermarkX, watermarkY = renderer.measure_text("cd-", "")
        local lua_watermarkname = ''
        local logo = animate_text(globals.curtime(), globalFlag == "cd-" and lua_watermarkname:upper() or lua_watermarkname:upper(), mainClr.r, mainClr.g, mainClr.b, 255)
        renderer.text(sizeX/2-watermarkX/2+24, sizeY/1.025,  mainClr.r, mainClr.g, mainClr.b, 255, "c", 0, unpack(logo))
    end

    local call_back = ui.get(menu.visualsTab.logs) and client.set_event_callback or client.unset_event_callback

    notifications.render()
end)

local u8, device, localize, surface, notify = {}, {}, {}, {}, {}

do 
    function u8:len(s)
        return #s:gsub("[\128-\191]", "");
    end

    local string_mod; do
        local float = 0;
        local to_alpha = 1 / 255;

        local function fn(rgb, alpha)
            return string.format("%s%02x", rgb, float * tonumber(alpha, 16));
        end

        function string_mod(s, alpha)
            float = alpha * to_alpha;
            return s:gsub("(\a%x%x%x%x%x%x)(%x%x)", fn);
        end
    end

    function device:on_update()
        local new_rect = vector(client.screen_size());

        if new_rect ~= self.rect then
            self.rect = new_rect;
        end
    end

    function device:draw_text(x, y, r, g, b, a, flags, max_width, ...)
        local text = table.concat {...};
        text = string.mod(text, a);

        renderer.text(x, y, r, g, b, a, flags, max_width, text);
    end

    local native_ConvertAnsiToUnicode = vtable_bind("localize.dll", "Localize_001", 15, "int(__thiscall*)(void* thisptr, const char *ansi, wchar_t *unicode, int buffer_size)")
    local native_ConvertUnicodeToAnsi = vtable_bind("localize.dll", "Localize_001", 16, "int(__thiscall*)(void* thisptr, wchar_t *unicode, char *ansi, int buffer_size)")

    function localize:ansi_to_unicode(ansi, unicode, buffer_size)
        return native_ConvertAnsiToUnicode(ansi, unicode, buffer_size);
    end

    function localize:unicode_to_ansi(ansi, unicode, buffer_size)
        return native_ConvertUnicodeToAnsi(ansi, unicode, buffer_size);
    end

    local native_SetTextFont = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 23, "void*(__thiscall*)(void *thisptr, dword font_id)");
    local native_SetTextColor = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 25, "void*(__thiscall*)(void *thisptr, int r, int g, int b, int a)");
    local native_SetTextPos = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 26, "void*(__thiscall*)(void *thisptr, int x, int y)");
    local native_DrawPrintText = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 28, "void*(__thiscall*)(void *thisptr, const wchar_t *text, int maxlen, int draw_type)");

    local native_GetTextSize = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 79, "void(__thiscall*)(void *thisptr, size_t font, const wchar_t *text, int &wide, int &tall)");

    local native_GetFontName = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 134, "const char*(__thiscall*)(void *thisptr, size_t font)");

    local buffer = ffi.new("wchar_t[65535]");
    local wide, tall = ffi.new("int[1]"), ffi.new("int[1]");

    local to_alpha = 1 / 255;

    function surface:get_font_name(font_id)
        return ffi.string(native_GetFontName(font_id));
    end

    function surface:text(font, x, y, r, g, b, a, ...)
        local text = table.concat {...};
        localize:ansi_to_unicode(text, buffer, 65535);

        native_GetTextSize(font, buffer, wide, tall);

        native_SetTextFont(font);
        native_SetTextPos(x, y);
        native_SetTextColor(r, g, b, a);

        native_DrawPrintText(buffer, u8:len(text), 0);

        return wide[0], tall[0];
    end

    function surface:color_text(font, x, y, r, g, b, a, ...)
        local text = table.concat {...};
        local i, j = text:find "\a";

        if i ~= nil then
            x = x + self:text(font, x, y, r, g, b, a, text:sub(1, i - 1))

            while i ~= nil do
                local new_r, new_g, new_b, new_a = r, g, b, a;

                if text:sub(i, j + 7) == "\adefault" then
                    text = text:sub(1 + j + 7);
                else
                    local hex = text:sub(i + 1, j + 8);
                    text = text:sub(1 + j + 8);

                    new_r, new_g, new_b, new_a = func.frgba(hex);
                    new_a = new_a * (a * to_alpha);
                end

                i, j = text:find "\a";

                local new_text = text;

                if i ~= nil then
                    new_text = text:sub(1, i - 1);
                end

                x = x + self:text(font, x, y, new_r, new_g, new_b, new_a, new_text);
            end

            return;
        end

        self:text(font, x, y, r, g, b, a, text);
    end

    local native_ConsoleIsVisible = vtable_bind("engine.dll", "VEngineClient014", 11, "bool(__thiscall*)(void*)");
    local native_ColorPrint = vtable_bind("vstdlib.dll", "VEngineCvar007", 25, "void(__cdecl*)(void*, const color_t&, const char*, ...)");

    local queue = {};
    local current;

    local times = 6;
    local duration = 8;

    local buffer = ffi.new("color_t");
    local to_alpha = 1 / 255;

    local function color_print(r, g, b, a, ...)
        buffer.r, buffer.g, buffer.b, buffer.a = r, g, b, a;
        native_ColorPrint(buffer, ...);
    end

    function notify:color_log(r, g, b, a, ...)
        local text = table.concat {...};
        local i, j = text:find "\a";

        if i ~= nil then
            color_print(r, g, b, a, text:sub(1, i - 1));

            while i ~= nil do
                local new_r, new_g, new_b, new_a = r, g, b, a;

                if text:sub(i, j + 7) == "\adefault" then
                    text = text:sub(1 + j + 7);
                else
                    local hex = text:sub(i + 1, j + 8);
                    text = text:sub(1 + j + 8);

                    new_r, new_g, new_b, new_a = rgba(hex);
                    new_a = new_a * a * to_alpha;
                end

                i, j = text:find "\a";

                local new_text = text;

                if i ~= nil then
                    new_text = text:sub(1, i - 1);
                end

                color_print(new_r, new_g, new_b, new_a, new_text);
            end

            color_print(0, 0, 0, 0, "\n");
            return;
        end

        color_print(r, g, b, a, text .. "\n");
    end

    function notify:add_to_queue(r, g, b, a, ...)
        local text = table.concat {...};

        local this =
        {
            text = text,
            colour = {r, g, b, a},
            colored = true,
            liferemaining = duration
        };

        queue[#queue + 1] = this;

        while #queue > times do
            table.remove(queue, 1);
        end

        return this;
    end

    function notify:should_draw()
        local is_visible = false;
        local host_frametime = globals.frametime();

        if not native_ConsoleIsVisible() then
            for i = #queue, 1, -1 do
                local v = queue[i];
                v.liferemaining = v.liferemaining - host_frametime;

                if v.liferemaining <= 0 then
                    table.remove(queue, i);
                    goto continue;
                end

                is_visible = true;
                ::continue::
            end
        end

        return is_visible;
    end

    function notify:on_paint_ui()
        local x, y = 8, 5;
        local flags = "d";

        for i = 1, #queue do
            local v = queue[i];

            local colour = v.colour;
            local r, g, b, a = colour[1], colour[2], colour[3], colour[4];

            local text = v.text:gsub("\n", "");
            local measure = vector(renderer.measure_text(flags, text));

            local tall = measure.y + 1;

            if v.liferemaining < .5 then
                local f = func.fclamp(v.liferemaining, 0, .5) / .5;
                a = a * f;

                if i == 1 and f < .2 then
                    y = y - tall * (1 - f / .2);
                end
            end

            if v.colored then
                surface:color_text(63, x, y, r, g, b, a, text);
            else
                surface:text(63, x, y, r, g, b, a, text);
            end

            y = y + tall;
        end
    end

    function notify:on_output(e)
        local text = string.format("\a%02x%02x%02x%02x%s", e.r, e.g, e.b, e.a, e.text);
        local i = text:find "\0";

        if i ~= nil then
            text = text:sub(1, i - 1);
        end

        if current ~= nil then
            current.text = current.text .. text;

            if i == nil then
                current = nil;
            end

            return current;
        end

        local this = self:add_to_queue(e.r, e.g, e.b, e.a, text);
        this.colored = text:find "\a" ~= nil;

        if i ~= nil then
            current = this;
        end

        return this;
    end

    function notify:on_console_input(e)
        if e:find("clear") == 1 then
            for i = 1, #queue do
                queue[i] = nil;
            end
        end
    end
end

device:on_update()

client.set_event_callback("paint_ui", function()
    device:on_update()
    notify:should_draw()
    notify:on_paint_ui()
end)


-- @region UI_CALLBACKS start
ui.update(menu.configTab.list,getConfigList())
if database.read(lua.database.configs) == nil then
    database.write(lua.database.configs, {})
end
ui.set(menu.configTab.name, #database.read(lua.database.configs) == 0 and "" or database.read(lua.database.configs)[ui.get(menu.configTab.list)+1].name)
ui.set_callback(menu.configTab.list, function(value)
    local protected = function()
        if value == nil then return end
        local name = ""
    
        local configs = getConfigList()
        if configs == nil then return end
    
        name = configs[ui.get(value)+1] or ""
    
        ui.set(menu.configTab.name, name)
    end

    if pcall(protected) then

    end
end)

ui.set_callback(menu.configTab.load, function()
    local r, g, b = ui.get(menu.visualsTab.logsClr)
    local name = ui.get(menu.configTab.name)
    if name == "" then return end

    local protected = function()
        loadConfig(name)
    end

    if pcall(protected) then
        name = name:gsub('*', '')
        notifications.new(string.format('Successfully loaded config!'), r, g, b)
    else
        notifications.new(string.format('Failed to load config!'), 255, 120, 120)
    end
end)

ui.set_callback(menu.configTab.save, function()
    local r, g, b = ui.get(menu.visualsTab.logsClr)

    local name = ui.get(menu.configTab.name)
    if name == "" then return end

    for i, v in pairs(presets) do
        if v.name == name:gsub('*', '') then
            notifications.new(string.format('Disable presets [402]"', name:gsub('*', '')), 255, 120, 120) --cant save with ready-to-use presets
            return
        end
    end

    if name:match("[^%w]") ~= nil then
        notifications.new(string.format('[401] You cant save Default config', name), 255, 120, 120) --due to invalid characters
        return
    end

    local protected = function()
        saveConfig(name)
        ui.update(menu.configTab.list, getConfigList())
    end
    if pcall(protected) then
        notifications.new(string.format('Successfully saved config!'), r, g, b)
    else
        notifications.new(string.format('Failed to save config! [406]'), 255, 120, 120)
    end
end)

ui.set_callback(menu.configTab.delete, function()
    local name = ui.get(menu.configTab.name)
    if name == "" then return end
    local r, g, b = ui.get(menu.visualsTab.logsClr)
    if deleteConfig(name) == false then
        notifications.new(string.format('Error [403]'), 255, 120, 120) --failed to delete cfg
        ui.update(menu.configTab.list, getConfigList())
        return
    end

    for i, v in pairs(presets) do
        if v.name == name:gsub('*', '') then
            notifications.new(string.format('[410]"', name:gsub('*', '')), 255, 120, 120) -- cant delete ready-to-use presets
            return
        end
    end

    local protected = function()
        deleteConfig(name)
    end

    if pcall(protected) then
        ui.update(menu.configTab.list, getConfigList())
        ui.set(menu.configTab.list, #presets + #database.read(lua.database.configs) - #database.read(lua.database.configs))
        ui.set(menu.configTab.name, #database.read(lua.database.configs) == 0 and "" or getConfigList()[#presets + #database.read(lua.database.configs) - #database.read(lua.database.configs)+1])
        notifications.new(string.format('Deleted "$%s$"', name), r, g, b)
    end
end)

ui.set_callback(menu.configTab.import, function()
    local r, g, b = ui.get(menu.visualsTab.logsClr)

    local protected = function()
        importSettings()
    end

    if pcall(protected) then
        notifications.new(string.format('Successfully loaded config', name), r, g, b)
    else
        notifications.new(string.format('Bad import config!', name), 255, 120, 120)
    end
end)

ui.set_callback(menu.configTab.export, function()
    local name = ui.get(menu.configTab.name)
    if name == "" then return end

    local protected = function()
        exportSettings(name)
    end
    local r, g, b = ui.get(menu.visualsTab.logsClr)

    if pcall(protected) then
        notifications.new(string.format('Successfully shared config!', name), r, g, b)
    else
        notifications.new(string.format('Failed to export settings!', name), 255, 120, 120)
    end
end)

local logica1337 = "2"

ui.set_callback(menu.builderTab.PresetComboBox, function()
    if ui.get(menu.builderTab.PresetComboBox) == "Unmatched" then
        local r, g, b = ui.get(menu.visualsTab.logsClr)

        local protected = function()
            importPreset()
        end

        if pcall(protected) then
            notifications.new(string.format('Enabled Un\adec3c3ffmatched', name), r, g, b)
        else
            notifications.new(string.format('Invaild Settings', name), 255, 120, 120)
        end
    elseif ui.get(menu.builderTab.PresetComboBox) == "Community" then
        local r, g, b = ui.get(menu.visualsTab.logsClr)

        local protected = function()
            importPreset2()
        end

        if pcall(protected) then
            notifications.new(string.format('Enabled Comm\adec3c3ffunity', name), r, g, b)
        else
            notifications.new(string.format('Invaild Settings', name), 255, 120, 120)
        end
    end
end)

-- ui.set_callback(menu.builderTab.buttonPresets, function()
--     local r, g, b = ui.get(menu.visualsTab.logsClr)

--     local protected = function()
--         ui.set(menu.builderTab.LogicComboBox, "2")
--     end

--     if pcall(protected) then
--         --notifications.new(string.format('Pres\adec3c3ffets', name), r, g, b)
--     else
--         notifications.new(string.format('Failed to open Pres\adec3c3ffets', name), 255, 120, 120)
--     end
-- end)

ui.set_callback(menu.builderTab.buttonBuilder, function()
    local r, g, b = ui.get(menu.visualsTab.logsClr)

    local protected = function()
        ui.set(menu.builderTab.LogicComboBox, "1")
        ui.set(menu.builderTab.PresetComboBox, "Disabled")
        --importPresetClear()
    end

    if pcall(protected) then
        notifications.new(string.format('Successfully exported settings to your builder', name), r, g, b)
    else
        notifications.new(string.format('Disabled Presets', name), 255, 120, 120)
    end
end)

client.set_event_callback("paint_ui", function()
    vars.activeState = vars.sToInt[ui.get(menu.builderTab.state)]
    local isEnabled = ui.get(masterSwitch)
    local isAATab = ui_menu.selected_tab == 1 and ui.get(aaTabs) == "Other"
    local keys2 = ui_menu.selected_tab == 1 and ui.get(aaTabs) == "Keybinds"
    local isBuilderTab = ui_menu.selected_tab == 1 and ui.get(aaTabs) == "Builder"
    local isVisualsTab = ui_menu.selected_tab == 2
    local isMiscTab = ui_menu.selected_tab == 3
    local isCFGTab = ui_menu.selected_tab == 4
    local ispresetdisabled = ui.get(menu.builderTab.PresetComboBox) == "Disabled"
    local isLogicBuilder = ui.get(menu.builderTab.LogicComboBox) == "1"
    local isLogicPresets = ui.get(menu.builderTab.LogicComboBox) == "2"

    ui.set(aaBuilder[1].enableState, true)
    for i = 1, #vars.aaStates do
        local stateEnabled = ui.get(aaBuilder[i].enableState)
        local defensivedziala = ui.get(aaBuilder[i].enabledefensive)
        ui.set_visible(aaBuilder[i].enableState, vars.activeState == i and isBuilderTab and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].pitch, vars.activeState == i and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].pitchSlider , vars.activeState == i and isBuilderTab and stateEnabled and ui.get(aaBuilder[i].pitch) == "Custom" and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawBase, vars.activeState == i and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yaw, vars.activeState == i and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawCondition, vars.activeState == i and ui.get(aaBuilder[i].yaw) ~= "Off" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawStatic, vars.activeState == i and ui.get(aaBuilder[i].yaw) ~= "Off" and ui.get(aaBuilder[i].yawCondition) == "Static"  and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawLeft, vars.activeState == i and ui.get(aaBuilder[i].yaw) ~= "Off" and ui.get(aaBuilder[i].yawCondition) ~= "Static" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawRight, vars.activeState == i and ui.get(aaBuilder[i].yaw) ~= "Off" and ui.get(aaBuilder[i].yawCondition) ~= "Static" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawSpeed, vars.activeState == i and ui.get(aaBuilder[i].yaw) ~= "Off" and ui.get(aaBuilder[i].yawCondition) == "Delay" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawJitter, vars.activeState == i and ui.get(aaBuilder[i].yaw) ~= "Off" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawJitterCondition, vars.activeState == i and ui.get(aaBuilder[i].yawJitter) ~= "Off" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawJitterStatic, vars.activeState == i and ui.get(aaBuilder[i].yawJitter) ~= "Off" and ui.get(aaBuilder[i].yawJitterCondition) == "Static" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawJitterLeft, vars.activeState == i and ui.get(aaBuilder[i].yawJitter) ~= "Off" and ui.get(aaBuilder[i].yawJitterCondition) == "L & R" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawJitterRight, vars.activeState == i and ui.get(aaBuilder[i].yawJitter) ~= "Off" and ui.get(aaBuilder[i].yawJitterCondition) == "L & R" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
       -- ui.set_visible(aaBuilder[i].yawJitterDisablers, vars.activeState == i and ui.get(aaBuilder[i].yawJitter) ~= "Off" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].bodyYaw, vars.activeState == i and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].bodyYawSlider, vars.activeState == i and ui.get(aaBuilder[i].bodyYaw) ~= "Off" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].enabledefensive, vars.activeState == i and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].defensiveOpt, vars.activeState == i and isBuilderTab and defensivedziala and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].defensiveYaw, vars.activeState == i and isBuilderTab and defensivedziala and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].defensiveYawSlider, vars.activeState == i and isBuilderTab and defensivedziala and stateEnabled and isEnabled and ui.get(aaBuilder[i].defensiveYaw) == "Custom" and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].defensivePitch, vars.activeState == i and isBuilderTab and defensivedziala and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].defensivePitchSlider, vars.activeState == i and isBuilderTab and defensivedziala and stateEnabled and isEnabled and ui.get(aaBuilder[i].defensivePitch) == "Custom" and ispresetdisabled and isLogicBuilder)
    end

    for i, feature in pairs(menu.aaTab) do
        if type(feature) ~= "table" then
            ui.set_visible(feature, isAATab and isEnabled and ui.get(aaTabs) == "Other")
        end
	end 

   -- local bindykurwa = ui.get(menu.keys.Bindyhehe)
   -- ui.set_visible(menu.keys.Bindyhehe, isBuilderTab and isEnabled and ispresetdisabled and isLogicBuilder)
    ui.set_visible(menu.builderTab.state, ui.get(menu.builderTab.PresetComboBox) == "Disabled" and isBuilderTab and isEnabled and isLogicBuilder)
    ui.set_visible(menu.builderTab.buttonBuilder, isBuilderTab and isEnabled and isLogicPresets)
   -- ui.set_visible(menu.builderTab.buttonPresets, isBuilderTab and isEnabled and isLogicBuilder)
    ui.set_visible(menu.builderTab.PresetComboBox, isBuilderTab and isEnabled and isLogicPresets)
    ui.set_visible(aaTabs, isBuilderTab or keys2 or isAATab and isEnabled)
    ui.set_visible(menu.builderTab.LogicComboBox, isBuilderTab and isEnabled and logica1337 == "1")

    ui.set_visible(menu.keys.freestandHotkey, keys2 and ui.get(aaTabs) == "Keybinds" and isEnabled) 
    ui.set_visible(menu.keys.edgeYawHotkey, keys2 and ui.get(aaTabs) == "Keybinds" and isEnabled)
    ui.set_visible(menu.keys.freestandDisablers, keys2 and ui.get(aaTabs) == "Keybinds" and isEnabled)
    --ui.set_visible(ctx.ui.menu.Normal.resolver2), 
    


    for i, feature in pairs(menu.visualsTab) do
        if type(feature) ~= "table" then
            ui.set_visible(feature, isVisualsTab and isEnabled)
        end
	end 
--2.0

    for i, feature in pairs(menu.keys.manualTab) do
        if type(feature) ~= "table" then
            ui.set_visible(feature,  keys2 and ui.get(aaTabs) == "Keybinds" and isEnabled)
        end
	end 


    ui.set_visible(menu.visualsTab.logsClr, ui.get(menu.visualsTab.logs) and isVisualsTab and isEnabled and ui.get(menu.visualsTab.logs_style) == "Default")
    ui.set_visible(menu.visualsTab.indicatorsClr, ui.get(menu.visualsTab.indicators) == "New" or ui.get(menu.visualsTab.indicators) == "Second" and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.arrowIndicatorStyle, ui.get(menu.visualsTab.arrows) and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.arrowClr, ui.get(menu.visualsTab.arrows) and isVisualsTab and isEnabled)
    --ui.set_visible(menu.visualsTab.watermarkClr, ui.get(menu.visualsTab.watermark) and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.watermark_opt, not ui.get(menu.visualsTab.watermark) and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.watermark_pos, not ui.get(menu.visualsTab.watermark) and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.watermark_og_opt, ui.get(menu.visualsTab.watermark) and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.logs_style, ui.get(menu.visualsTab.logs) and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.velocity_ada, ui.get(menu.visualsTab.arrowIndicatorStyle) == "Teamskeet" and isVisualsTab and isEnabled)

    ui.set_visible(menu.resolver.debug_style, func.includes(ui.get(menu.resolver.xddd), "Debug"))
    ui.set_visible(menu.configTab.export, isCFGTab and isEnabled)
    
    for i, feature in pairs(menu.miscTab) do
        if type(feature) ~= "table" then
            ui.set_visible(feature, isMiscTab and isEnabled)
        end
	end
    ui.set_visible(menu.miscTab.fastLadder, ui.get(menu.miscTab.fastLadderEnabled) and isMiscTab and isEnabled)
    ui.set_visible(menu.miscTab.animations, ui.get(menu.miscTab.animationsEnabled) and isMiscTab and isEnabled)

    for i, feature in pairs(menu.configTab) do
		ui.set_visible(feature, isCFGTab and isEnabled)
	end

    -- for i, feature in pairs(menu.configTab) do
	-- 	ui.set_visible(feature, isLogicBuilder and isCFGTab and isEnabled)
	-- end

    if not isEnabled and not saved then
        func.resetAATab()
        ui.set(refs.fsBodyYaw, isEnabled)
        ui.set(refs.enabled, isEnabled)
        saved = true
    elseif isEnabled and saved then
        ui.set(refs.fsBodyYaw, not isEnabled)
        ui.set(refs.enabled, isEnabled)
        saved = false
    end
    func.setAATab()

end)

-------------------------------------------------------------------------------------------------reso

local miss_save = 0

local function GetPlayerVelocity(player)
    local vec_vel = vector(entity.get_prop(player, "m_vecVelocity"))
    return math.floor(math.sqrt(vec_vel.x^2 + vec_vel.y^2) + 0.5)
end

local function in_air(player)
    local flags = entity.get_prop(player, "m_fFlags")

    if bit.band(flags, 1) == 0 then
        return true
    end

    return false
end

-- local function normalize_yaw1(yaws)
--     while yaws > 180 do
--         yaws = yaws - 360
--     end
--     while yaws < -180 do
--         yaws = yaws + 360
--     end
--     return yaws
-- end

local get_entities = function(enemy_only, alive_only)
    local enemy_only = enemy_only ~= nil and enemy_only or false
    local alive_only = alive_only ~= nil and alive_only or true

    local result = {}

    local me = entity.get_local_player()
    local player_resource = entity.get_player_resource()

    for player = 1, globals.maxplayers() do
        local is_enemy, is_alive = true, true

        if enemy_only and not entity.is_enemy(player) then
            is_enemy = false
        end
        if is_enemy then
            if alive_only and entity.get_prop(player_resource, 'm_bAlive', player) ~= 1 then
                is_alive = false
            end
            if is_alive then
                table.insert(result, player)
            end
        end
    end

    return result
end

local vector_c = {}
local vector_mt = {
    __index = vector_c
}

function vector_c.eye_position(player)
    local origin = vector(entity.get_prop(player, "m_vecOrigin"))
    local duck_amount = entity.get_prop(eid, "m_flDuckAmount") or 0

    origin.z = origin.z + 46 + (1 - duck_amount) * 18

    return origin
end

local function get_anim_layer(b, c)
    c = c or 1;
    b = ffi.cast(classptr, b)
    return ffi.cast('struct animation_layer_t**', ffi.cast('char*', b) + 0x2990)[0][c]
end

yaw_save = 0

local function in_air(player)
    local flags = entity.get_prop(player, "m_fFlags")

    if bit.band(flags, 1) == 0 then
        return true
    end

    return false
end

-------------------------------------------------------------------------------------------------reso

local function ResolveJitter(player, currentYaw, currentEyeAnglesX, currentEyeAnglesY)
    local function AngleBetween(v1, v2)
        return math.deg(math.acos((v1.x * v2.x + v1.y * v2.y) / (math.sqrt(v1.x * v1.x + v1.y * v1.y) * math.sqrt(v2.x * v2.x + v2.y * v2.y))))
    end

    local animstate = GetAnimationState(player) 


    local yaw_body_xd = entity.get_prop(player, "m_flPoseParameter", 11)

    local currentYaw = entity.get_prop(player, "m_flLowerBodyYawTarget") --lowerbody
    local pitchYaw = entity.get_prop(player, "m_angEyeAngles[0]") --pitch
   -- local currentYaw1 = math.floor(normalize_yaw1(entity.get_prop(player, "m_angEyeAngles[1]"))) --yaw
    local currentYaw3 = entity.get_prop(player, "m_flLowerBodyYawTarget")


    local angle = math.deg(math.atan2(entity.get_prop(player, "m_angEyeAngles[1]") - entity.get_prop(player, "m_flLowerBodyYawTarget"), entity.get_prop(player, "m_angEyeAngles[0]")))
    local yawik = math.min(60, math.max(-60, (angle * 10000)))



    local enemyEyeAnglesY = entity.get_prop(player, "m_angEyeAngles[1]")
    local lowerBodyYawTarget = entity.get_prop(player, "m_flLowerBodyYawTarget")
    local current_time = globals.tickcount()
    local velocity = GetPlayerVelocity(player)
    local isinair = in_air(player)
    local enemyPosition = vector(entity.get_prop(player, "m_vecOrigin"))
    local nDuckAmount = entity.get_prop(player, "m_flDuckAmount")
    local slowwalkMultiplier = 0.8
    local duckMultiplier = 0.75
    local local_origin = vector(entity.get_prop(local_player, "m_vecAbsOrigin"))
    local enemyDistance = vector(entity.get_prop(player, "m_vecOrigin"))
    enemyDistance = local_origin:dist(enemyDistance)
    local r41_138 = require("vector");


    local prefix = function(x, z) 
        return (z and ("\aC84545FFtabsense \a698a6dFF~ \a414141FF(\ab5b5b5FF%s\a414141FF) \aC84545FF%s"):format(x, z) or ("\aC84545FFtabsense \a698a6dFF~ \aC84545FF%s"):format(x)) 
    end

   local yaws2 = yawik
    
  local r109_138 = false;
   if func.includes(ui.get(menu.resolver.other_menu), "Math Random Resolver") then
           plist.set(player, "Force body yaw", true)
           plist.set(player, "Force body yaw value", math.random(-60, 60))
--    elseif func.includes(ui.get(menu.resolver.xddd), "Resolver [Recode 0.1]") then
--     if func.includes(ui.get(menu.resolver.xddd), "Resolver [Recode 0.1]") then
--         r109_138 = true;
--         for r3_198, r4_198 in ipairs(entity.get_players(true)) do
--             local r6_198 = r35_138.new(r4_198);
--             local r8_198 = {entity.get_prop(r4_198, "m_angEyeAngles")};
--             local r7_198 = math.floor(math.min(60, (entity.get_prop(player, "m_flPoseParameter", 11) * 120) - 60));
--             local r10_1982 = math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw)));
--             if (math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw))) < (r7_198 + 1)) and ((r7_198 - 1) < math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw)))) then
--                 plist.set(player, "Force body yaw", false);
--             else
--                 local ang1 = entity.get_prop(player, "m_angEyeAngles[1]") * (180 / math.pi)
--                 local ang2 = entity.get_prop(player, "m_angEyeAngles[0]") * (180 / math.pi)
--                 local delta = r8_198[2] - r6_198:get_anim_state().current_feet_yaw * r6_198:get_anim_overlay().playback_rate
--                 local delta2 = r8_198[2] - r8_198[3] * r6_198:get_anim_overlay().playback_rate
--                 local r10_198 =  r8_198[2] - r6_198:get_anim_state().current_feet_yaw * r6_198:get_anim_overlay().playback_rate
--                 local r5_198 = {r89_0.get_bounding_box(r4_198)};
--                 local r6_198 = r35_138.new(r4_198);
--                 local r7_198 = math.floor(math.min(60, (entity.get_prop(r4_198, "m_flPoseParameter", 11) * 120) - 60));
--                 local r8_198 = {entity.get_prop(r4_198, "m_angEyeAngles")};
--                 local r9_198 = r1_0.band(entity.get_prop(r4_198, "m_fFlags"), 1) == 1;
--                 local isinair = in_air(player)

--                 local lastyawupdate = globals.tickcount() + 10
--                 local modelside = delta2

--                 local eye_angles = entity.get_prop(r4_198, "m_angEyeAngles")
                
--                 local foot_yaw = r6_198:get_anim_state().current_feet_yaw
                
--                 local eye_foot_delta = (r8_198[2] - foot_yaw) % 360
            
        

--                 if eye_foot_delta > 180 then
--                     eye_foot_delta = eye_foot_delta - 360
--                 elseif eye_foot_delta < -180 then
--                     eye_foot_delta = eye_foot_delta + 360
--                 end

--                 local yaws = eye_foot_delta


--                 if velocity == 0 or velocity == 1 then
--                     plist.set(player, "Force body yaw", false)    
--                -- print("stand")
--                 elseif (math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw))) < (r7_198 + 1)) and ((r7_198 - 1) < math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw)))) then
--                     plist.set(player, "Force body yaw", false);
--                     --print("delta")
--                 elseif delta == 0 then
--                     plist.set(player, "Force body yaw", false)
--                    -- print("0")
--                 elseif r6_198:get_anim_state().duck_amount > 0.5 and not isinair then
--                         r10_198 = r10_198 / 2;
--                      --   print("duck")
--                 elseif r10_198 > 90 then
--                     plist.set(player, "Force body yaw", true);
--                     plist.set(player, "Force body yaw value", yaws); --r10_198
--                    -- print("90")
--                 elseif isinair then --NOWE DO TESTU WCZESNIEJ NIE BYLO
--                     plist.set(player, "Force body yaw", true)
--                     plist.set(player, "Force body yaw value", yaws)  --r10_198
--                     if plist.set(player, "Force body yaw value", yaws) then
--                        -- print("inair-yaws")
--                     elseif plist.set(player, "Force body yaw value", r10_198) then 
--                        -- print("r10")
--                     end
--                 elseif math.abs(delta - delta2) == 0 then
--                     plist.set(player, "Force body yaw", true)
--                     plist.set(player, "Force body yaw value", 0)
--                    -- print("abs")
--                 elseif r41_138(entity.get_prop(player, "m_vecVelocity")):length2d() < 2 then
--                     plist.set(player, "Force body yaw", false);
--                    -- print("2d")
--                 elseif lastyawupdate > globals.tickcount() and eye_foot_delta == 0 then 
--                     plist.set(player, "Force body yaw value", (modelside) > 0 and 60 or -60)
--                    -- print("lastyaw")
--                 else
--                     plist.set(player, "Force body yaw", true)
--                     plist.set(player, "Force body yaw value", yaws) 
--                 end
--             end
--         end
--     elseif r109_138 == true then
--         for r3_198 = 1, globals.maxplayers(), 1 do
--             if (r25_138(r3_198) == "CCSPlayer") and (entity.get_prop(r3_198, "m_iTeamNum") ~= entity.get_prop(r28_138(), "m_iTeamNum")) then
--                 plist.set(r3_198, "Force body yaw", false);
--                 plist.set(r3_198, "Force body yaw value", 0);
--             end
--         end
--         r109_138 = false;
--     end
   end


   

-- elseif ui.get(menu.resolver.delta_mode) == "AI [ALPHA]" then
   
--     if ui.get(menu.resolver.delta_mode) == "AI [ALPHA]" then
--         r109_138 = true;
--         for r3_198, r4_198 in ipairs(entity.get_players(true)) do
--             local r5_198 = {r89_0.get_bounding_box(r4_198)};
--             local r6_198 = r35_138.new(r4_198);
--             local r7_198 = math.floor(math.min(60, (entity.get_prop(r4_198, "m_flPoseParameter", 11) * 120) - 60));
--             local r8_198 = {entity.get_prop(r4_198, "m_angEyeAngles")};
--             local r10_1982 = math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw)));
--             local r9_198 = r1_0.band(entity.get_prop(r4_198, "m_fFlags"), 1) == 1;

--              if velocity == 0 or velocity == 1 then
--                  plist.set(player, "Force body yaw", false)
--              end

--             if (math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw))) < (r7_198 + 1)) and ((r7_198 - 1) < math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw)))) then
--                 plist.set(r4_198, "Force body yaw", false);
--             else
--                 local r10_198 = math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw)));
--                 if r87_0.is_menu_open() then
--                   --  plist.set(r4_198, "Force body yaw", false);
--                    -- plist.set(r4_198, "Force body yaw value", 0);
--                 elseif r41_138(entity.get_prop(r4_198, "m_vecVelocity")):length2d() < 2 then
--                     plist.set(r4_198, "Force body yaw", false);
--                 else
--                     if not r9_198 then
--                         r10_198 = r10_198 / 2;
--                     elseif r6_198:get_anim_state().duck_amount > 0.5 then
--                         r10_198 = r10_198 / 2;
--                     elseif r10_198 ~= 60 then
--                         if r10_198 == -60 then
--                             plist.set(r4_198, "Force body yaw", false);
--                         end
--                     else
--                         plist.set(r4_198, "Force body yaw", false);
--                     end
--                     plist.set(r4_198, "Force body yaw", true);
--                     plist.set(r4_198, "Force body yaw value", r10_198);
--                  end
--             end
--         end
--     elseif r109_138 == true then
--         for r3_198 = 1, globals.maxplayers(), 1 do
--             if (r25_138(r3_198) == "CCSPlayer") and (entity.get_prop(r3_198, "m_iTeamNum") ~= entity.get_prop(r28_138(), "m_iTeamNum")) then
--                 plist.set(r3_198, "Force body yaw", false);
--                 plist.set(r3_198, "Force body yaw value", 0);
--             end
--         end
--         r109_138 = false;
--     end

-- end

    yaw_save = plist.get(player, "Force body yaw value")
end


local function Resolver(player)
        if entity.is_dormant(player) or entity.get_prop(player, "m_bDormant") then
            return
        end

        if func.includes(ui.get(menu.resolver.other_menu), "Defensive Resolver") then
            for k,ent in ipairs(entity.get_players(true)) do
                local jump = bit.band(entity.get_prop(ent, "m_fFlags"), 1) 
                local y,p = entity.get_prop(ent,"m_angEyeAngles")
                local ent_flags = entity.get_esp_data(ent).flags
                
        
                if jump == 0 then
                    if y < -1 then
                        plist.set(ent,"Force pitch",true)
                        plist.set(ent,"Force pitch value",0)
                        plist.set(ent,"Force body yaw",true)
                        plist.set(ent,"Force body yaw value",0)
                      --  ui.set(accuracy_boost, "Low")
                    else
                        plist.set(ent,"Force pitch",false)
                      --  ui.set(accuracy_boost, accuracy_boost_save)
                    end
                end
            end
        end

        ResolveJitter(player)
end

local function ResolverUpdate()
    local enemies = entity.get_players(true)
    for i, enemy_ent in ipairs(enemies) do
        if enemy_ent and entity.is_alive(enemy_ent) and entity.get_prop(enemy_ent, "m_iTeamNum") ~= entity.get_prop(entity.get_local_player(), "m_iTeamNum") then
            Resolver(enemy_ent)
        end
    end
end


local function aim_hit(e)
    miss_save = 0
end

client.set_event_callback('round_start', function()
    miss_save = 0
end)

client.set_event_callback("aim_hit", aim_hit)
client.set_event_callback("setup_command", ResolverUpdate)
-------------------------------------------------------------------------------------------------reso


client.set_event_callback("shutdown", function()
    if hsValue ~= nil then
        ui.set(refs.fakeLag[1], hsValue)
    end
    if clanTag ~= nil then
        client.set_clan_tag("")
    end
    if dtSaved ~= nil then
        ui.set(refs.dt[3], "Defensive")
    end
    func.setAATab(true)
end)