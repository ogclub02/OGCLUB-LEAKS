local lua_name = "t a b s e n s e"
local lua_color = {r = 222, g = 195, b = 195}
local data = obex_fetch and obex_fetch() or {username = 'wyscigufa9', build = 'Source', discord=''}
X,Y = client.screen_size()

local lua_banner = [[                                                                                                                                                                                                                                    
]]

local function try_require(module, msg)
    local success, result = pcall(require, module)
    if success then return result else return error(msg) end
end

local pui = require("gamesense/pui")

local images = try_require("gamesense/images", "Download images library: https://gamesense.pub/forums/viewtopic.php?id=22917")
local bit = try_require("bit")
local base64 = try_require("gamesense/base64", "Download base64 encode/decode library: https://gamesense.pub/forums/viewtopic.php?id=21619")
local antiaim_funcs = try_require("gamesense/antiaim_funcs", "Download anti-aim functions library: https://gamesense.pub/forums/viewtopic.php?id=29665")
local ffi = try_require("ffi", "Failed to require FFI, please make sure Allow unsafe scripts is enabled!")
local vector = try_require("vector", "Missing vector")
local http = try_require("gamesense/http", "Download HTTP library: https://gamesense.pub/forums/viewtopic.php?id=21619")
local clipboard = try_require("gamesense/clipboard", "Download Clipboard library: https://gamesense.pub/forums/viewtopic.php?id=28678")
local ent = try_require("gamesense/entity", "Download Entity Object library: https://gamesense.pub/forums/viewtopic.php?id=27529")
local csgo_weapons = try_require("gamesense/csgo_weapons", "Download CS:GO weapon data library: https://gamesense.pub/forums/viewtopic.php?id=18807")
local ent = try_require("gamesense/entity")
local steamworks = try_require("gamesense/steamworks") or error('Missing https://gamesense.pub/forums/viewtopic.php?id=26526')

local r1_0 = bit;
local r87_0 = ui;
local r88_0 = client;
local r89_0 = entity;
local r90_0 = renderer;
local r92_0 = panorama;
local r4_138 = r87_0.new_combobox;
local r5_138 = r87_0.new_checkbox;
local r6_138 = r87_0.new_multiselect;
local r7_138 = r87_0.new_label;
local r8_138 = r87_0.new_color_picker;
local r35_138 = require("gamesense/entity") or error("Failed to load entity | https://gamesense.pub/forums/viewtopic.php?id=27529");

local crr_t = ffi.typeof('void*(__thiscall*)(void*)')
local cr_t = ffi.typeof('void*(__thiscall*)(void*)')
local gm_t = ffi.typeof('const void*(__thiscall*)(void*)')
local gsa_t = ffi.typeof('int(__fastcall*)(void*, void*, int)')


local var_table = {};
    
local prev_simulation_time = 0

local function time_to_ticks(t)
    return math.floor(0.5 + (t / globals.tickinterval()))
end
local diff_sim = 0

function var_table:sim_diff() 
    local current_simulation_time = time_to_ticks(entity.get_prop(entity.get_local_player(), "m_flSimulationTime"))
    local diff = current_simulation_time - prev_simulation_time
    prev_simulation_time = current_simulation_time
    diff_sim = diff
    return diff_sim
end

local login = {
    username = data.username,
    version = "1.0.0",
    build = data.build,
}

if not LPH_OBFUSCATED then
    LPH_NO_VIRTUALIZE = function (...)
        return ...;
    end
end

debug_x, debug_y = 30, Y / 2

local function intersect(x, y, width, height)
    local cx, cy = ui.mouse_position()
    return cx >= x and cx <= x + width and cy >= y and cy <= y + height
end

local new_class = function()
	local mt, mt_data, this_mt = { }, { }, { }

	mt.__metatable = false
	mt_data.struct = function(self, name)
		assert(type(name) == 'string', 'invalid class name')
		assert(rawget(self, name) == nil, 'cannot overwrite subclass')

		return function(data)
			assert(type(data) == 'table', 'invalid class data')
			rawset(self, name, setmetatable(data, {
				__metatable = false,
				__index = function(self, key)
					return
						rawget(mt, key) or
						rawget(this_mt, key)
				end
			}))

			return this_mt
		end
	end

	this_mt = setmetatable(mt_data, mt)

	return this_mt
end

local function normalize_yaw1(yaws)
    while yaws > 180 do
        yaws = yaws - 360
    end
    while yaws < -180 do
        yaws = yaws + 360
    end
    return yaws
end


local color = {}
color.__index = color

function color.new(r, g, b, a)
    local self = setmetatable({}, color)

    self.r = r or 255
    self.g = g or 255
    self.b = b or 255
    self.a = a or 255

    return self
end

color.__add = function(a, b)
    return color.new(a.r + b.r, a.g + b.g, a.b + b.b, a.a + b.a)
end

color.__sub = function(a, b)
    return color.new(a.r - b.r, a.g - b.g, a.b - b.b, a.a - b.a)
end

color.__mul = function(a, b)
    return color.new(a.r * b.r, a.g * b.g, a.b * b.b, a.a * b.a)
end

color.__div = function(a, b)
    return color.new(a.r / b.r, a.g / b.g, a.b / b.b, a.a / b.a)
end

color.__eq = function(a, b)
    return a.r == b.r and a.g == b.g and a.b == b.b and a.a == b.a
end

color.__tostring = function(self)
    return string.format("color(%d, %d, %d, %d)", self.r, self.g, self.b, self.a)
end

function color:table()
    return { self.r, self.g, self.b, self.a }
end

function color:hex()
    return string.format("%02x%02x%02x%02x", self.r, self.g, self.b, self.a)
end

function color:unpack()
    return self.r, self.g, self.b, self.a
end

function color:lerp(color, amount)
    local r = self.r + (color.r - self.r) * amount
    local g = self.g + (color.g - self.g) * amount
    local b = self.b + (color.b - self.b) * amount
    local a = self.a + (color.a - self.a) * amount

    return color.new(r, g, b, a)
end

if login.build == 'User' then
    login.build = 'Live'
end

local x, o = '\x14\x14\x14\xFF', '\x0c\x0c\x0c\xFF'

local pattern = table.concat{
    x,x,o,x,
    o,x,o,x,
    o,x,x,x,
    o,x,o,x
  }

  local logo = images.load(base64.decode("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"))


local tex_id = renderer.load_rgba(pattern, 4, 4)

local ui_menu = {
    tabs_names = {"","","☰",""},

    selected_tab = 1,
    selected_color = { {20, 20, 20, 255}, {210,210,210,255} },
    menu_alpha = 255,
    is_hovered = false,
    dpi_scaling_y = {{84,149},{100,181},{116,213},{132,245},{148,276}},
    pesadelo_na_cozinha2 = {597,741,885,1030,1173 },
    selected_gs_tab = false,
    mouse_press = false,
    old_mpos = {0,0}
}

local function lerp(a, b, t)
    return a + (b - a) * t
end

local script = {}

script.renderer = {
    rec = function(self, x, y, w, h, radius, color)
         radius = math.min(x/2, y/2, radius)
         local r, g, b, a = unpack(color)
         renderer.rectangle(x, y + radius, w, h - radius*2, r, g, b, a)
         renderer.rectangle(x + radius, y, w - radius*2, radius, r, g, b, a)
         renderer.rectangle(x + radius, y + h - radius, w - radius*2, radius, r, g, b, a)
         renderer.circle(x + radius, y + radius, r, g, b, a, radius, 180, 0.25)
         renderer.circle(x - radius + w, y + radius, r, g, b, a, radius, 90, 0.25)
         renderer.circle(x - radius + w, y - radius + h, r, g, b, a, radius, 0, 0.25)
         renderer.circle(x + radius, y - radius + h, r, g, b, a, radius, -90, 0.25)
     end,
 
     rec_outline = function(self, x, y, w, h, radius, thickness, color)
         radius = math.min(w/2, h/2, radius)
         local r, g, b, a = unpack(color)
         if radius == 1 then
             renderer.rectangle(x, y, w, thickness, r, g, b, a)
             renderer.rectangle(x, y + h - thickness, w , thickness, r, g, b, a)
         else
             renderer.rectangle(x + radius, y, w - radius*2, thickness, r, g, b, a)
             renderer.rectangle(x + radius, y + h - thickness, w - radius*2, thickness, r, g, b, a)
             renderer.rectangle(x, y + radius, thickness, h - radius*2, r, g, b, a)
             renderer.rectangle(x + w - thickness, y + radius, thickness, h - radius*2, r, g, b, a)
             renderer.circle_outline(x + radius, y + radius, r, g, b, a, radius, 180, 0.25, thickness)
             renderer.circle_outline(x + radius, y + h - radius, r, g, b, a, radius, 90, 0.25, thickness)
             renderer.circle_outline(x + w - radius, y + radius, r, g, b, a, radius, -90, 0.25, thickness)
             renderer.circle_outline(x + w - radius, y + h - radius, r, g, b, a, radius, 0, 0.25, thickness)
         end
     end,
 
     glow_module = function(self, x, y, w, h, width, rounding, accent, accent_inner)
         local thickness = 1
         local offset = 1
         local r, g, b, a = unpack(accent)
         if accent_inner then
             self:rec(x , y, w, h + 1, rounding, accent_inner)
         end
         for k = 0, width do
             if a * (k/width)^(1) > 5 then
                 local accent = {r, g, b, a * (k/width)^(2)}
                 self:rec_outline(x + (k - width - offset)*thickness, y + (k - width - offset) * thickness, w - (k - width - offset)*thickness*2, h + 1 - (k - width - offset)*thickness*2, rounding + thickness * (width - k + offset), thickness, accent)
             end
         end
     end
 }


 function ui_menu:is_aa_tab()
    local menu_size = { ui.menu_size() }
  
    
    local menu_pos = { ui.menu_position() }
    local mouse_pos = { ui.mouse_position() }

   local scale = {0,0}
   local scale_x = 0
   local pesadelo_no_direito = 0

    if ui.get(ui.reference("MISC","Settings","DPI scale")) == "100%" then
        scale = { ui_menu.dpi_scaling_y[1][1],ui_menu.dpi_scaling_y[1][2] }
        scale_x = 76
        pesadelo_no_direito = ui_menu.pesadelo_na_cozinha2[1]
    elseif ui.get(ui.reference("MISC","Settings","DPI scale"))  == "125%" then
        scale = { ui_menu.dpi_scaling_y[2][1],ui_menu.dpi_scaling_y[2][2] }
        scale_x = 95
        pesadelo_no_direito = ui_menu.pesadelo_na_cozinha2[2]
    elseif ui.get(ui.reference("MISC","Settings","DPI scale"))  == "150%" then
        scale = { ui_menu.dpi_scaling_y[3][1],ui_menu.dpi_scaling_y[3][2] }
        scale_x = 113
        pesadelo_no_direito = ui_menu.pesadelo_na_cozinha2[3]
    elseif ui.get(ui.reference("MISC","Settings","DPI scale"))  == "175%" then
        scale = { ui_menu.dpi_scaling_y[4][1],ui_menu.dpi_scaling_y[4][2] }
        scale_x = 132
        pesadelo_no_direito = ui_menu.pesadelo_na_cozinha2[4]
    elseif ui.get(ui.reference("MISC","Settings","DPI scale"))  == "200%" then
        scale = { ui_menu.dpi_scaling_y[5][1],ui_menu.dpi_scaling_y[5][2] }
        scale_x = 151
        pesadelo_no_direito = ui_menu.pesadelo_na_cozinha2[5]
    end

    if ui_menu.mouse_press == false then
        ui_menu.old_mpos = mouse_pos
    end      

    if client.key_state(0x1) then
        if not ui_menu.mouse_press then
            ui_menu.mouse_press = true
            if mouse_pos[1] > menu_pos[1] + 5 and mouse_pos[1] < menu_pos[1] + 5 + scale_x then
                if mouse_pos[2] > menu_pos[2] + scale[1] and mouse_pos[2] < menu_pos[2] + scale[2] then
                    ui_menu.selected_gs_tab = true
                    
                elseif mouse_pos[2] > menu_pos[2] + 19 and (menu_size[2] >= pesadelo_no_direito and mouse_pos[2] < menu_pos[2] + menu_size[2] or mouse_pos[2] < menu_pos[2] + pesadelo_no_direito) and ui_menu.selected_gs_tab == true then
                    ui_menu.selected_gs_tab = false
                end
            end
        end
    else
        ui_menu.mouse_press = false
    end
end


function ui_menu:new_tab()

    ui_menu.is_hovered = false
    if not ui.is_menu_open()  then
        ui_menu.menu_alpha = lerp(ui_menu.menu_alpha,0,globals.frametime() * 50)
    else
        ui_menu.menu_alpha = lerp(ui_menu.menu_alpha,255,globals.frametime() * 5)
    end

    if ui_menu.menu_alpha < 50 then return end

    local menu_size = { ui.menu_size() }
    local divide_menu = (menu_size[1] - 12) / #ui_menu.tabs_names
    
    local menu_pos = { ui.menu_position() }
    local mouse_pos = { ui.mouse_position() }

    if not ui_menu.selected_gs_tab then return end

    for k,v in ipairs(ui_menu.tabs_names) do

        if ui_menu.selected_tab == k then
            ui_menu.selected_color[1] = {20, 20, 20}
            ui_menu.selected_color[2] = {210, 210, 210}
        else
            ui_menu.selected_color[1] = {12, 12, 12}
            ui_menu.selected_color[2] = {90, 90, 90}
        end
       
        renderer.text(menu_pos[1] + (divide_menu * k) - divide_menu / 2 ,menu_pos[2] - 25,ui_menu.selected_color[2][1], ui_menu.selected_color[2][2], ui_menu.selected_color[2][3],ui_menu.menu_alpha,"cd+",0,v)

        if mouse_pos[1] > menu_pos[1] + (divide_menu * k) -  divide_menu and mouse_pos[1] < menu_pos[1] + (divide_menu * k) and mouse_pos[2] > menu_pos[2] - 50 and mouse_pos[2] < menu_pos[2] then
            ui_menu.is_hovered = true
            if  client.key_state(0x1) then
                ui_menu.selected_tab = k
            end
        end
    end
    renderer.text(menu_pos[1] + (divide_menu * ui_menu.selected_tab) - divide_menu / 2 ,menu_pos[2] - 25,210, 210, 210,ui_menu.menu_alpha,"cd+",0,ui_menu.tabs_names[ui_menu.selected_tab])
end

function ui_menu:render_tabs() 
    local menu_s = { ui.menu_size() }
    local menu_p = { ui.menu_position() }

    if not ui.is_menu_open()  then
        ui_menu.menu_alpha = lerp(ui_menu.menu_alpha,0,globals.frametime() * 90)
    else
        ui_menu.menu_alpha = lerp(ui_menu.menu_alpha,255,globals.frametime() * 5)
    end

    local divide_menu = (menu_s[1] - 12) / #ui_menu.tabs_names
    
    if ui_menu.menu_alpha < 170 then return end

    if not ui_menu.selected_gs_tab then return end

    renderer.texture(tex_id, menu_p[1] + 1, menu_p[2]-49, menu_s[1] - 2, 50, 255, 255, 255, ui_menu.menu_alpha, "r")

    --renderer.rectangle(menu_p[1] + (divide_menu * ui_menu.selected_tab) - divide_menu + 7, menu_p[2] - 44,divide_menu -1,50,11,11,11,255) 
    
    --top bar
    renderer.rectangle(menu_p[1] ,menu_p[2] - 53,menu_s[1] ,1 ,12,12,12,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + 2,menu_p[2] - 52,menu_s[1] - 4,5 ,60,60,60,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + 2,menu_p[2] - 51,menu_s[1] - 4,3 ,40,40,40,ui_menu.menu_alpha) 
    
    --left bar
    renderer.rectangle(menu_p[1] ,menu_p[2] - 53,1,53 ,12,12,12,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + 1,menu_p[2] - 52,4,52 ,60,60,60,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + 2,menu_p[2] - 51,3,51 ,40,40,40,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + 5,menu_p[2] - 48,1,48 ,60,60,60,ui_menu.menu_alpha)
    
    --right bar
    renderer.rectangle(menu_p[1] + menu_s[1] - 1,menu_p[2] - 53,1,53 ,12,12,12,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + menu_s[1] - 3,menu_p[2] - 52,2,52 ,60,60,60,ui_menu.menu_alpha) 
    renderer.rectangle(menu_p[1] + menu_s[1] - 5,menu_p[2] - 51,3,51 ,40,40,40,ui_menu.menu_alpha)
    renderer.rectangle(menu_p[1] + menu_s[1] - 6,menu_p[2] - 48,1,48 ,60,60,60,ui_menu.menu_alpha) 

    renderer.gradient(menu_p[1] + 7,menu_p[2] - 46, menu_s[1]/2,1, 59, 175, 222, ui_menu.menu_alpha, 202, 70, 205, ui_menu.menu_alpha,true)
                
    renderer.gradient(menu_p[1] + 7 + menu_s[1]/2 ,menu_p[2] - 46, menu_s[1]/2 - 13.3, 1,203, 70, 205, ui_menu.menu_alpha,204, 227, 53, ui_menu.menu_alpha,true)
end

client.set_event_callback("paint_ui", ui_menu.is_aa_tab)
client.set_event_callback("paint_ui", ui_menu.render_tabs)
client.set_event_callback("paint_ui", ui_menu.new_tab)


----------------------------------------------------------------------------------------------------------------------------------------------MENU




client.exec("clear")
client.color_log(255, 255, 255, " \n \n \n \n \n ")
client.color_log(lua_color.r, lua_color.g, lua_color.b, lua_banner)
client.color_log(255, 255, 255, " \n \n \n \n \n ")

normalize = function(self, angle)
    angle =  angle % 360 
    angle = (angle + 360) % 360
    if (angle > 180)  then
        angle = angle - 360
    end
    return angle
end

local function round(num, numDecimalPlaces)
	local mult = 10^(numDecimalPlaces or 0)
	return math.floor(num * mult + 0.5) / mult
end

local ft_prev = 0
local function get_fps()
	ft_prev = ft_prev * 0.9 + globals.absoluteframetime() * 0.1
	return round(1 / ft_prev)
end

local function lerp(a, b, percentage)
	return a + (b - a) * percentage
end

local function table_lerp(a, b, percentage)
	local result = {}
	for i=1, #a do
		result[i] = lerp(a[i], b[i], percentage)
	end
	return result
end

local function clamp(cur_val, min_val, max_val)
	return math.min(math.max(cur_val, min_val), max_val)
end

local function lerp_color_yellow_red(val, max_normal, max_yellow, max_red, default, yellow, red)
	default = default or {255, 255, 255}
	yellow = yellow or {230, 210, 40}
	red = red or {255, 32, 32}
	if val > max_yellow then
		return unpack(table_lerp(yellow, red, clamp((val-max_yellow)/(max_red-max_yellow), 0, 1)))
	else
		return unpack(table_lerp(default, yellow, clamp((val-max_normal)/(max_yellow-max_normal), 0, 1)))
	end
end

function render_ogskeet_border(x,y,w,h,a,text)
    renderer.rectangle(x - 10, y - 48 ,w + 20, h + 16,12,12,12,a)
    renderer.rectangle(x - 9, y - 47 ,w + 18, h + 14,60,60,60,a)
    renderer.rectangle(x - 8, y - 46 ,w + 16, h + 12,40,40,40,a)
    renderer.rectangle(x - 5, y - 43 ,w + 10, h + 6,60,60,60,a)
    renderer.rectangle(x - 4, y - 42 ,w + 8, h + 4,12,12,12,a)
    renderer.texture(tex_id, x - 4, y - 42, w + 8, h + 4, 255, 255, 255, a, "r")
    renderer.gradient(x - 4,y - 42, w /2, 1, 59, 175, 222, a, 202, 70, 205, a,true)               
    renderer.gradient(x - 4 + w / 2 ,y - 42, w /2 + 8.5, 1,202, 70, 205, a,204, 227, 53, a,true)
    renderer.text(x, y - 40, 255,255,255,a, "", nil, text)
end

-- resolver_data = {}
-- local ctx = (function()
--     local ctx = {}

--     ctx.globals = {
--         states = {"stand", "slow walk", "run", "duck", "duck move", "jump", "duck jump", "fakelag", "hideshots"},
-- 		extended_states = {"global", "stand", "slow walk", "run", "duck", "duck move", "jump", "duck jump", "fakelag", "hideshots"},
-- 		teams = {"t", "ct"},
-- 		in_ladder = 0,
-- 		nade = 0,
-- 		resolver_data = {}
--     }


--     ctx.resolver = {
--       run = function(self)
--     end
-- }
  
--     return ctx
-- end)()

local ctx = new_class()

:struct 'helpers' {
    last_eye_yaw = 0,
		was_in_air = true,
		last_tick = globals.tickcount(),

		contains = function(self, tbl, val)
			for k, v in pairs(tbl) do
				if v == val then
					return true
				end
			end
			return false
		end,

		get_lerp_time = function(self)
			local ud_rate = cvar.cl_updaterate:get_int()
			
			local min_ud_rate = cvar.sv_minupdaterate:get_int()
			local max_ud_rate = cvar.sv_maxupdaterate:get_int()
			
			if (min_ud_rate and max_ud_rate) then
				ud_rate = max_ud_rate
			end

			local ratio = cvar.cl_interp_ratio:get_float()
			
			if (ratio == 0) then
				ratio = 1
			end

			local lerp = cvar.cl_interp:get_float()
			local c_min_ratio = cvar.sv_client_min_interp_ratio:get_float()
			local c_max_ratio = cvar.sv_client_max_interp_ratio:get_float()
			
			if (c_min_ratio and  c_max_ratio and  c_min_ratio ~= 1) then
				ratio = clamp(ratio, c_min_ratio, c_max_ratio)
			end

			return math.max(lerp, (ratio / ud_rate));
		end,

		rgba_to_hex = function(self, r, g, b, a)
			return bit.tohex(
			(math.floor(r + 0.5) * 16777216) + 
			(math.floor(g + 0.5) * 65536) + 
			(math.floor(b + 0.5) * 256) + 
			(math.floor(a + 0.5))
			)
		end,

		easeInOut = function(self, t)
			return (t > 0.5) and 4*((t-1)^3)+1 or 4*t^3;
		end,

		animate_text = function(self, time, string, r, g, b, a)
			local t_out, t_out_iter = { }, 1

			local l = string:len( ) - 1
	
			local r_add = (255 - r)
			local g_add = (255 - g)
			local b_add = (255 - b)
			local a_add = (155 - a)
	
			for i = 1, #string do
				local iter = (i - 1)/(#string - 1) + time
				t_out[t_out_iter] = "\a" .. self:rgba_to_hex( r + r_add * math.abs(math.cos( iter )), g + g_add * math.abs(math.cos( iter )), b + b_add * math.abs(math.cos( iter )), a + a_add * math.abs(math.cos( iter )) )
	
				t_out[t_out_iter + 1] = string:sub( i, i )
	
				t_out_iter = t_out_iter + 2
			end
	
			return t_out
		end,

		clamp = function(self, val, lower, upper)
			assert(val and lower and upper, "not very useful error message here")
			if lower > upper then lower, upper = upper, lower end -- swap if boundaries supplied the wrong way
			return math.max(lower, math.min(upper, val))
		end,

		get_damage = function(self)
			local mindmg = ui.get(self.ref.rage.mindmg[1])
			if ui.get(self.ref.rage.ovr[1]) and ui.get(self.ref.rage.ovr[2]) then
				return ui.get(self.ref.rage.ovr[3])
			else
				return mindmg
			end
		end,

		normalize = function(self, angle)
			angle =  angle % 360 
			angle = (angle + 360) % 360
			if (angle > 180)  then
				angle = angle - 360
			end
			return angle
		end,

		fetch_data = function(self, ent)
			return {
				origin = vector(entity.get_origin(ent)), -- +
				vev_velocity = vector(entity.get_prop(ent, "m_vecVelocity")),
				view_offset = entity.get_prop(ent, "m_vecViewOffset[2]"), -- +
				eye_angles = vector(entity.get_prop(ent, "m_angEyeAngles")), -- +
				lowerbody_target = entity.get_prop(ent, "m_flLowerBodyYawTarget"),
				simulation_time = self.helpers:time_to_ticks(entity.get_prop(ent, "m_flSimulationTime")),
				tickcount = globals.tickcount(),
				curtime = globals.curtime(),
				tickbase = entity.get_prop(ent, "m_nTickBase"),
				origin = vector(entity.get_prop(ent, "m_vecOrigin")),
				flags = entity.get_prop(ent, "m_fFlags"),
			}
		end,

		time_to_ticks = function(self, t)
			return math.floor(0.5 + (t / globals.tickinterval()))
		end,

		menu_visibility = function(self, visible)
			for _, v in pairs(self.ref.aa) do
				for _, item in ipairs(v) do
					ui.set_visible(item, visible)
				end
			end
		end,

		in_ladder = function(self)
			local me = entity.get_local_player()

			if entity.is_alive(me) then
				if entity.get_prop(me, "m_MoveType") == 9 then
					self.globals.in_ladder = globals.tickcount() + 8
				end
			else
				self.globals.in_ladder = 0
			end

		end,

		in_air = function(self, ent)
			local flags = entity.get_prop(ent, "m_fFlags")
			return bit.band(flags, 1) == 0
		end,

		in_duck = function(self, ent)
			local flags = entity.get_prop(ent, "m_fFlags")
			return bit.band(flags, 4) == 4
		end,

    get_eye_yaw = function (self, ent)
      if ent == nil then
        return
      end

      local player_ptr = get_client_entity(ientitylist, ent)
      if player_ptr == nil then
        return
      end

      if globals.chokedcommands() == 0 then
	      self.last_eye_yaw = ffi.cast("float*", ffi.cast("char*", ffi.cast("void**", ffi.cast("char*", player_ptr) + 0x9960)[0]) + 0x78)[0]
      end

      return self.last_eye_yaw
    end,

    get_closest_angle = function(self, max, min, dir, ang)
      -- Calculate the absolute angular difference between d and a, b, and c
      max = self.helpers:normalize(max)
      min = self.helpers:normalize(min)
      dir = self.helpers:normalize(dir)
      ang = self.helpers:normalize(ang)

      --check if ang is between max and min and also in the same side as dir
      local diff_maxang = math.abs((max - ang + 180) % 360 - 180)
      local diff_minang = math.abs((min - ang + 180) % 360 - 180)
      local diff_maxdir = math.abs((max - dir + 180) % 360 - 180)
      local diff_mindir = math.abs((min - dir + 180) % 360 - 180)
      local diff_minmax = math.abs((min - max + 180) % 360 - 180)

      local ang_side = diff_maxang > diff_minmax or diff_minang > diff_minmax

      local dir_side = diff_maxdir > diff_minmax or diff_mindir > diff_minmax

      if dir_side ~= ang_side then
        if diff_minang < diff_maxang then
          return 0
        else
          return 1
        end
        return
      end

      return 2
    end,

		get_freestanding_side = function(self, data)
			local me = entity.get_local_player()
			local target = client.current_threat()
			local _, yaw = client.camera_angles()
			local pos = vector(client.eye_position())

      if not target then
        return 2
      end
			
			_, yaw = (pos - vector(entity.get_origin(target))):angles()
			
			local yaw_offset = data.offset
			local yaw_jitter_type = string.lower(data.type)
			local yaw_jitter_amount = data.value
			
			local offset = math.abs(yaw_jitter_amount)
			
			if yaw_jitter_type == 'skitter' then
				offset = math.abs(yaw_jitter_amount) + 33
			elseif yaw_jitter_type == 'offset' then
				offset = math.max(0, yaw_jitter_amount)
			elseif yaw_jitter_type == 'center' then
				offset = math.abs(yaw_jitter_amount)/2
			end
			
			local max_yaw = self.helpers:normalize(yaw + yaw_offset + offset)
			
			local min_offset = offset
			if yaw_jitter_type == 'offset' then
				min_offset = math.abs(math.min(0, yaw_jitter_amount))
			end
			
			local min_yaw = self.helpers:normalize(yaw + yaw_offset - min_offset)
			
			local current_yaw = self:get_eye_yaw(me)

      local left_offset = max_yaw - current_yaw
      local right_offset = min_yaw - current_yaw

      local closest = self:get_closest_angle(min_yaw, max_yaw, yaw, current_yaw)
			
      return closest
		end,

		get_state = function(self)
			local me = entity.get_local_player()
			local velocity = vector(entity.get_prop(me, "m_vecVelocity")):length2d()
			local duck = self:in_duck(me) or ui.get(self.ref.rage.fd[1])

			local state = velocity > 1.5 and "run" or "stand"
			
			if self:in_air(me) or self.was_in_air then
				state = duck and "duck jump" or "jump"
			elseif velocity > 1.5 and duck then
				state = "duck move"
			elseif ui.get(self.ref.slow_motion[1]) and ui.get(self.ref.slow_motion[2]) then
				state = "slow walk"
			elseif duck then
				state = "duck"
			end
			if globals.tickcount() ~= self.last_tick then
				self.was_in_air = self:in_air(me)
				self.last_tick = globals.tickcount()
			end
			return state
		end,

		get_team = function(self)
			local me = entity.get_local_player()
			local index = entity.get_prop(me, "m_iTeamNum")

			return index == 2 and "t" or "ct"
		end,

		loop = function (arr, func)
			if type(arr) == "table" and arr.__type == "pui::element" then
				func(arr)
			else
				for k, v in pairs(arr) do
					loop(v, func)
				end
			end
		end,

		get_charge = function ()
			local me = entity.get_local_player()
			local simulation_time = entity.get_prop(entity.get_local_player(), "m_flSimulationTime")
			return (globals.tickcount() - simulation_time/globals.tickinterval())
		end,
	}


    :struct 'ui' {
		menu = {
			global = {},
            Normal = {},
			Debug = {},
            resik = {},
		},
        

		execute = function(self)
			local group = pui.group("Players", "Adjustments")
			self.menu.global.tab = group:combobox("\badffff\bfacfff[TAB SELECTOR]\n", {"Normal", "Debug"})
            self.menu.Normal.resolver2 = group:combobox("\badffff\bfacfff[Resolver [Recode]]\n", {"Off", "On"})
            self.menu.Normal.label2 = group:label(" ")
            self.menu.Debug.resolver = group:combobox("\badffff\bfacfff[AI [Recode]]\n", {"Off", "On"})
            self.menu.Debug.tab2 = group:combobox(" \ntab", {"Smart", "Dangerous"}):depend({self.menu.Debug.resolver, true})
           -- self.menu.Debug.label = group:label("~DISABLE RECODE [0.1]!")
            self.menu.Debug.label2 = group:label(" ")


            

			-- set item dependencies (visibility)=
			for tab, arr in pairs(self.menu) do
				if type(arr) == "table" and tab ~= "global" then
					Loop = function (arr, tab)
						for _, v in pairs(arr) do
							if type(v) == "table" then
								if v.__type == "pui::element" then
									v:depend({self.menu.global.tab, tab})
								else
									Loop(v, tab)
								end
							end
						end
					end

					Loop(arr, tab)
				end
			end
			
		end,

		shutdown = function(self)
			self.helpers:menu_visibility(true)
		end
	}


    :struct 'globals' {
        states = {"stand", "slow walk", "run", "duck", "duck move", "jump", "duck jump", "fakelag", "hideshots"},
        extended_states = {"global", "stand", "slow walk", "run", "duck", "duck move", "jump", "duck jump", "fakelag", "hideshots"},
        teams = {"t", "ct"},
        in_ladder = 0,
        nade = 0,
        resolver_data = {}
    }

    :struct 'ref' {
		aa = {
			enabled = {ui.reference("aa", "anti-aimbot angles", "enabled")},
			pitch = {ui.reference("aa", "anti-aimbot angles", "pitch")},
			yaw_base = {ui.reference("aa", "anti-aimbot angles", "Yaw base")},
			yaw = {ui.reference("aa", "anti-aimbot angles", "Yaw")},
			yaw_jitter = {ui.reference("aa", "anti-aimbot angles", "Yaw Jitter")},
			body_yaw = {ui.reference("aa", "anti-aimbot angles", "Body yaw")},
			freestanding_body_yaw = {ui.reference("aa", "anti-aimbot angles", "Freestanding body yaw")},
			freestand = {ui.reference("aa", "anti-aimbot angles", "Freestanding")},
			roll = {ui.reference("aa", "anti-aimbot angles", "Roll")},
			edge_yaw = {ui.reference("aa", "anti-aimbot angles", "Edge yaw")}
		},
		fakelag = {
			enable = {ui.reference("aa", "fake lag", "enabled")},
			amount = {ui.reference("aa", "fake lag", "amount")},
			variance = {ui.reference("aa", "fake lag", "variance")},
			limit = {ui.reference("aa", "fake lag", "limit")},
		},
		rage = {
			dt = {ui.reference("rage", "aimbot", "Double tap")},
			dt_limit = {ui.reference("rage", "aimbot", "Double tap fake lag limit")},
			fd = {ui.reference("rage", "other", "Duck peek assist")},
			os = {ui.reference("aa", "other", "On shot anti-aim")},
			silent = {ui.reference("rage", "Other", "Silent aim")},
			quickpeek = {ui.reference("RAGE", "Other", "Quick peek assist")},
			quickpeek2 = {ui.reference("RAGE", "Other", "Quick peek assist mode")},
			mindmg = {ui.reference('rage', 'aimbot', 'minimum damage')},
			ovr = {ui.reference('rage', 'aimbot', 'minimum damage override')}
		},
		slow_motion = {ui.reference("aa", "other", "Slow motion")},
	}

    :struct 'resolver' {
        state = {},
        counter = {},
        jitterhelper = function(self)

            local resolver = self.ui.menu.Debug.resolver:get()
            local resolver2 = self.ui.menu.Normal.resolver2:get()
            if resolver == "On" then
                if resolver2 == "On" then 
                    print("Disable Resolver [Recode] before AI!")
                end
                local players = entity.get_players(true)      
                if #players == 0 then
                    return
                end
              --  resolver_status = self.ui.menu.misc.resolver_flag()
                for _, i in next, players do

                    local target = i
                    if self.globals.resolver_data[target] == nil then
                        local data = self.helpers:fetch_data(target)
                        self.globals.resolver_data[target] = {
                            current = data,
                            last_valid_record = data
                        }
                    else
                        local simulation_time = self.helpers:time_to_ticks(entity.get_prop(target, "m_flSimulationTime"))
                        if simulation_time ~= self.globals.resolver_data[target].current.simulation_time then
                            table.insert(self.globals.resolver_data[target], 1, self.globals.resolver_data[target].current)
                            local data = self.helpers:fetch_data(target)
                            if simulation_time - self.globals.resolver_data[target].current.simulation_time >= 1 then
                                self.globals.resolver_data[target].last_valid_record = data
                            end
                            self.globals.resolver_data[target].current = data
                            for i = #self.globals.resolver_data[target], 1, -1 do
                                if #self.globals.resolver_data[target] > 16 then 
                                    table.remove(self.globals.resolver_data[target], i)
                                end
                            end
                        end
                    end

                    if self.globals.resolver_data[target][1] == nil or self.globals.resolver_data[target][2] == nil or self.globals.resolver_data[target][3] == nil or self.globals.resolver_data[target][6] == nil or self.globals.resolver_data[target][7] == nil then
                        return
                    end
                    
                    local yaw_delta = self.helpers:normalize(self.globals.resolver_data[target].current.eye_angles.y - self.globals.resolver_data[target][1].eye_angles.y)
                    local yaw_delta2 = self.helpers:normalize(self.globals.resolver_data[target][2].eye_angles.y - self.globals.resolver_data[target][3].eye_angles.y)
                    local yaw_delta3 = self.helpers:normalize(self.globals.resolver_data[target][6].eye_angles.y - self.globals.resolver_data[target][7].eye_angles.y)

                    if math.abs(yaw_delta) >= 33 then
                        self.globals.resolver_data[target].lastyawupdate = globals.tickcount() + 10
                        self.globals.resolver_data[target].side = yaw_delta
                    end

                    if self.globals.resolver_data[target].lastyawupdate == nil then self.globals.resolver_data[target].lastyawupdate = 0 end
                    if self.globals.resolver_data[target].lastplistupdate == nil then self.globals.resolver_data[target].lastplistupdate = 0 end
                    if self.globals.resolver_data[target].skitterupdate == nil then self.globals.resolver_data[target].skitterupdate = 0 end

                    if math.abs(yaw_delta2 - yaw_delta3) > 90 then
                        self.globals.resolver_data[target].skitterupdate = globals.tickcount() + 10
                    end
                    if self.globals.resolver_data[target].skitterupdate - globals.tickcount() > 0 then
                        self.state[target] = "SKITTER"
                      --  resolver_flag[target] = "SKITTER"
                        if math.abs(yaw_delta2 - yaw_delta3) == 0 then
                            plist.set(target, "Force body yaw value", 0)
                        else
                            plist.set(target, "Force body yaw value", (yaw_delta) > 0 and 60 or -60)
                        end
                    elseif self.globals.resolver_data[target].lastyawupdate > globals.tickcount() and yaw_delta == 0 and self.globals.resolver_data[target].skitterupdate - globals.tickcount() < 0 then
                        plist.set(target, "Force body yaw", true)
                        plist.set(target, "Force body yaw value", (self.globals.resolver_data[target].side) > 0 and 60 or -60)
                        self.globals.resolver_data[target].lastplistupdate = globals.tickcount() + 10
                        self.state[target] = "CENTER"
                      --  resolver_flag[target] = "JITTER"
                    elseif math.abs(yaw_delta) >= 33 then
                        plist.set(target, "Force body yaw", true)
                        plist.set(target, "Force body yaw value", (yaw_delta) > 0 and 60 or -60)
                        self.state[target] = "CENTER"
                      --  resolver_flag[target] = "JITTER"
                        self.globals.resolver_data[target].lastplistupdate = globals.tickcount() + 10
                    elseif self.globals.resolver_data[target].lastplistupdate < globals.tickcount() then
                        plist.set(target, "Force body yaw", false)
                        self.state[target] = ""
                      --  resolver_flag[target] = ""
                    else
                        plist.set(target, "Force body yaw", false)
                        self.state[target] = ""
                      --  resolver_flag[target] = ""
                    end

                end
            elseif resolver2 == "On" then
                if resolver == "On" then 
                    print("Disable AI Resolver before Recode!")
                end
                local players = entity.get_players(true)    
                if #players == 0 then
                    return
                end
                for _, i in next, players do

                    local target = i
                    if self.globals.resolver_data[target] == nil then
                        local data = self.helpers:fetch_data(target)
                        self.globals.resolver_data[target] = {
                            current = data,
                            last_valid_record = data
                        }
                    else
                        local simulation_time = self.helpers:time_to_ticks(entity.get_prop(target, "m_flSimulationTime"))
                        if simulation_time ~= self.globals.resolver_data[target].current.simulation_time then
                            table.insert(self.globals.resolver_data[target], 1, self.globals.resolver_data[target].current)
                            local data = self.helpers:fetch_data(target)
                            if simulation_time - self.globals.resolver_data[target].current.simulation_time >= 1 then
                                self.globals.resolver_data[target].last_valid_record = data
                            end
                            self.globals.resolver_data[target].current = data
                            for i = #self.globals.resolver_data[target], 1, -1 do
                                if #self.globals.resolver_data[target] > 16 then 
                                    table.remove(self.globals.resolver_data[target], i)
                                end
                            end
                        end
                    end

                    if self.globals.resolver_data[target][1] == nil or self.globals.resolver_data[target][2] == nil or self.globals.resolver_data[target][3] == nil or self.globals.resolver_data[target][6] == nil or self.globals.resolver_data[target][7] == nil then
                        return
                    end
                    
                    local yaw_delta = self.helpers:normalize(self.globals.resolver_data[target].current.eye_angles.y - self.globals.resolver_data[target][1].eye_angles.y)
                    local yaw_delta2 = self.helpers:normalize(self.globals.resolver_data[target][2].eye_angles.y - self.globals.resolver_data[target][3].eye_angles.y)
                    local yaw_delta3 = self.helpers:normalize(self.globals.resolver_data[target][6].eye_angles.y - self.globals.resolver_data[target][7].eye_angles.y)

                    if math.abs(yaw_delta) >= 33 then
                        self.globals.resolver_data[target].lastyawupdate = globals.tickcount() + 10
                        self.globals.resolver_data[target].side = yaw_delta
                    end
                    

                    if self.globals.resolver_data[target].lastyawupdate == nil then self.globals.resolver_data[target].lastyawupdate = 0 end
                    if self.globals.resolver_data[target].lastplistupdate == nil then self.globals.resolver_data[target].lastplistupdate = 0 end
                    if self.globals.resolver_data[target].skitterupdate == nil then self.globals.resolver_data[target].skitterupdate = 0 end

                    if math.abs(yaw_delta2 - yaw_delta3) > 90 then
                        self.globals.resolver_data[target].skitterupdate = globals.tickcount() + 10
                    end
                    if self.globals.resolver_data[target].skitterupdate - globals.tickcount() > 0 then
                        self.state[target] = "SKITTER"
                        if math.abs(yaw_delta2 - yaw_delta3) == 0 then
                            plist.set(target, "Force body yaw value", 0)
                        else
                            plist.set(target, "Force body yaw value", yaw_delta)
                        end
                    elseif self.globals.resolver_data[target].lastyawupdate > globals.tickcount() and yaw_delta == 0 and self.globals.resolver_data[target].skitterupdate - globals.tickcount() < 0 then
                        plist.set(target, "Force body yaw", true)
                       -- plist.set(target, "Force body yaw value", (self.globals.resolver_data[target].side) > 0 and 60 or -60)
                        plist.set(target, "Force body yaw value", (self.globals.resolver_data[target].side) > 0 and 60 or -60)
                        self.globals.resolver_data[target].lastplistupdate = globals.tickcount() + 10
                        self.state[target] = "CENTER"
                    elseif math.abs(yaw_delta) >= 33 then
                        plist.set(target, "Force body yaw", true)
                        plist.set(target, "Force body yaw value", yaw_delta)
                        self.state[target] = "CENTER"
                        self.globals.resolver_data[target].lastplistupdate = globals.tickcount() + 10
                    elseif self.globals.resolver_data[target].lastplistupdate < globals.tickcount() then
                        plist.set(target, "Force body yaw", false)
                        self.state[target] = ""
                    else
                        plist.set(target, "Force body yaw", false)
                        self.state[target] = ""

                    end
                end
            end

        end,
    }
    for _, eid in ipairs({
        {
            "net_update_start", function()
                ctx.resolver:jitterhelper()
            end
        },
        {
            "paint_ui", function()
                ctx.helpers:menu_visibility(false)
            end
        },
        {
            "load", function()
                ctx.ui:execute()
            end
        },
    }) do
        if eid[1] == "load" then
            eid[2]()
        else
            client.set_event_callback(eid[1], eid[2])
        end
    end

local lua = {}
lua.database = {
    configs = ":" .. lua_name .. "::configs:"
}
local presets = {}
-- @region USERDATA end

ffi.cdef [[
    typedef unsigned long dword;
    typedef unsigned int size_t;

    typedef struct {
        uint8_t r, g, b, a;
    } color_t;

    struct c_animstate { 
        char pad[ 3 ];
        char m_bForceWeaponUpdate; //0x4
        char pad1[ 91 ];
        void* m_pBaseEntity; //0x60
        void* m_pActiveWeapon; //0x64
        void* m_pLastActiveWeapon; //0x68
        float m_flPrevCycle; //0x001C
        float m_flWeight; //0x0020
        float m_flWeightDeltaRate; //0x0024
        float m_flPlaybackRate; //0x0028
        float m_flLastClientSideAnimationUpdateTime; //0x6C
        int m_iLastClientSideAnimationUpdateFramecount; //0x70
        float m_flAnimUpdateDelta; //0x74
        float m_flEyeYaw; //0x78
        float m_flPitch; //0x7C
        float m_flGoalFeetYaw; //0x80
        float m_flCurrentFeetYaw; //0x84   
        float m_flCurrentTorsoYaw; //0x88
        float m_flUnknownVelocityLean; //0x8C
        float m_flLeanAmount; //0x90
        char pad2[ 4 ];
        float m_flFeetCycle; //0x98
        float m_flFeetYawRate; //0x9C
        char pad3[ 4 ];
        float m_fDuckAmount; //0xA4
        float m_fLandingDuckAdditiveSomething; //0xA8
        char pad4[ 4 ];
        float m_vOriginX; //0xB0
        float m_vOriginY; //0xB4
        float m_vOriginZ; //0xB8
        float m_vLastOriginX; //0xBC
        float m_vLastOriginY; //0xC0
        float m_vLastOriginZ; //0xC4
        float m_vVelocityX; //0xC8
        float m_vVelocityY; //0xCC
        char pad5[ 4 ];
        float m_flUnknownFloat1; //0xD4
        char pad6[ 8 ];
        float m_flUnknownFloat2; //0xE0
        float m_flUnknownFloat3; //0xE4
        float m_flUnknown; //0xE8
        float m_flSpeed2D; //0xEC
        float m_flUpVelocity; //0xF0
        float m_flSpeedNormalized; //0xF4
        float m_flFeetSpeedForwardsOrSideWays; //0xF8
        float m_flFeetSpeedUnknownForwardOrSideways; //0xFC
        float m_flTimeSinceStartedMoving; //0x100
        float m_flTimeSinceStoppedMoving; //0x104
        bool m_bOnGround; //0x108
        bool m_bInHitGroundAnimation; //0x109
        float m_flTimeSinceInAir; //0x10A
        float m_flLastOriginZ; //0x10E
        float m_flHeadHeightOrOffsetFromHittingGroundAnimation; //0x112
        float m_flStopToFullRunningFraction; //0x116
        char pad7[ 4 ]; //0x11A
        float m_flMagicFraction; //0x11E
        char pad8[ 60 ]; //0x122
        float m_flWorldForce; //0x15E
        char pad9[ 462 ]; //0x162
        float m_flMaxYaw; //0x334
    };
]]

local classptr = ffi.typeof('void***')
local rawientitylist = client.create_interface('client.dll', 'VClientEntityList003') or
                           error('VClientEntityList003 wasnt found', 2)

local ientitylist = ffi.cast(classptr, rawientitylist) or error('rawientitylist is nil', 2)
local get_client_networkable = ffi.cast('void*(__thiscall*)(void*, int)', ientitylist[0][0]) or
                                   error('get_client_networkable_t is nil', 2)
local get_client_entity = ffi.cast('void*(__thiscall*)(void*, int)', ientitylist[0][3]) or
                              error('get_client_entity is nil', 2)

local rawivmodelinfo = client.create_interface('engine.dll', 'VModelInfoClient004')
local ivmodelinfo = ffi.cast(classptr, rawivmodelinfo) or error('rawivmodelinfo is nil', 2)
local get_studio_model = ffi.cast('void*(__thiscall*)(void*, const void*)', ivmodelinfo[0][32])

local seq_activity_sig = client.find_signature('client.dll', '\x55\x8B\xEC\x53\x8B\x5D\x08\x56\x8B\xF1\x83')

to_draw = "no"
to_up = "no"
to_draw_ticks = 0

function defensive_indicator()

    local diff_mmeme = var_table.sim_diff()

    if diff_mmeme <= -1 then
        to_draw = "yes"
        to_up = "yes"
    end
end 

local function GetAnimationState(player)
    if not (player) then
        return
    end
    local player_ptr = ffi.cast("void***", get_client_entity(ientitylist, player))
    local animstate_ptr = ffi.cast("char*", player_ptr) + 0x9960
    local state = ffi.cast("struct c_animstate**", animstate_ptr)[0]

    return state
end

local solus_render = LPH_NO_VIRTUALIZE(function()
    local solus_m = {}

    local Box = function(x, y, w, h, r, g, b, a, radius)
        renderer.rectangle(x, y + radius, w, h - radius, r, g, b, a) -- down
        renderer.rectangle(x + radius, y, w - radius * 2, radius, r, g, b, a) -- up

        renderer.circle(x + radius, y + radius, r, g, b, a, radius, 180, 0.25) --<
        renderer.circle(x + w - radius, y + radius, r, g, b, a, radius, 90, 0.25) -->
    end

    local n = 70

    local OutlineBox = function(x, y, w, h, r, g, b, a, radius)
        local n = a / 255 * n
        renderer.rectangle(x, y + h - 1, w, 1, r, g, b, a) -- down
        renderer.rectangle(x + radius, y, w - radius * 2 + 1, 1, r, g, b, n) -- up

        renderer.gradient(x, y + radius, 1, h - radius, r, g, b, n, r, g, b, a, false) --<
        renderer.gradient(x + w, y + radius, 1, h - radius, r, g, b, n, r, g, b, a, false) -->
        renderer.gradient(x, y + h - 1, w + 1, 6, r, g, b, n, r, g, b, 0, false) -- down

        renderer.circle_outline(x + radius, y + radius, r, g, b, n, radius, 180, 0.25, 1) --<
        renderer.circle_outline(x + w - radius + 1, y + radius, r, g, b, n, radius, 270, 0.25, 1) --> 
  end

    solus_m.container = function(x, y, w, h, r, g, b, a, radius, aa)
        if aa > 20 and radius < 6 then
            renderer.blur(x, y, w, h)
        end

        Box(x, y, w, h, 17, 17, 17, a, radius)
        OutlineBox(x, y, w, h, r, g, b, aa, radius)
    end

    return solus_m
end)()

-- @region REFERENCES start
local refs = {
    legit = ui.reference("LEGIT", "Aimbot", "Enabled"),
    dmgOverride = {ui.reference("RAGE", "Aimbot", "Minimum damage override")},
    fakeDuck = ui.reference("RAGE", "Other", "Duck peek assist"),
    minDmg = ui.reference("RAGE", "Aimbot", "Minimum damage"),
    hitChance = ui.reference("RAGE", "Aimbot", "Minimum hit chance"),
    safePoint = ui.reference("RAGE", "Aimbot", "Force safe point"),
    forceBaim = ui.reference("RAGE", "Aimbot", "Force body aim"),
    dtLimit = ui.reference("RAGE", "Aimbot", "Double tap fake lag limit"),
    quickPeek = {ui.reference("RAGE", "Other", "Quick peek assist")},
    dt = {ui.reference("RAGE", "Aimbot", "Double tap")},
    enabled = ui.reference("AA", "Anti-aimbot angles", "Enabled"),
    pitch = {ui.reference("AA", "Anti-aimbot angles", "pitch")},
    roll = ui.reference("AA", "Anti-aimbot angles", "roll"),
    yawBase = ui.reference("AA", "Anti-aimbot angles", "Yaw base"),
    yaw = {ui.reference("AA", "Anti-aimbot angles", "Yaw")},
    flLimit = ui.reference("AA", "Fake lag", "Limit"),
    fsBodyYaw = ui.reference("AA", "anti-aimbot angles", "Freestanding body yaw"),
    edgeYaw = ui.reference("AA", "Anti-aimbot angles", "Edge yaw"),
    yawJitter = {ui.reference("AA", "Anti-aimbot angles", "Yaw jitter")},
    bodyYaw = {ui.reference("AA", "Anti-aimbot angles", "Body yaw")},
    freeStand = {ui.reference("AA", "Anti-aimbot angles", "Freestanding")},
    os = {ui.reference("AA", "Other", "On shot anti-aim")},
    slow = {ui.reference("AA", "Other", "Slow motion")},
    fakeLag = {ui.reference("AA", "Fake lag", "Limit")},
    legMovement = ui.reference("AA", "Other", "Leg movement"),
    indicators = {ui.reference("VISUALS", "Other ESP", "Feature indicators")},
    ping = {ui.reference("MISC", "Miscellaneous", "Ping spike")},
}
local vars = {
    localPlayer = 0,
    hitgroup_names = { 'Generic', 'Head', 'Chest', 'Stomach', 'Left arm', 'Right arm', 'Left leg', 'Right leg', 'Neck', '?', 'Gear' },
    aaStates = {"Global", "Stand", "Move", "Slowwalk", "Crouch", "Aero", "Aero + Crouch", "Legit-AA"},
    pStates = {"G", "S", "M", "SW", "C", "A", "AC", "LA"},
	sToInt = {["Global"] = 1, ["Stand"] = 2, ["Move"] = 3, ["Slowwalk"] = 4, ["Crouch"] = 5, ["Aero"] = 6, ["Aero + Crouch"] = 7,["Legit-AA"] = 8},
    intToS = {[1] = "Global", [2] = "Stand", [3] = "Move", [4] = "Slowwalk", [5] = "Crouch", [6] = "Aero", [7] = "Aero+C", [8] = "Legit"},
    currentTab = 1,
    activeState = 1,
    pState = 1,
    should_disable = false,
    defensive_until = 0,
    defensive_prev_sim = 0,
    fs = false,
    choke1 = 0,
    choke2 = 0,
    choke3 = 0,
    choke4 = 0,
    switch = false,
}


local kill = {

	'ｉ ｈｓ ｓｉｎｃｅ ｍｙ ｍｏｔｈｅｒ ｂｏｒｎｅｄ ｍｅ',
	'i live and laugh knowing u die.',
	'my spotlight is bigger then united states of 𝒦𝒪𝒮𝒪𝒱𝒪 𝑅𝐸𝒫𝒰𝐵𝐿𝐼𝒞',
	'I AM LEGEND TO MY FAMILY',
	'tommorow lighton will suffer his last blow after gsense ban',
	'𝗲𝗻𝗷𝗼𝘆 𝗱𝗶𝗲 𝘁𝗼 𝗚 𝗟𝗢𝗦𝗦 𝗟𝗨𝗔',
	'𝕥𝕙𝕚𝕤 𝕠𝕟𝕖 𝕚𝕤 𝕗𝕠𝕣 𝕞𝕪 𝕄𝕌𝕄𝕄ℤ𝕐 𝕖𝕟𝕛𝕠𝕪 𝕕𝕚𝕖',
	'𝓽𝓱𝓲𝓼 𝔀𝓮𝓪𝓴 𝓭𝓸𝓰 "VAX" 𝓌𝒶𝓈 𝒹𝑒𝓅𝑜𝓇𝓉𝑒𝒹 𝓉𝑜 ""𝒦𝐿𝒜𝒟𝒪𝒱𝒪""',
	'after killing "ReDD" 𝕚 𝕘𝕠𝕥 𝕡𝕣𝕖𝕤𝕚𝕕𝕖𝕟𝕥 𝕠𝕗 𝕒𝕔𝕖𝕥𝕠𝕝',
	'by funny color player',
    'you think you are 𝔰𝔦𝔤𝔪𝔞 𝔭𝔯𝔢𝔡𝔦𝔠𝔱𝔦𝔬𝔫 but no.',
    'neverlose will always use as long father esotartliko has my back.',
    'after winning 1vALL i went on vacation to 𝒢𝒜𝐵𝐸𝒩 𝐻𝒪𝒰𝒮𝐸',
    'i superior resolver(selling shoppy.gg/@KURAC))',
    'ＹＯＵ ＨＡＤ ＦＵＮ ＬＡＵＧＨＩＮＧ ＵＮＴＩＬ ＮＯＷ',
    'once this game started 𝔂𝓸𝓾 𝓵𝓸𝓼𝓮𝓭 𝓪𝓵𝓻𝓮𝓭𝔂',
    'WOMANBOSS VS 𝙀𝙑𝙀𝙍𝙔𝙊𝙉𝙀(𝙌𝙏𝙍𝙐𝙀,𝙍𝙊𝙊𝙏,𝙍𝘼𝙕𝙊,𝙍𝙀𝘿𝘿,𝙍𝙓𝙕𝙀𝙔,𝘽𝙀𝘼𝙕𝙏,𝙎𝙄𝙂𝙈𝘼,𝙂𝙍𝙄𝙈𝙕𝙒𝘼𝙍𝙀)',
	'𝕖𝕤𝕠𝕥𝕒𝕣𝕥𝕝𝕚𝕜 𝔸𝕃 ℙ𝕌𝕋𝕆 𝕊𝕌𝔼𝕃𝕆!',
	'𝘨𝘢𝘮𝘦𝘴𝘯𝘴𝘦 𝘪𝘴 𝘥𝘪𝘦 𝘵𝘰 𝘶.',
	'𝙨𝙬𝙖𝙢𝙥𝙢𝙤𝙣𝙨𝙩𝙚𝙧 𝙤𝙛 𝙢𝙚 𝙞𝙨 𝙘𝙤𝙢𝙚 𝙤𝙪𝙩',
	'weak gay femboy "cho" is depression after lose https://gamesense.pub/forums/viewtopic.php?id=35658',
	'after ban from galaxy i go on all servers to 𝓂𝒶𝓀𝑒 𝑒𝓋𝑒𝓇𝓎𝑜𝓃𝑒 𝓅𝒶𝓎 𝒻𝑜𝓇 𝒷𝒶𝓃 𝑜𝒻 𝓂𝑒',
	'𝚠𝚎𝚊𝚔 𝚍𝚘𝚐(𝚖𝚋𝚢 𝚋𝚕𝚊𝚌𝚔) 𝚐𝚘 𝚑𝚎𝚕𝚕 𝚊𝚏𝚝𝚎𝚛 𝚔𝚒𝚕𝚕',
	'𝔻𝕠𝕟’𝕥 𝕡𝕝𝕒𝕪 𝕓𝕒𝕟𝕜 𝕧𝕤 𝕞𝕖, 𝕚𝕞 𝕝𝕚𝕧𝕖 𝕥𝕙𝕖𝕣𝕖.',
	'𝙙𝙖𝙮 666 𝙃𝙑𝙃𝙔𝘼𝙒 𝙨𝙩𝙞𝙡𝙡 𝙣𝙤 𝙧𝙞𝙫𝙖𝙡𝙨',
	'𝕌 ℂ𝔸ℕ 𝔹𝕌𝕐 𝔸 ℕ𝔼𝕎 𝔸ℂℂ𝕆𝕌ℕ𝕋 𝔹𝕌𝕋 𝕌 ℂ𝔸ℕ𝕋 𝔹𝕌𝕐 𝔸 𝕎𝕀ℕ',
	'my config better than your',
	'1 STFU NN WHO.RU $$$ UFF YA UID?',
	'𝕣𝕖𝕤𝕠𝕝𝕧𝕖𝕣 𝕁ℤ 𝕤𝕠𝕠𝕟.',
	'𝕀 𝔸𝕄 𝕃𝔸𝕍𝔸 𝕐𝕆𝕌 𝔸ℝ𝔼 𝔽ℝ𝕆𝔾',
	'game vs you is free win',
	'𝙖𝙛𝙩𝙚𝙧 𝙠𝙞𝙡𝙡𝙞𝙣𝙜 𝙜𝙧𝙞𝙢𝙯𝙬𝙖𝙧𝙚 𝙞 𝙘𝙡𝙖𝙞𝙢𝙚𝙙 𝙢𝙮 𝙥𝙡𝙖𝙘𝙚 𝙖𝙨 𝙋𝙍𝙀𝙕𝙄𝘿𝙀𝙉𝙏 𝙊𝙁 𝘾𝙍𝙊𝘼𝙏𝙄𝘼',
	'𝘴𝘩𝘰𝘱𝘱𝘺.𝘨𝘨/@𝘢𝘧𝘳𝘪𝘤𝘬𝘢𝘴𝘭𝘫𝘪𝘷𝘢 𝘵𝘰 𝘪𝘯𝘤𝘳𝘦𝘢𝘴𝘦 𝘩𝘷𝘩 𝘱𝘰𝘵𝘦𝘯𝘵𝘪𝘢𝘭',
	'𝔦 𝔰𝔱𝔬𝔭 𝔲 𝔴𝔦𝔱𝔥 𝔱𝔥𝔦𝔰 ℌ$',
	'𝔲 𝔫𝔢𝔢𝔡 𝔱𝔯𝔞𝔫𝔰𝔩𝔞𝔱𝔬𝔯 𝔱𝔬 𝔥𝔦𝔱 𝔪𝔶 𝔞𝔫𝔱𝔦 𝔞𝔦𝔪𝔟𝔬𝔱',
	'𝒻𝒶𝓃𝒸𝒾𝑒𝓈𝓉 𝒽𝓋𝒽 𝓇𝑒𝓈𝑜𝓁𝓋𝑒𝓇 𝒾𝓃 𝒾𝓃𝒹𝓊𝓈𝓉𝓇𝓎 𝑜𝒻 𝓋𝒾𝓉𝓂𝒶',
	'𝕒𝕗𝕥𝕖𝕣 𝕝𝕖𝕒𝕧𝕚𝕟𝕘 𝕣𝕠𝕞𝕒𝕟𝕚𝕒 𝕚 𝕓𝕖𝕔𝟘𝕞𝕖 = 𝕝𝕖𝕘𝕖𝕟𝕕𝕒',
	'gσ∂ вℓєѕѕ υηιтє∂ ѕтαтєѕ σƒ яσмαηι & ѕєявια',
	'ur lua cracked like egg',
	'i am america after doing u like japan in HVH',
	'winning not possibility, sry.',
	'after this ＨＥＡＤＳＨＯＲＴ i become sigma',
	'𝕘𝕠𝕕 𝕘𝕒𝕧𝕖 𝕞𝕖 𝕡𝕠𝕨𝕖𝕣 𝕠𝕗 𝕣𝕖𝕫𝕠𝕝𝕧𝕖𝕣 𝕁𝔸𝕍𝔸𝕊ℂℝ𝕀ℙ𝕋𝔸',
	'ｉ ａｍ ａｍｂａｓｓａｄｏｒ ｏｆ ｇｓｅｎｓｅ',
	'𝓼𝓴𝓮𝓮𝓽 𝓬𝓻𝓪𝓬𝓴 𝓷𝓸 𝔀𝓸𝓻𝓴 𝓪𝓷𝔂𝓶𝓸𝓻𝓮 𝔀𝓱𝓪𝓽 𝓾 𝓾𝓼𝓮 𝓷𝓸𝔀',
	'𝕡𝕠𝕠𝕣 𝕕𝟘𝕘 𝕊ℙ𝔸𝔻𝔼𝔻 𝕟𝕖𝕖𝕕 𝟚𝟘$ 𝕥𝕠 𝕓𝕦𝕪 𝕟𝕖𝕨 𝕒𝕚𝕣 𝕞𝕒𝕥𝕥𝕣𝕖𝕤𝕤.',
	'i am KING go slave for me',
	'Don"t cry, say ᶠᵘᶜᵏ ʸᵒᵘ and smile.',
	'My request for 150 ETH was not filled in. It passed almost 48 hours, I gave them 72...',
    '𝒶𝒻𝓉𝑒𝓇 𝒷𝒶𝓃 𝒻𝓇𝑜𝓂 𝓈𝓀𝑒𝑒𝓉(𝑔𝓈𝑒𝓃𝓈𝑒) 𝒾 𝒷𝒶𝓃 𝓎𝑜𝓊 𝒻𝓇𝑜𝓂 𝒽𝑒𝒶𝓋𝑒𝓃.𝓁𝓊𝒶',
    '𝘨𝘰𝘥 𝘣𝘭𝘦𝘴𝘴𝘦𝘥 𝘨𝘢𝘮𝘦𝘴𝘦𝘯𝘴𝘦 𝘢𝘯𝘥 𝘳𝘦𝘨𝘦𝘭𝘦 𝘰𝘧 𝘸𝘰𝘳𝘭𝘥(𝘮𝘦)',
   	'𝕒𝕗𝕥𝕖𝕣 𝕣𝕖𝕔𝕚𝕖𝕧𝕖 𝕤𝕜𝕖𝕖𝕥𝕓𝕖𝕥𝕒 𝕚 +𝕨 𝕚𝕟𝕥𝕠 𝕪𝕠𝕦',
    'ｅｖｅｎ ｓｉｇｍａ ｃａｎｔ ｔｏｕｃｈ ｍｙ ａｎｔｉ ｒｅｓｏｌｖｅｒ',
    '𝓊 𝑔𝑜 𝓈𝓁𝑒𝑒𝓅 𝓁𝒾𝓀𝑒 𝓎𝑜𝓊𝓇 *𝒟𝐸𝒜𝒟* 𝓂𝑜𝓉𝒽𝑒𝓇𝓈',
   	'𝒾 𝓀𝒾𝓁𝓁𝑒𝒹 𝓊 𝒻𝓇𝑜𝓂 𝓂𝑜𝑜𝓃',
   	'𝕖𝕝𝕖𝕡𝕙𝕒𝕟𝕥 𝕝𝕠𝕠𝕜 𝕒𝕝𝕚𝕜𝕖 "𝕎𝕀𝕊ℍ" 𝕕𝕚𝕖𝕕 𝕥𝕠 𝕞𝕖 𝕤𝕠 𝕨𝕚𝕝𝕝 𝕪𝕠𝕦',
    'ᵍᵒᵒᵈ ᵈᵃʸ ᵗᵒ ʰˢ ⁿᵒⁿᵃᵐᵉˢ.',
    '𝙖𝙛𝙩𝙚𝙧 𝙘𝙖𝙧𝙙𝙞𝙣𝙜 𝙛𝙤𝙤𝙙 𝙛𝙤𝙧 𝙭𝙖𝙉𝙚 𝙞 𝙧𝙚𝙘𝙞𝙚𝙫𝙚𝙙 𝙨𝙠𝙚𝙚𝙩𝙗𝙚𝙩𝙖',
	'𝔫𝔢𝔳𝔢𝔯 𝔱𝔥𝔦𝔫𝔨 𝔶𝔬𝔲𝔯 𝔠𝔬𝔦𝔫𝔟𝔞𝔰𝔢 𝔦𝔰 𝔰𝔞𝔣𝔢',
	'𝓲 𝔀𝓲𝓵𝓵 𝓼𝓲𝓶𝓼𝔀𝓪𝓹 𝔂𝓸𝓾𝓻 𝓯𝓪𝓶𝓲𝓵𝔂',
	'𝕗𝕣𝕖𝕖 𝕙𝕧𝕙 𝕝𝕖𝕤𝕤𝕠𝕟𝕤 𝕪𝕠𝕦𝕥𝕦𝕓𝕖.𝕔𝕠𝕞/𝕊𝕖𝕣𝕓𝕚𝕒𝕟𝔾𝕒𝕞𝕖𝕤𝔹𝕃',
	'(っ◔◡◔)っ ♥ enjoy this H$ and spectate me ♥',
	'𝕚 𝕒𝕞 𝕜𝕝𝕒𝕕𝕠𝕧𝕠 𝕡𝕖𝕖𝕜 (◣_◢)',
	'𝓎𝑜𝓊𝓇 𝒹𝑜𝓍 𝒾𝓈 𝒶𝓁𝓇𝑒𝒶𝒹𝓎 𝓅𝑜𝓈𝓉𝑒𝒹.',
    '𝔦 𝔥$ 𝔞𝔫𝔡 𝔰𝔪𝔦𝔩𝔢',
	'ｙｏｕ ｃｒｙ？',
	'𝙞 𝙚𝙣𝙩𝙚𝙧𝙚𝙙 𝙧𝙪𝙧𝙪𝙧𝙪 𝙨𝙩𝙖𝙩𝙚 𝙤𝙛 𝙢𝙞𝙣𝙙',
    '𝓇𝑒𝓏𝑜𝓁𝓋𝑒𝓇 𝑜𝓃 𝓎𝑜𝓊 = 𝐹𝒪𝑅𝒞𝐸 𝐻$',
	'𝔸𝔽𝕋𝔼ℝ 𝔼𝕊ℂ𝔸ℙ𝕀ℕ𝔾 𝕊𝔼ℂ𝕌ℝ𝕀𝕋𝕐 𝕀 𝕎𝔼ℕ𝕋 𝕆ℕ 𝕂𝕀𝕃𝕃𝕀ℕ𝔾 𝕊ℙℝ𝔼𝔸𝕂 𝕌ℝ 𝕀ℕ 𝕀𝕋',
	'𝘪 𝘩𝘴 𝘺𝘰𝘶. 𝘦𝘷𝘦𝘳𝘺𝘵𝘪𝘮𝘦 𝘫𝘶𝘴𝘵 𝘩𝘴. 𝘣𝘶𝘺 𝘮𝘺 𝘬𝘧𝘨.',
	'cu@gsense/spotlight section of forum by MOGYORO',
	'u die while i talk with prezident of 𝙰𝙵𝙶𝙷𝙰𝙽𝙸𝚂𝚃𝙰𝙽𝙸 making $$$',
	'my coinbase is thicker then the hs i gave u',
	'olympics every 4 years next chance to kill me is in 100',
	'stop talk u *DEAD*',
	'𝒩𝐸𝒱𝐸𝑅 𝒯𝐻𝐼𝒩𝒦 𝒴𝒪𝒰 "yerebko"',
	'𝕟𝕠 𝕤𝕜𝕚𝕝𝕝 𝕟𝕖𝕖𝕕 𝕥𝕠 𝕜𝕚𝕝𝕝 𝕪𝕠𝕦',
	'𝕥𝕙𝕚𝕤 𝕓𝕠𝕥𝕟𝕖𝕥 𝕨𝕚𝕝𝕝 𝕖𝕟𝕕 𝕦 𝕙𝕒𝕣𝕕𝕖𝕣 𝕥𝕙𝕖𝕟 𝕞𝕪 𝕓𝕦𝕝𝕝𝕖𝕥',
	'𝘸𝘰𝘮𝘢𝘯𝘣𝘰$$ 𝘰𝘸𝘯𝘪𝘯𝘨 𝘲𝘶𝘢𝘥𝘳𝘶𝘱𝘭𝘦𝘵 𝘪𝘯𝘥𝘪𝘢𝘯𝘴 𝘢𝘯𝘥 𝘨𝘺𝘱𝘴𝘪𝘴 𝘴𝘪𝘯𝘤𝘦 2001',
	'𝘺𝘰𝘶 𝘫𝘶𝘴𝘵 𝘨𝘰𝘵 𝘵𝘢𝘱𝘱𝘦𝘥 𝘣𝘺 𝘢 𝘴𝘶𝘱𝘦𝘳𝘪𝘰𝘳 𝘱𝘭𝘢𝘺𝘦𝘳, 𝘨𝘰 𝘤𝘰𝘮𝘮𝘪𝘵 𝘩𝘰𝘮𝘪𝘤𝘪𝘥𝘦',
	'𝕪𝕠𝕦 𝕒𝕦𝕥𝕠𝕨𝕒𝕝𝕝 𝕞𝕖 𝕠𝕟𝕔𝕖 , 𝕚 𝕒𝕦𝕥𝕠𝕨𝕒𝕝𝕝 𝕪𝕠𝕦 𝕥𝕨𝕚𝕔𝕖 (◣_◢) ',
	'𝓫𝔂 𝔀𝓸𝓶𝓪𝓷𝓫𝓸𝓼𝓼 𝓻𝓮𝓼𝓸𝓵𝓿𝓮𝓻 $',
	'𝘸𝘰𝘳𝘴𝘩𝘪𝘱 𝘵𝘩𝘦 𝘨𝘰𝘥𝘴, 𝘸𝘰𝘳𝘴𝘩𝘪𝘱 𝘮𝘦',
	'1',
	'𝟙,𝟚,𝟛 𝕚𝕟𝕥𝕠 𝕥𝕙𝕖 𝟜, 𝕨𝕠𝕞𝕒𝕟 𝕞𝕗𝕚𝕟𝕘 𝕓𝕠𝕤𝕤 𝕨𝕚𝕥𝕙 𝕥𝕙𝕖 𝕔𝕙𝕣𝕠𝕞𝕖 𝕥𝕠 𝕪𝕒 𝕕𝕠𝕞𝕖',
	'𝔧𝔢𝔴𝔦𝔰𝔥 𝔱𝔢𝔯𝔪𝔦𝔫𝔞𝔱𝔬𝔯',
	'𝕐𝕠𝕦 𝕜𝕚𝕝𝕝 𝕞𝕖 𝕀 𝕖𝕩𝕥𝕠𝕣𝕥 𝕪𝕠𝕦 𝕗𝕠𝕣 𝟙𝟝𝟘 𝕖𝕥𝕙',
	'𝘢𝘭𝘸𝘢𝘺𝘴 𝘩𝘴, 𝘯𝘦𝘷𝘦𝘳 𝘣𝘢𝘮𝘦.',
	'𝘒𝘪𝘉𝘪𝘛 𝘷𝘚 𝘰𝘊𝘪𝘖 (𝘨𝘖𝘖𝘥𝘌𝘭𝘌𝘴𝘴 𝘥0𝘨) 𝘰𝘞𝘯𝘌𝘥 𝘐𝘯 3𝘹3',
	'𝕪𝕠𝕦𝕣 𝕒𝕟𝕥𝕚𝕒𝕚𝕞 𝕤𝕠𝕝𝕧𝕖𝕕 𝕝𝕚𝕜𝕖 𝕒𝕝𝕘𝕖𝕓𝕣𝕒 𝕖𝕢𝕦𝕒𝕥𝕚𝕠𝕟',
	'ｗｅａｋ ｂｏｔ ｍａｌｖａ ａｌｗａｙｓ ｄｏｇ',
	'𝙥𝙧𝙞𝙫𝙖𝙩𝙚 𝙞𝙙𝙚𝙖𝙡 𝙩𝙞𝙘𝙠 𝙩𝙚𝙘𝙝𝙣𝙤𝙡𝙤𝙜𝙞𝙚𝙨 ◣_◢',
	'𝕓𝕖𝕤𝕥 𝕤𝕖𝕣𝕓𝕚𝕒𝕟 𝕝𝕠𝕘 𝕞𝕖𝕥𝕙𝕠𝕕𝕤 𝕥𝕒𝕡 𝕚𝕟',
	'UHQ DoorDash logs tap in!',
	'cheap mcdonald giftcard method ◣_◢ selly.gg/mcsauce',
	'womanboss>all',
	'𝕨𝕙𝕒𝕥 𝕚𝕤 𝕒 𝕘𝕚𝕣𝕝 𝕥𝕠 𝕒 𝕨𝕠𝕞𝕒𝕟?',
	'drain balls for superior womanboss.technology invite',
	'𝚒𝚏 𝚢𝚘𝚞 𝚠𝚊𝚗t 𝚜𝚎𝚎 𝚖𝚢 𝚌𝚊𝚝 𝚢𝚘𝚞  𝚔𝚒𝚕𝚕 𝚖𝚎',
	'ミ💖 𝔫ᎥĞĞєⓡ 𝔫ᎥĞĞєⓡ 𝔫ᎥĞĞєⓡ 𝔫ᎥĞĞєⓡ 𝔫ᎥĞĞєⓡ 𝔫ᎥĞĞєⓡ 💖彡',
	'▄︻デ 𝔦 𝔱𝔲𝔯𝔫 𝔶𝔬𝔲 𝔴𝔞𝔱𝔢𝔯 𝔲𝔫𝔡𝔢𝔯 𝔟𝔯𝔦𝔡𝔤𝔢 ══━一',
	'died to a womän',
	'get fucked in the ass by serb gods, u can freely commit genocide just like eren yeager did $$$ kukubra simulator inreallif',
	'weak dog attend quandale dingle academic',
	'24 btc`d',
	'天安门广场抗议 黑人使我不舒服 I LOVE VALORATN 天安门广场抗议 黑人使我不舒服 Glory to China long live Xi Jinping',
	'𝟩 𝐼𝓃𝓉𝓇𝑒𝓈𝓉𝒾𝓃𝑔 𝐹𝒶𝒸𝓉𝓈 𝒶𝒷𝑜𝓊𝓉 𝒞𝑜𝓈𝓉𝒶 𝑅𝒾𝒸𝒶',
	'Black nigga balls HD',
	'when round is end i kill ghost.',
	'i swim entire mediterranean sea and atlantic ocean to 1 weak NA dogs',
	'🅆🄷🅈 🄳🄾 🅈🄾🅄 🅂🄾 🅂🄷🄸🅃.',
	'sowwy >_<',
	'Approved feminist  ◣_◢',
	'ХАХАХАХАХХАХА НИЩИЙ УЛЕТЕЛ (◣_◢)',
	'so i recive KILLSEY BOOST SYSTEM and now it"S dead all',
	'𝑴𝒚 𝒈𝒊𝒓𝒍𝒇𝒓𝒊𝒆𝒏𝒅𝒔 𝒂𝒏𝒅 𝑰 𝒋𝒖𝒔𝒕 𝒘𝒂𝒏𝒕𝒆𝒅 𝒕𝒐 𝒉𝒂𝒗𝒆 𝒂 𝒈𝒊𝒓𝒍𝒔 𝒏𝒊𝒈𝒉𝒕 𝒐𝒖𝒕 𝒃𝒖𝒕 𝒊𝒕 𝒕𝒖𝒓𝒏𝒆𝒅 𝒊𝒏𝒕𝒐 𝒎𝒆 𝒈𝒆𝒕𝒕𝒊𝒏𝒈 FREE HELL TIKET',
	'𝕀𝕋 𝕎𝔸𝕊 𝔸 𝕄𝕀𝕊𝕋𝔸𝕂𝔼 𝕋𝕆 𝔹𝔸ℕ ℙ𝔼𝕋ℝ𝔼ℕ𝕂𝕆 𝕋ℍ𝔼 ℂ𝔸𝕋 𝔽ℝ𝕆𝕄 𝔹ℝ𝔸ℤ𝕀𝕃 ℕ𝕆𝕎 𝔼𝕊𝕆𝕋𝕀𝕃𝔸ℝℂ𝕆 𝕊ℍ𝔸𝕃𝕃 ℙ𝔸𝕐',
	'𝘾𝙤𝙞𝙣𝙗𝙖𝙨𝙚: 𝘾𝙤𝙣𝙛𝙞𝙧𝙢 𝙩𝙧𝙖𝙣𝙨𝙛𝙚𝙧 𝙧𝙚𝙦𝙪𝙚𝙨𝙩. 𝘾𝙤𝙞𝙣𝙗𝙖𝙨𝙚: 𝙔𝙤𝙪 𝙨𝙚𝙣𝙩 10.244 𝙀𝙏𝙃 𝙩𝙤 𝙬𝙤𝙢𝙖𝙣𝙗𝙤𝙨𝙨.𝙚𝙩𝙝',
	'ᴊᴀʀᴠɪs: ɴɴ ᴅᴏɢ ᴛᴀᴘᴘᴇᴅ sɪʀ',
	'𝙜𝙖𝙢𝙚𝙨𝙚𝙣𝙨𝙚.𝙥𝙪𝙗 𝙚𝙧𝙧𝙤𝙧 404 𝙙𝙪𝙚 𝙩𝙤  𝕔𝕝𝕠𝕦𝕕𝕗𝕝𝕒𝕣𝕖 𝕓𝕪𝕡𝕒𝕤𝕤𝕖𝕤 ◣_◢',
	'game-sense is a reaaly good against nevelooss and some other',
	'the server shivers when the when 𝐰𝐨𝐦𝐚𝐧𝐛𝐨𝐬𝐬 𝐭𝐞𝐚𝐦 connect..',
	'𝕟𝕠 𝕞𝕒𝕥𝕔𝕙 𝕗𝕠𝕣 𝕜𝕦𝕣𝕒𝕔 𝕣𝕖𝕤𝕠𝕝𝕧𝕖𝕣',
	'𝕋𝕙𝕚𝕤 𝕕𝕠𝕘 𝕤𝕠𝕗𝕚 𝕥𝕙𝕚𝕟𝕜 𝕙𝕖 𝕙𝕒𝕤 𝕓𝕖𝕤𝕥 𝕙𝕒𝕔𝕜 𝕓𝕦𝕥 𝕙𝕖 𝕙𝕒𝕤𝕟”𝕥 𝕓𝕖𝕖𝕟 𝕥𝕠 𝕞𝕒𝕝𝕕𝕚𝕧𝕖𝕤 𝕌𝕊𝔸 𝕖𝕤𝕠𝕥𝕒𝕝𝕜𝕚𝕜',
	'𝕚𝕞 𝕒𝕝𝕨𝕒𝕪𝕤 𝟙𝕧𝕤𝟛𝟠 𝕤𝕥𝕒𝕔𝕜 𝕘𝕠𝕠𝕕𝕝𝕖𝕤𝕤 𝕓𝕦𝕥 𝕥𝕙𝕖𝕪 𝕚𝕥𝕤 𝕟𝕠𝕥 𝕨𝕚𝕟 𝕧𝕤 𝕄𝔼',
	'𝕚𝕞 +𝕨 𝕚𝕟𝕥𝕠 𝕪𝕠𝕦 𝕨𝕙𝕖𝕟 𝕚 𝕨𝕒𝕤 𝕣𝕖𝕔𝕚𝕧𝕖𝕕 𝕞𝕖𝕤𝕤𝕒𝕘𝕖 𝕗𝕣𝕠𝕞 𝕖𝕤𝕠𝕥𝕒𝕝𝕚𝕜',
	'𝕘𝕠𝕕 𝕟𝕚𝕘𝕙𝕥 - 𝕗𝕣𝕠𝕞 𝕥𝕙𝕖 𝕘𝕒𝕞𝕖𝕤𝕖𝕟𝕫.𝕦𝕫𝕓𝕖𝕜𝕚𝕤𝕥𝕒𝕟',
	'𝘶𝘯𝘧𝘰𝘳𝘵𝘶𝘯𝘢𝘵𝘦 𝘮𝘦𝘮𝘣𝘦𝘳 𝘬𝘯𝘦𝘦 𝘢𝘨𝘢𝘪𝘯𝘴𝘵 𝘸𝘰𝘮𝘢𝘯𝘣𝘰𝘴𝘴',
	'𝕒𝕝𝕨𝕒𝕪𝕤 𝕕𝕠𝕟𝕥 𝕘𝕠 𝕗𝕠𝕣 𝕙𝕖𝕒𝕕 𝕒𝕚𝕞 𝕠𝕟𝕝𝕪 𝕚𝕕𝕖𝕒𝕝 𝕥𝕚𝕜 𝕥𝕖𝕔𝕟𝕠𝕝𝕠𝕛𝕚𝕤 ◣_◢',
	'+𝕨 𝕨𝕚𝕥𝕙 𝕚𝕞𝕡𝕝𝕖𝕞𝕖𝕟𝕥 𝕠𝕗 𝕘𝕒𝕞𝕖𝕤𝕖𝕟𝕤.𝕤𝕖𝕣𝕓𝕚𝕒',
	'𝕦𝕟𝕗𝕠𝕣𝕥𝕦𝕟𝕒𝕥𝕪𝕝𝕪 𝕪𝕠𝕦 𝕚𝕥𝕤 𝕣𝕖𝕔𝕚𝕧𝕖 𝔽𝕣𝕖𝕖 𝕙𝕖𝕝𝕝 𝕖𝕩𝕡𝕖𝕕𝕚𝕥𝕚𝕠𝕟',
	'𝚗𝚘 𝚋𝚊𝚖𝚎𝚜 𝚠𝚒𝚝𝚑 𝚞𝚜𝚎 𝚘𝚏 𝚔𝚞𝚛𝚊𝚌 𝚛𝚎𝚣𝚘𝚕𝚟𝚎𝚛 𝚝𝚎𝚌𝚑𝚗𝚘𝚕𝚘𝚓𝚒𝚎𝚜',
	'ℕ𝕖𝕨 𝕗𝕣𝕖𝕖 +𝕨 𝕥𝕣𝕚𝕔𝕜 𝕔𝕠𝕞𝕚𝕟𝕘 𝕤𝕠𝕠𝕟 𝕚𝕟 𝕤𝕖𝕣𝕓𝕚𝕒 𝕦𝕡𝕕𝕒𝕥𝕖 𝕠𝕗 𝕥𝕙𝕖 𝕘𝕒𝕞𝕖 𝕤𝕖𝕟𝕤𝕖𝕣𝕚𝕟𝕘',
	'𝕒𝕝𝕨𝕒𝕪𝕤 𝕚 𝕘𝕠 𝟙𝕧𝟛𝟞 𝕧𝕤 𝕦𝕟𝕗𝕠𝕣𝕥𝕦𝕟𝕒𝕥𝕖 𝕞𝕖𝕞𝕓𝕖𝕣𝕤… 𝕒𝕝𝕨𝕒𝕪𝕤 𝕚 𝕒𝕞 𝕧𝕚𝕔𝕥𝕠𝕣𝕪  ◣_◢',
	'(っ◔◡◔)っ ♥ fnay”ed ♥',
	'𝕚 𝕒𝕞 𝕚𝕥”𝕤 𝕕𝕠𝕟𝕥 𝕝𝕠𝕤𝕖  ◣_◢',
	'𝕣𝕠𝕞𝕒𝕟𝕪 𝕓𝕖𝕘 𝕞𝕖 𝕗𝕠𝕣 𝕜𝕗𝕘 𝕓𝕦𝕥 𝕚𝕞 𝕤𝕒𝕪 𝟝 𝕡𝕖𝕤𝕠𝕤',
	'𝕚𝕞 𝕔𝕒𝕟 𝕙𝕒𝕔𝕜 𝕗𝕟𝕒𝕪 𝕒𝕟𝕕 𝕡𝕣𝕖𝕕𝕚𝕔𝕥𝕚𝕠𝕟 𝕒𝕝𝕝 𝕟𝕖𝕩𝕥 𝕣𝕠𝕦𝕟𝕕..',
	'𝕡𝕣𝕖𝕞𝕚𝕦𝕞 𝕗𝕚𝕧𝕖 𝕟𝕚𝕘𝕙𝕥𝕤 𝕒𝕥 𝕗𝕣𝕖𝕕𝕕𝕪𝕤 𝕙𝕒𝕔𝕜𝕤 @𝕤𝕙𝕠𝕡𝕡𝕪.𝕘𝕘/𝕥𝕦𝕣𝕜𝕝𝕚𝕗𝕖𝕤𝕥𝕪𝕝𝕖',
	'𝕀𝔾𝔸𝕄𝔼𝕊𝔼ℕ𝕊𝔼 𝔸ℕ𝕋𝕀-𝔸𝕀𝕄 ℍ𝔼𝔸𝔻𝕊ℍ𝕆𝕋 ℙℝ𝔼𝔻𝕀ℂ𝕋+',
	'𝟙𝔸ℕ𝕋𝕀-ℕ𝔼𝕎-𝕋𝔼ℂℍℕ𝕆𝕃𝕆𝔾𝕐 𝕀𝕊 ℙℝ𝔼𝕊𝔼ℕ𝕋𝔼𝔻!',
	'!𝔹𝕐 𝕄𝕌𝕊𝕋𝔸𝔹𝔸ℝ𝔹𝔸𝔸ℝ𝕀𝟙𝟛𝟛𝟟𝟙-',
	'!𝔽ℝ𝔼𝔼 𝕃𝕌𝔸 𝕋𝕆𝕄𝕆ℝℝ𝕆𝕎!',
	'𝕆𝕎ℕ𝔼𝔻 𝔸𝕃𝕃!',
	'развертывать freddy fazbear',
	'𝕓𝕦𝕘𝕤 𝕔𝕒𝕞𝕖 𝕗𝕣𝕠𝕞 𝕤𝕚𝕘𝕞𝕒’𝕤 𝕟𝕠𝕤𝕖 𝕒𝕟𝕕 𝕙𝕚𝕤 𝕖𝕪𝕖𝕤 𝕥𝕦𝕣𝕟𝕖𝕕 𝕓𝕝𝕒𝕔𝕜 ◣_◢',
	'𝕤𝕠 𝕒 𝕨𝕖𝕒𝕜 𝕗𝕣𝕖𝕕𝕕𝕪 𝕗𝕒𝕫𝕓𝕖𝕒𝕣 𝕋𝕋 𝕤𝕠 𝕚 𝕤𝕡𝕖𝕟𝕕 𝟙𝟘 𝕟𝕚𝕘𝕙𝕥”𝕤 𝕨𝕚𝕥𝕙 𝕙𝕚𝕞 𝕞𝕠𝕥𝕙𝕖𝕣',
	'𝕤𝕡𝕖𝕔𝕚𝕒𝕝 𝕞𝕖𝕤𝕤𝕒𝕘𝕖 𝕥𝕠 𝕝𝕚𝕘𝕙𝕥𝕠𝕟 𝕙𝕧𝕙 𝕨𝕖 𝕨𝕚𝕝𝕝 𝕔𝕠𝕞𝕖 𝕥𝕠 𝕦𝕣 𝕙𝕠𝕦𝕤𝕖 𝕒𝕘𝕒𝕚𝕟 𝕒𝕟𝕕 𝕥𝕙𝕚𝕤 𝕥𝕚𝕞𝕖 𝕚𝕥 𝕨𝕚𝕝𝕝 𝕟𝕠𝕥 𝕓𝕖 𝕡𝕖𝕒𝕔𝕖𝕗𝕦𝕝 ◣_◢',
	'𝐞𝐩𝐢𝐜𝐟𝐨𝐧𝐭𝐬.𝐬𝐞𝐫𝐛𝐢𝐚 𝐩𝐫𝐞𝐦𝐢𝐮𝐢𝐦 𝐮𝐬𝐞𝐫',
	'𝕒𝕔𝕔𝕠𝕣𝕕𝕚𝕟𝕘 𝕥𝕠 𝕪𝕠𝕦𝕥𝕦𝕓𝕖 𝕒𝕟𝕒𝕝𝕚𝕥𝕚𝕔𝕤, 𝟟𝟘% 𝕒𝕣𝕖 𝕟𝕠𝕥 𝕤𝕦𝕓𝕤𝕔𝕣𝕚𝕓𝕖𝕤... ◣_◢',
	'FATALITY.WIN Finish Him and Everyone',
	'𝖘𝖔 𝖙𝖍𝖊𝖞 𝖗𝖊𝖆𝖑𝖑𝖞 𝖙𝖍𝖔𝖚𝖌𝖍𝖙 𝖙𝖍𝖊𝖞 𝖈𝖆𝖓 𝖘𝖍𝖔𝖈𝖐 𝖙𝖍𝖊 𝖐𝖎𝖓𝖌, 𝖘𝖔 𝖎 𝖘𝖍𝖔𝖈𝖐𝖊𝖉 𝖙𝖍𝖊𝖎𝖗 𝖎𝖓𝖋𝖆𝖓𝖙 𝖈𝖍𝖎𝖑𝖉𝖘',
	'ℍ𝕖𝕣𝕠𝕓𝕣𝕚𝕟𝕖 𝕞𝕚𝕘𝕙𝕥 𝕓𝕖 𝕔𝕙𝕖𝕒𝕥𝕚𝕟𝕘 𝕚𝕟 ℂ𝕊:𝔾𝕆...',
	'ɪ ᴄᴀʟʟ ᴀʟʟᴀʜ ᴛᴏ ᴘᴀʀᴛ ꜱᴇᴠᴇɴ ꜱᴇᴀꜱ ᴡʜᴇɴ ɪ ᴛʀᴀᴠᴇʟ ᴛᴏ ᴋɪʟʟ ᴡᴇᴀᴋ ɴᴀ ʀᴀᴛꜱ ◣_◢',
	'𝓼𝓸 𝓲 𝓶𝓲𝓰𝓱𝓽 𝓫𝓮 𝓼𝓮𝓵𝓵𝓲𝓷𝓰 𝓷𝓮𝓿𝓮𝓻𝓵𝓸𝓼𝓮 𝓲𝓷𝓿𝓲𝓽𝓪𝓽𝓲𝓸𝓷...',
	'ＴＨＥＲＥ ＩＳ ＮＯ  ＷＡＹ ＴＨＡＴＳ ＬＥＧＩＴ．．．ಠ_ಠ',
	'𝕊𝕠 𝕀 𝕗𝕚𝕟𝕒𝕝𝕝𝕪 𝕙𝕒𝕕 𝕤𝕖𝕩 𝕚𝕟 ℍ𝕦𝕟𝕚𝕖ℙ𝕠𝕡...',
	'𝐚𝐟𝐭𝐞𝐫 𝐟𝐢𝐯𝐞 𝐧𝐢𝐠𝐡𝐭𝐬 𝐟𝐫𝐞𝐝𝐝𝐲 𝐟𝐚𝐳𝐛𝐞𝐚𝐫 𝐠𝐚𝐯𝐞 𝐭𝐡𝐞𝐬𝐞 𝐭𝐞𝐜𝐡𝐧𝐨𝐥𝐨𝐠𝐢𝐜𝐚𝐥  ◣_◢',
	'𝖘𝖔 𝖙𝖍𝖎𝖘 𝖜𝖊𝖆𝖐 𝖗𝖆𝖙 𝖇𝖆𝖓𝖓𝖊𝖉 𝖒𝖎𝖓𝖊 𝖋𝖗𝖎𝖊𝖓𝖉 (𝖓𝖔𝖘𝖙𝖆𝖑𝖌𝖎𝖆) 𝖓𝖔𝖜 𝖎 𝖆𝖗𝖊 𝖚𝖘𝖊𝖉 𝖔𝖋 𝖆𝖓𝖙𝖎-𝖕𝖗𝖎𝖒𝖔𝖗𝖉𝖎𝖆𝖑 𝖙𝖊𝖈𝖍𝖓𝖔𝖑𝖔𝖌𝖎𝖈𝖆𝖑 ◣_◢',
	'𝐒𝐨 𝐈 𝐜𝐚𝐥𝐥𝐞𝐝 𝐭𝐡𝐞 𝐖𝐎𝐌𝐀𝐍𝐁𝐎𝐒𝐒 𝐚𝐭 𝟒𝐚𝐦... 𝐢𝐭 𝐰𝐚𝐬 𝐩𝐫𝐞𝐭𝐭𝐲 𝐬𝐜𝐚𝐫𝐲',
	'𝗞𝗜𝗭𝗔𝗥𝗨 𝗪𝗔𝗡𝗧𝗦 𝗪𝗢𝗠𝗔𝗡𝗕𝗢𝗦𝗦𝗘𝗦 𝗧𝗢 𝗝𝗢𝗜𝗡 𝗚𝗢𝗗𝗘𝗟𝗘𝗦𝗦?! (𝗴𝗼𝗶𝗻𝗴 𝗽𝗿𝗼)',
	'UNDERAGE? CALL ME',
	'ＦＯＯＬ ＭＥ ＯＮＣＥ， ＳＨＡＭＥ ＯＮ ＹＯＵ， ＦＯＯＬ ＭＥ ＴＷＩＣＥ， Ｉ ＴＲＯＬＬ ＹＯＵ．',
	'go buy Nixware for the best hacker facing hacker gone wrong experience.',
	'UFF SilenZIO$$$ U have Ben 1TAPED by PORTUGAL Technology',
	'you"re are poor go bay beter turkish cheat (onetap su) ',
	'Romanian Technology I steal real model and REZOLVE.',
	'ᴡᴀʀɴɪɴɢ: ɢᴏɪɴɢ ᴛᴏ ꜱʟᴇᴇᴘ ᴏɴ ꜱᴜɴᴅᴀʏ ᴡɪʟʟ ᴄᴀᴜꜱᴇ ᴍᴏɴᴅᴀʏ',
	'BICH...dont test gangster in me',
	'ᴡᴀɴɴᴀʙᴇ ᴀᴡᴘ ɢᴏᴅ ᴍᴀx(?) ᴄᴀᴍᴇ ᴛᴏ ꜰᴀᴄᴇ ʀᴇᴀʟ ᴀᴡᴘ ɢᴏᴅ ʀᴀᴢᴏ',
	'𝔾𝔻𝔼 𝕍𝔸𝕄 𝕁𝔼 𝕊𝕌ℕ ℙℝ𝕆𝕋𝔼𝕂𝕊𝕆ℕ?',
	'scrabble bot owned by wordle king',
	'𝕀 ℂ𝔸𝕄𝔼 𝔹𝔸ℂ𝕂 𝕋𝕆 ℝ𝕆𝕄𝔸ℕ𝕀𝔸 𝕋𝕆 𝕄𝕌ℝ𝔻𝔼ℝ 𝕋ℍ𝕀𝕊 𝔻𝕆𝔾 ℂ𝔸𝕃𝕃𝔼𝔻 "ℕ𝕌𝔹𝔹𝔼ℝ𝕊" 𝔸ℕ𝔻 ℍ𝕀𝕊 𝔼𝔹𝔽 "𝕗𝕦𝕤𝕚𝕠𝕟"',
	'ɪ ᴄᴀᴍᴇ ᴛᴏ 10ꜰᴘꜱ ᴛᴏ ᴅᴇꜱᴛʀᴏʏ ɴᴏꜱᴛᴀʟɢɪᴀ"ꜱ ᴅᴏɢɢᴏꜱ',
	'𝕀 𝕔𝕒𝕞𝕖 𝔹𝔸ℂ𝕂 𝕥𝕠 ℝ𝕆 𝕊𝕖𝕣𝕧𝕖𝕣 𝕥𝕠 𝕕𝕖𝕤𝕥𝕣𝕠𝕪 𝔹ℝ𝔸ℕ𝔻𝕆ℕ 𝔸ℕ𝔻 𝕃𝔸𝕌ℝ 𝔼ℂ𝕆𝕌ℙ𝕃𝔼',
	'ᴵ ᶜᵒᵐᵉ ᵇᵃᶜᵏ ᶠʳᵒᵐ ᴮʳᵃˢⁱˡ ᶠᵒʳ ᵖˡᵃʸ ᴴⱽᴴ ᵃⁿᵈ ᵈᵉˢᵗʳᵒʸ ᵈᵒᵍˢ',
	'ROLL VS ME? I KILL YOUR MOTHER FATHER SISTER BROTHER BUTCHER THEM AND ROLL ON THEIR GRAVE',
	'brutality,onlybaim,godeless,nuk3s,maverick it dont matter... all will dye to womanboss',
	'ɪ ʙᴇᴄᴀᴍᴇ ᴘʀɪᴍᴇ ᴍɪɴɪꜱᴛᴇʀ ᴏꜰ ᴄʀᴏᴀᴛɪᴀ ᴛᴏ ꜰʀᴇᴇ ᴍʏ ʙʀᴏᴛʜᴇʀ ɢʀɪᴍᴢ',
	'GIGACHAD FEMALE DETECTED, GAME DODGED GIGACHAD FEMALE DETECTED, GAME DODGED GIGACHAD FEMALE DETECTED, GAME DODGED GIGACHAD FEMALE DETECTED, GAME DODGED',
	'it ain"t gonna suck itself',
	'𝕀 𝕃𝕆𝕍𝔼 $C𝔸R𝔻𝕀N𝔾$ 𝕋H𝕀𝕊 𝕀𝕊 𝕄𝕐 𝕃𝕀𝔽𝔼$𝕋𝕃𝕐𝔼',
	'dont play roll vs me,im miss there',
	'no rare fish no talk',
	'god may forgive you but gamesense resolver won"t (◣_◢)',
	'You Just Got Tapped! #fyp #foryou #viral #fy',
	'𝔻ỖℕŦ 𝕄𝒶Ќ𝑒 𝓶𝓔 şｈㄖω 𝕋Ｈє 𝐦𝕠ⓃＳ𝐓乇𝓻 𝐢𝕟sι𝒹𝔼, เ 𝕊ţ𝐨𝓹 ʷ𝒆𝔞к яᗩ𝐭𝐒 ŴⒾtʰ ❶ʘ１ 𝔪Įᑎ ∂Μ𝕘 ☆',
	'𝕟𝟘 𝕔𝕦𝕣𝕒𝕛 𝕗𝕠𝕣 𝕡𝕝𝔸𝕪 𝕕𝕖_𝕟𝕦𝕜𝕖 𝕧𝕤 𝕄𝔼.. .... 𝕥𝕙𝕒𝕥 𝕚𝕤 𝕞𝕖 𝕙𝕠𝕦𝕤𝕖',
	'ｈａ－ｈａ－ｈａ ｙｏｕ＇ｒｅ ａｒｅ ｐｏｏｒ',
	'𝕟𝟘𝕤𝕥𝕒𝕝𝕘𝕚𝕒 𝕔𝕠𝕞𝕖 𝕓𝕒𝕔𝕜 𝕨𝕚𝕥𝕙 𝕞𝕚𝕝𝕜 𝕓𝕦𝕥 𝕞𝕖 𝕕𝕖𝕔𝕝𝕚𝕟𝕖 𝕠𝕗𝕗𝕖𝕣..',
	'ｗｏｍａｎｂｏｓｓ ｉｓ ｍａｎ？！ ｏｈ ｍｅ ｇｏｄ．．',
	'𝕓𝕒𝕫𝕚𝕔𝕒𝕝𝕝𝕪 𝕞𝕖 𝕚𝕟𝕛𝕖𝕔𝕥𝕖𝕕 𝕘𝕒𝕞𝕖-𝕤𝕖𝕟𝕤 𝕨𝕚𝕥𝕙𝕠𝕦𝕥 𝕍𝔸ℂ 𝔹𝕐ℙ𝔸𝕊𝕊... 𝕞𝕖 𝕘𝕠𝕥 𝕧𝕒𝕔𝕖𝕕 𝕟𝕖𝕩𝕥 𝕥𝕠𝕞𝕠𝕣𝕣𝕠𝕨',
	'𝙒𝙝𝙚𝙣 𝙄"𝙢 𝙥𝙡𝙖𝙮 𝙈𝙈 𝙄"𝙢 𝙥𝙡𝙖𝙮 𝙛𝙤𝙧 𝙬𝙞𝙣, 𝙙𝙤𝙣"𝙩 𝙨𝙘𝙖𝙧𝙚 𝙛𝙤𝙧 𝙨𝙥𝙞𝙣, 𝙞 𝙞𝙣𝙟𝙚𝙘𝙩 𝙧𝙖𝙜𝙚 ♕',
	'ℙ𝕖𝕣𝕤𝕠𝕟𝕒𝕝𝕝𝕪, 𝕞𝕖 𝕨𝕠𝕦𝕝𝕕 𝕤𝕒𝕪 𝕥𝕙𝕚𝕤 𝕔𝕙𝕖𝕒𝕥 𝕒𝕣𝕖 𝕓𝕖𝕥𝕥𝕖𝕣 𝕥𝕙𝕖𝕟 𝕆𝕋ℂ𝕍𝟛, 𝕆𝕊𝕀ℝ𝕀𝕊, ℙ𝕖𝕟𝕚𝕤ℍ𝕌𝔻, 𝕒𝕟𝕕 𝕊𝕆𝕄𝔼 𝕆𝕋ℍ𝔼ℝ.',
	'it"s morbin" time',
	'𝗜𝗜 𝗗𝗔𝗨 𝗠𝗨𝗜𝗘 𝗟𝗨𝗜 𝗢𝗩𝗜𝗗𝗜𝗨',
	'it"s just a game" is such a weak mindset',
	'Keep calm and tap on.',
	'2 lines a day keeps the doctor away',
	'They ain"t believe in us, GOD DID',
	'don"t problem',
	'Headshots speak louder than words',
	'Every tap is a step closer to glory',
	'once you tap you can"t stop',
	'When the tap success, victory follows suit',
	'𝕪𝕠𝕦 𝕥𝕙𝕚𝕟𝕜 𝕚𝕥𝕤 𝕨𝕚𝕟𝕟𝕚𝕟𝕘𝕤 𝕓𝕦𝕥 𝕒𝕨𝕒𝕝𝕝 𝕔𝕠𝕞𝕖 𝕗𝕚𝕣𝕤𝕥',
	'Turning cheats into defeat, one headshot at a time',
	'The way of wins is dont losing',
	'ℕ𝕖𝕧𝕖𝕣 𝕥𝕙𝕚𝕟𝕜 𝕪𝕠𝕦 𝕨𝕠𝕟 𝕓𝕖𝕔𝕒𝕦𝕤𝕖 𝕪𝕠𝕦 𝕤𝕙𝕠𝕥 𝕗𝕚𝕣𝕤𝕥, 𝕠𝕟𝕤𝕙𝕠𝕥 𝕔𝕠𝕞𝕖𝕤 𝕟𝕖𝕩𝕥.',
	'Baiming win rounds, headshots win hearts',
	'𝚝𝚑𝚎 𝚝𝚊𝚙𝚏𝚎𝚜𝚝 𝚑𝚊𝚜 𝚓𝚞𝚜𝚝 𝚋𝚎𝚐𝚞𝚗, 𝚋𝚎 𝚙𝚛𝚎𝚙𝚊𝚛𝚎𝚍',
	'What is happened on cs2 is remain on cs2 (◣_◢)',
	'𝐒𝐨𝐮𝐟𝐢𝐰 𝐲𝐨𝐮 𝐚𝐫𝐞 𝐚 𝐰𝐞𝐚𝐤 𝐝𝐨𝐠 𝐚𝐧𝐝 𝐲𝐨𝐮𝐫 𝐟𝐫𝐢𝐞𝐧𝐝𝐬 𝐰𝐢𝐥𝐥 𝐛𝐞 𝐤𝐢𝐥𝐥𝐞𝐝',
	'𝕓𝕪 𝕤𝕚𝕘𝕟𝕚𝕟𝕘 𝕒 𝕔𝕠𝕟𝕥𝕒𝕔𝕥 𝕨𝕚𝕥𝕙 𝕥𝕙𝕖 𝕕𝕖𝕧𝕚𝕝 𝕪𝕠𝕦 𝕒𝕣𝕖 𝕕𝕠𝕠𝕞𝕖𝕕 𝕥𝕠 𝕕𝕚𝕖',
	'ɪ ʙᴇᴄᴀᴍᴇ ᴛʜᴇ ᴘʀᴇsɪᴅᴇɴᴛ ᴏꜰ ᴛʜᴇ ʀᴜssɪᴀɴ ꜰᴇᴅᴇʀᴀᴛɪᴏɴᴀɴᴅ sɪɢɴᴇᴅ ᴀɴ ᴀɢʀᴇᴇᴍᴇɴᴛ ᴛʜᴀᴛ ᴘᴇᴏᴘʟᴇ ᴄᴀɴ ʙᴇ sʜᴏᴛ ᴅᴏᴡɴ',
	'𝐢 𝐤𝐢𝐥𝐥𝐞𝐝 𝐭𝐡𝐞𝐦 𝐚𝐧𝐝 𝐝𝐨 𝐧𝐨𝐭 𝐫𝐞𝐠𝐫𝐞𝐭 𝐢𝐭',
	'𝔸𝕝𝕝 𝕕𝕠𝕘𝕤 𝕦𝕤𝕖𝕣𝕤 𝟙𝕧𝟛𝟞 𝕨𝕖𝕟𝕥 𝕒𝕘𝕒𝕚𝕟𝕤𝕥 𝕞𝕖 𝕒𝕟𝕕 𝕚 𝕙𝕒𝕕 𝕥𝕠 𝕜𝕚𝕝𝕝 𝕖𝕧𝕖𝕣𝕪𝕠𝕟𝕖 𝕒𝕟𝕕 𝕥𝕙𝕖𝕚𝕣 𝕝𝕠𝕧𝕖𝕕 𝕠𝕟𝕖𝕤',
	'ｗｅａｋ ｄｏｇｓ ａｇａｉｎｓｔ ｔｈｅ ＫＩＮＧ ｉｔ ｃａｍｅ ｔｏ ｍｅ ｔｏ ｅｘｅｃｕｔｅ ｅｖｅｒｙｏｎｅ ｔｈｅｙ ｃｒｉｅｄ ｌｉｋｅ ｇｉｒｌｓ ＨＡＨＡＨ',
	'𝕍𝕝𝕒𝕕𝕚𝕞𝕚𝕣 ℙ𝕦𝕥𝕚𝕟 𝕒𝕨𝕒𝕣𝕕𝕖𝕕 𝕞𝕖 𝕨𝕚𝕥𝕙 𝕥𝕙𝕖 𝕒𝕨𝕒𝕣𝕕 𝕀 𝕒𝕞 𝕟𝕠𝕨 𝕚𝕞𝕡𝕖𝕣𝕒𝕥𝕠𝕣',
	'Ｉ ＷＩＬＬ ＫＩＬＬ ＡＬＬ ＮＥＶＥＲＬＯＳＥ ＵＳＥＲＳ １ ＢＹ １',
	'ᴀʟʟ ɴᴇᴠᴇʀʟᴏꜱᴇ ᴜꜱᴇʀꜱ ᴄʀʏ ᴡʜᴇɴ ɢᴀᴍᴇꜱᴇɴꜱᴇ ɢᴇᴛꜱ ᴜᴘᴅᴀᴛᴇᴅ',
	'𝔸𝕃𝕃 ℂℝ𝔸ℂ𝕂 𝕌𝕊𝔼ℝ𝕊 𝕎𝕀𝕊ℍ 𝔽𝕆ℝ 𝕋ℍ𝔼 ℝ𝔼𝔸𝕃 𝕋ℍ𝕀ℕ𝔾',
	'ＹＯＵ ＷＩＳＨ ＹＯＵ ＨＡＤ ＧＡＭＥＳＥＮＳＥ Ｕ ＨＲＳＮ',
	'₲₳₥Ɇ₴Ɇ₦₴Ɇ 1 ₦ɆVɆⱤ₩ł₦ 0',

}

local js = panorama.open()
local MyPersonaAPI, LobbyAPI, PartyListAPI, SteamOverlayAPI = js.MyPersonaAPI, js.LobbyAPI, js.PartyListAPI, js.SteamOverlayAPI
-- @region VARIABLES end

-- @region FUNCS start
local func = {
    fclamp = function(x, min, max)
        return math.max(min, math.min(x, max));
    end,
    frgba = function(hex)
        hex = hex:gsub("#", "");
    
        local r = tonumber(hex:sub(1, 2), 16);
        local g = tonumber(hex:sub(3, 4), 16);
        local b = tonumber(hex:sub(5, 6), 16);
        local a = tonumber(hex:sub(7, 8), 16) or 255;
    
        return r, g, b, a;
    end,
    render_text = function(x, y, ...)
        local x_Offset = 0
        
        local args = {...}
    
        for i, line in pairs(args) do
            local r, g, b, a, text = unpack(line)
            local size = vector(renderer.measure_text("-d", text))
            renderer.text(x + x_Offset, y, r, g, b, a, "-d", 0, text)
            x_Offset = x_Offset + size.x
        end
    end,
    easeInOut = function(t)
        return (t > 0.5) and 4*((t-1)^3)+1 or 4*t^3;
    end,
    rec = function(x, y, w, h, radius, color)
        radius = math.min(x/2, y/2, radius)
        local r, g, b, a = unpack(color)
        renderer.rectangle(x, y + radius, w, h - radius*2, r, g, b, a)
        renderer.rectangle(x + radius, y, w - radius*2, radius, r, g, b, a)
        renderer.rectangle(x + radius, y + h - radius, w - radius*2, radius, r, g, b, a)
        renderer.circle(x + radius, y + radius, r, g, b, a, radius, 180, 0.25)
        renderer.circle(x - radius + w, y + radius, r, g, b, a, radius, 90, 0.25)
        renderer.circle(x - radius + w, y - radius + h, r, g, b, a, radius, 0, 0.25)
        renderer.circle(x + radius, y - radius + h, r, g, b, a, radius, -90, 0.25)
    end,
    rec_outline = function(x, y, w, h, radius, thickness, color)
        radius = math.min(w/2, h/2, radius)
        local r, g, b, a = unpack(color)
        if radius == 1 then
            renderer.rectangle(x, y, w, thickness, r, g, b, a)
            renderer.rectangle(x, y + h - thickness, w , thickness, r, g, b, a)
        else
            renderer.rectangle(x + radius, y, w - radius*2, thickness, r, g, b, a)
            renderer.rectangle(x + radius, y + h - thickness, w - radius*2, thickness, r, g, b, a)
            renderer.rectangle(x, y + radius, thickness, h - radius*2, r, g, b, a)
            renderer.rectangle(x + w - thickness, y + radius, thickness, h - radius*2, r, g, b, a)
            renderer.circle_outline(x + radius, y + radius, r, g, b, a, radius, 180, 0.25, thickness)
            renderer.circle_outline(x + radius, y + h - radius, r, g, b, a, radius, 90, 0.25, thickness)
            renderer.circle_outline(x + w - radius, y + radius, r, g, b, a, radius, -90, 0.25, thickness)
            renderer.circle_outline(x + w - radius, y + h - radius, r, g, b, a, radius, 0, 0.25, thickness)
        end
    end,
    clamp = function(x, min, max)
        return x < min and min or x > max and max or x
    end,
    includes = function(tbl, value)
        for i = 1, #tbl do
            if tbl[i] == value then
                return true
            end
        end
        return false
    end,
    setAATab = function(ref)
        ui.set_visible(refs.enabled, ref)
        ui.set_visible(refs.pitch[1], ref)
        ui.set_visible(refs.pitch[2], ref)
        ui.set_visible(refs.roll, ref)
        ui.set_visible(refs.yawBase, ref)
        ui.set_visible(refs.yaw[1], ref)
        ui.set_visible(refs.yaw[2], ref)
        ui.set_visible(refs.yawJitter[1], ref)
        ui.set_visible(refs.yawJitter[2], ref)
        ui.set_visible(refs.bodyYaw[1], ref)
        ui.set_visible(refs.bodyYaw[2], ref)
        ui.set_visible(refs.freeStand[1], ref)
        ui.set_visible(refs.freeStand[2], ref)
        ui.set_visible(refs.fsBodyYaw, ref)
        ui.set_visible(refs.edgeYaw, ref)
    end,
    findDist = function (x1, y1, z1, x2, y2, z2)
        return math.sqrt((x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2)
    end,
    resetAATab = function()
        ui.set(refs.enabled, false)
        ui.set(refs.pitch[1], "Off")
        ui.set(refs.pitch[2], 0)
        ui.set(refs.roll, 0)
        ui.set(refs.yawBase, "local view")
        ui.set(refs.yaw[1], "Off")
        ui.set(refs.yaw[2], 0)
        ui.set(refs.yawJitter[1], "Off")
        ui.set(refs.yawJitter[2], 0)
        ui.set(refs.bodyYaw[1], "Off")
        ui.set(refs.bodyYaw[2], 0)
        ui.set(refs.freeStand[1], false)
        ui.set(refs.freeStand[2], "On hotkey")
        ui.set(refs.fsBodyYaw, false)
        ui.set(refs.edgeYaw, false)
    end,
    type_from_string = function(input)
        if type(input) ~= "string" then return input end

        local value = input:lower()

        if value == "true" then
            return true
        elseif value == "false" then
            return false
        elseif tonumber(value) ~= nil then
            return tonumber(value)
        else
            return tostring(input)
        end
    end,
    lerp = function(start, vend, time)
        return start + (vend - start) * time
    end,
    vec_angles = function(angle_x, angle_y)
        local sy = math.sin(math.rad(angle_y))
        local cy = math.cos(math.rad(angle_y))
        local sp = math.sin(math.rad(angle_x))
        local cp = math.cos(math.rad(angle_x))
        return cp * cy, cp * sy, -sp
    end,
    hex = function(arg)
        local result = "\a"
        for key, value in next, arg do
            local output = ""
            while value > 0 do
                local index = math.fmod(value, 16) + 1
                value = math.floor(value / 16)
                output = string.sub("0123456789ABCDEF", index, index) .. output 
            end
            if #output == 0 then 
                output = "00" 
            elseif #output == 1 then 
                output = "0" .. output 
            end 
            result = result .. output
        end 
        return result .. "FF"
    end,
    split = function( inputstr, sep)
        if sep == nil then
                sep = "%s"
        end
        local t={}
        for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
                table.insert(t, str)
        end
        return t
    end,
    RGBAtoHEX = function(redArg, greenArg, blueArg, alphaArg)
        return string.format('%.2x%.2x%.2x%.2x', redArg, greenArg, blueArg, alphaArg)
    end,
    create_color_array = function(r, g, b, string)
        local colors = {}
        for i = 0, #string do
            local color = {r, g, b, 255 * math.abs(1 * math.cos(2 * math.pi * globals.curtime() / 4 + i * 5 / 30))}
            table.insert(colors, color)
        end
        return colors
    end,
    textArray = function(string)
        local result = {}
        for i=1, #string do
            result[i] = string.sub(string, i, i)
        end
        return result
    end,
    gradient_text = function(r1, g1, b1, a1, r2, g2, b2, a2, text)
        local output = ''
    
        local len = #text-1
    
        local rinc = (r2 - r1) / len
        local ginc = (g2 - g1) / len
        local binc = (b2 - b1) / len
        local ainc = (a2 - a1) / len
    
        for i=1, len+1 do
            output = output .. ('\a%02x%02x%02x%02x%s'):format(r1, g1, b1, a1, text:sub(i, i))
    
            r1 = r1 + rinc
            g1 = g1 + ginc
            b1 = b1 + binc
            a1 = a1 + ainc
        end
    
        return output
    end,    
    time_to_ticks = function(t)
        return math.floor(0.5 + (t / globals.tickinterval()))
    end,
    headVisible = function(enemy)
        local local_player = entity.get_local_player()
        if local_player == nil then return end
        local ex, ey, ez = entity.hitbox_position(enemy, 1)
    
        local hx, hy, hz = entity.hitbox_position(local_player, 1)
        local head_fraction, head_entindex_hit = client.trace_line(enemy, ex, ey, ez, hx, hy, hz)
        if head_entindex_hit == local_player or head_fraction == 1 then return true else return false end
    end,
    defensive = {
        cmd = 0,
        check = 0,
        defensive = 0,
    },
    aa_clamp = function(x) if x == nil then return 0 end x = (x % 360 + 360) % 360 return x > 180 and x - 360 or x end,
}

client.set_event_callback("run_command", function(e)
    func.defensive.cmd = e.command_number
end)
-- client.set_event_callback("predict_command", function(e)
--     if e.command_number == func.defensive.cmd then
--         local tickbase = entity.get_prop(entity.get_local_player(), "m_nTickBase")
--         func.defensive.defensive = math.abs(tickbase - func.defensive.check)
--         func.defensive.check = math.max(tickbase, func.defensive.check or 0)
--         func.defensive.cmd = 0
        
--     end
-- end)

-- client.set_event_callback("level_init", function() func.defensive.check, func.defensive.defensive = 0, 0 end)


-- render = function()
--     local x, y = client.screen_size()
--     local to_remove = {}
--     local Offset = 0
--     for i = 1, #data do
--         local notif = data[i]

--         local data = {rounding = 3, size = 2, glow = 2, time = 2}

--         if notif.time + data.time - globals.curtime() > 0 then
--             notif.fraction = func.clamp(notif.fraction + globals.frametime() / anim_time, 0, 1)
--         else
--             notif.fraction = func.clamp(notif.fraction - globals.frametime() / anim_time, 0, 1)
--         end

--         if notif.fraction <= 0 and notif.time + data.time - globals.curtime() <= 0 then
--             table.insert(to_remove, i)
--         end

--         if i > 7 then
--             table.remove(notif, i)
--         end

--         local fraction = func.easeInOut(notif.fraction)

--         local r, g, b, a = unpack(notif.color)
--         local string = color_text(notif.string, r, g, b, a * fraction)

--         local strw, strh = renderer.measure_text("", string)
--         local strw2 = renderer.measure_text("b", "")

--         local paddingx, paddingy = 7, data.size
--         local offsetY = y /2 - 350 --ui.get(menu.visualsTab.logOffset)
--         local icon_size = 35
--         local watermarkClr = {}
--         watermarkClr.r, watermarkClr.g, watermarkClr.b = ui.get(menu.visualsTab.indicatorsClr)
--         local width2 = vector(renderer.measure_text('', ("xo-yaw for gamesense | %s"):format(login.build)));


--         if ui.get(menu.visualsTab.logs_style) == "Default" then
--             Offset = Offset + (strh + paddingy*2 + 	math.sqrt(data.glow/10)*10 + 5) 
--             solus_render.container(x/2 - (strw + strw2)/2 * fraction - paddingx,y - offsetY - Offset * fraction - 10, (strw + strw2) + 10, 21,  watermarkClr.r, watermarkClr.g, watermarkClr.b, 50 * 1, 5, 255)
--             --logo:draw(x/2 + (strw/2 + 19) * fraction - paddingx, y - offsetY - Offset - (icon_size/2) + 2 - paddingy + 5, icon_size, nil,  watermarkClr.r, watermarkClr.g, watermarkClr.b, 255, true)
--             logo:draw(x/2 - (strw/2 + 40) * fraction - paddingx, y - offsetY - Offset - (icon_size/2) - paddingy + 3, icon_size, nil,  watermarkClr.r, watermarkClr.g, watermarkClr.b, 255, true)
--             --glow_module(x/2 - (strw + strw2)/2 - paddingx * fraction , y - offsetY - strh/2 - paddingy - Offset * fraction, strw + strw2 + paddingx*2, strh + paddingy*2, data.glow, data.rounding, {r, g, b, 155 * fraction}, {25,25,25,155 * fraction})
--             renderer.text(x/2 + strw2/2 * fraction, y - offsetY - Offset * fraction, 255, 255, 255, 255 * fraction, "c", 0, string)
--         elseif ui.get(menu.visualsTab.logs_style) == "OG" then
--             Offset = Offset + (strh + paddingy*2 + 	math.sqrt(data.glow/10)*10 + 9) 
--             render_ogskeet_border(x/2 - (strw/2), y - offsetY - Offset * fraction - 10, strw, 13, 255 * fraction, string)
--             --renderer.text(x/2 - (strw/2), y - offsetY - Offset * fraction - 10, 255, 255, 255, 255 * fraction, "c", 0, string)
--         elseif ui.get(menu.visualsTab.logs_style) == "Normal" then
--             Offset = Offset + (strh + paddingy*2 + 	math.sqrt(data.glow/10)*8) 
--             renderer.text(x/2, y - offsetY - Offset * fraction - 10, 255, 255, 255, 255 * fraction, "c", 0, string)
--         end
--     end
    

--     for i = #to_remove, 1, -1 do
--         table.remove(data, to_remove[i])
--     end
-- end,

client.set_event_callback( "net_update_start", function(  )
    local to_remove = {}
    for i = 1, #data do
        local native_GetClientEntity = vtable_bind("client.dll", "VClientEntityList003", 3, "uintptr_t(__thiscall*)(void*, int)");
        local player = entity.get_local_player( )

        if player == nil then
            return
        end

        local ptr = native_GetClientEntity(player);

        local m_flSimulationTime = entity.get_prop(player, "m_flSimulationTime");
        local m_flOldSimulationTime = ffi.cast("float*", ptr + 0x26C)[0];

        if (m_flSimulationTime - m_flOldSimulationTime < 0) then
            func.defensive.defensive_ticks = globals.tickcount() + toticks(.200);
            func.defensive.defensive = func.defensive.defensive_ticks
        end
    end

    for i = #to_remove, 1, -1 do
        table.remove(data, to_remove[i])
    end

end)



local clantag_anim = function(text, indices)
    local text_anim = "               " .. text ..                       "" 
    local tickinterval = globals.tickinterval()
    local tickcount = globals.tickcount() + func.time_to_ticks(client.latency())
    local i = tickcount / func.time_to_ticks(0.3)
    i = math.floor(i % #indices)
    i = indices[i+1]+1
    return string.sub(text_anim, i, i+15)
end

local trashtalk = function(e)

    local victim_userid, attacker_userid = e.userid, e.attacker
    if victim_userid == nil or attacker_userid == nil then
        return
    end

    local victim_entindex   = client.userid_to_entindex(victim_userid)
    local attacker_entindex = client.userid_to_entindex(attacker_userid)
    if attacker_entindex == entity.get_local_player() and entity.is_enemy(victim_entindex) then
        local phrase = kill[math.random(1, #kill)]
        local say = 'say ' .. phrase
        client.exec(say)
    end
end

local color_text = function( string, r, g, b, a)
    local accent = "\a" .. func.RGBAtoHEX(r, g, b, a)
    local white = "\a" .. func.RGBAtoHEX(255, 255, 255, a)

    local str = ""
    for i, s in ipairs(func.split(string, "$")) do
        str = str .. (i % 2 ==( string:sub(1, 1) == "$" and 0 or 1) and white or accent) .. s
    end

    return str
end

local animate_text = function(time, string, r, g, b, a)
    local t_out, t_out_iter = { }, 1

    local l = string:len( ) - 1

    local r_add = (255 - r)
    local g_add = (255 - g)
    local b_add = (255 - b)
    local a_add = (165 - a)

    for i = 1, #string do
        local iter = (i - 1)/(#string - 1) + time
        t_out[t_out_iter] = "\a" .. func.RGBAtoHEX( r + r_add * math.abs(math.cos( iter )), g + g_add * math.abs(math.cos( iter )), b + b_add * math.abs(math.cos( iter )), a + a_add * math.abs(math.cos( iter )) )

        t_out[t_out_iter + 1] = string:sub( i, i )

        t_out_iter = t_out_iter + 2
    end

    return t_out
end

local glow_module = function(x, y, w, h, width, rounding, accent, accent_inner)
    local thickness = 1
    local Offset = 1
    local r, g, b, a = unpack(accent)
    if accent_inner then
        func.rec(x, y, w, h + 1, rounding, accent_inner)
    end
    for k = 0, width do
        if a * (k/width)^(1) > 5 then
            local accent = {r, g, b, a * (k/width)^(2)}
            func.rec_outline(x + (k - width - Offset)*thickness, y + (k - width - Offset) * thickness, w - (k - width - Offset)*thickness*2, h + 1 - (k - width - Offset)*thickness*2, rounding + thickness * (width - k + Offset), thickness, accent)
        end
    end
end

local colorful_text = {
    lerp = function(self, from, to, duration)
        if type(from) == 'table' and type(to) == 'table' then
            return { 
                self:lerp(from[1], to[1], duration), 
                self:lerp(from[2], to[2], duration), 
                self:lerp(from[3], to[3], duration) 
            };
        end
    
        return from + (to - from) * duration;
    end,
    console = function(self, ...)
        for i, v in ipairs({ ... }) do
            if type(v[1]) == 'table' and type(v[2]) == 'table' and type(v[3]) == 'string' then
                for k = 1, #v[3] do
                    local l = self:lerp(v[1], v[2], k / #v[3]);
                    client.color_log(l[1], l[2], l[3], v[3]:sub(k, k) .. '\0');
                end
            elseif type(v[1]) == 'table' and type(v[2]) == 'string' then
                client.color_log(v[1][1], v[1][2], v[1][3], v[2] .. '\0');
            end
        end
    end,
    text = function(self, ...)
        local menu = false;
        local alpha = 255
        local f = '';
        
        for i, v in ipairs({ ... }) do
            if type(v) == 'boolean' then
                menu = v;
            elseif type(v) == 'number' then
                alpha = v;
            elseif type(v) == 'string' then
                f = f .. v;
            elseif type(v) == 'table' then
                if type(v[1]) == 'table' and type(v[2]) == 'string' then
                    f = f .. ('\a%02x%02x%02x%02x'):format(v[1][1], v[1][2], v[1][3], alpha) .. v[2];
                elseif type(v[1]) == 'table' and type(v[2]) == 'table' and type(v[3]) == 'string' then
                    for k = 1, #v[3] do
                        local g = self:lerp(v[1], v[2], k / #v[3])
                        f = f .. ('\a%02x%02x%02x%02x'):format(g[1], g[2], g[3], alpha) .. v[3]:sub(k, k)
                    end
                end
            end
        end
    
        return ('%s\a%s%02x'):format(f, (menu) and 'cdcdcd' or 'ffffff', alpha);
    end,
    log = function(self, ...)
        for i, v in ipairs({ ... }) do
            if type(v) == 'table' then
                if type(v[1]) == 'table' then
                    if type(v[2]) == 'string' then
                        self:console({ v[1], v[1], v[2] })
                        if (v[3]) then
                            self:console({ { 255, 255, 255 }, '\n' })
                        end
                    elseif type(v[2]) == 'table' then
                        self:console({ v[1], v[2], v[3] })
                        if v[4] then
                            self:console({ { 255, 255, 255 }, '\n' })
                        end
                    end
                elseif type(v[1]) == 'string' then
                    self:console({ { 205, 205, 205 }, v[1] });
                    if v[2] then
                        self:console({ { 255, 255, 255 }, '\n' })
                    end
                end
            end
        end
    end
}


local tab, container = "AA", "Anti-aimbot angles"
local masterSwitch = ui.new_checkbox(tab, container, "TAB\adec3c3ffSENSE - "..login.username.."")
local aaTabs = ui.new_combobox(tab, container, "\nAA Tabs", "Builder", "Keybinds", "Other")


local menu = {

    keys = {
        --Bindyhehe = ui.new_combobox(tab, "other", "\n", "Binds", "Other"),
       -- enable_key = ui.new_checkbox(tab, "other", "Key\adec3c3ffbinds"),
        freestandHotkey = ui.new_hotkey(tab, container, "Freest\adec3c3ffanding"),
        edgeYawHotkey = ui.new_hotkey(tab, container, "Edge\adec3c3ff Yaw"),
        manualTab = {
            manualLeft = ui.new_hotkey(tab, container, "Manual " .. func.hex({200,200,200}) .. "\adec3c3ffleft"),
            manualRight = ui.new_hotkey(tab, container, "Manual\adec3c3ff " .. func.hex({200,200,200}) .. "\adec3c3ffright"),
            manualForward = ui.new_hotkey(tab, container, "Manual\adec3c3ff " .. func.hex({200,200,200}) .. "\adec3c3ffforward"),
        },
        freestandDisablers = ui.new_multiselect(tab, container, "Freestand\adec3c3ff Disablers", {"Aero", "Duck", "Manual"}),
    },

    aaTab = {
        lol = ui.new_multiselect(tab, container, "Extra\adec3c3ff", {"Safe Knife", "Avoid Backstab", "Static on Manual"}),
    },

    --("\badffff\bfacfff[TAB]\n"
    resolver = {
        xddd = ui.new_multiselect("Players", "Adjustments", "Vis\abfacffffuals", {"Debug Panel"}),
        debug_style = ui.new_combobox("Players", "Adjustments", "Debug \abfacffffstyle", {"Default", "Skeet border"}),
        other_menu = ui.new_multiselect("Players", "Adjustments", "Oth\abfacffffer", {"Defensive Resolver", "Math Random Resolver"}),
        --resolver_disabler = ui.new_multiselect("Players", "Adjustments", "Resolver Disabler", {"CORRECTION ACTIVE","STAND", "MOVE", "CROUCH", "INAIR", "SLOWWALK"}),
    },


    builderTab = {
        PresetComboBox = ui.new_combobox(tab, "Fake Lag", "Pres\adec3c3ffets", "Disabled", "Unmatched", "Community"),
       -- buttonPresets = ui.new_button(tab, "Fake Lag", "Pres\adec3c3ffets", function() end),
        LogicComboBox = ui.new_combobox(tab, "Fake Lag", "logica\adec3c3ff secret", "1", "2"),
        buttonBuilder = ui.new_button(tab, "Fake Lag", "Builder", function() end),
        state = ui.new_combobox(tab, container, "Anti-aim state", vars.aaStates)
    },
    visualsTab = {
        indicators = ui.new_combobox(tab, container, "» Indic\adec3c3ffators", "Disabled", "New", "Second"),
        indicatorsClr = ui.new_color_picker(tab, container, "» Main \adec3c3ffColor", lua_color.r, lua_color.g, lua_color.b, 255),
        defensive_indicator = ui.new_multiselect(tab, container, "Select \adec3c3ffIndicator", "Defensive", "Slowdown", "Kibit"),
        defensive_indicatorClr = ui.new_color_picker(tab, container, "» Indicators \adec3c3ffColor", lua_color.r, lua_color.g, lua_color.b, 255),
        arrows = ui.new_checkbox(tab, container, "» Arr\adec3c3ffows"),
        arrowClr = ui.new_color_picker(tab, container, "Arrow Color", lua_color.r, lua_color.g, lua_color.b, 255),
        arrowIndicatorStyle = ui.new_combobox(tab, container, "\n arrows style", "-", "Teamskeet", "Normal"),
        velocity_ada = ui.new_checkbox(tab, container, "» Velocity \adec3c3ffadaptive"),
        watermark = ui.new_checkbox(tab, container, "» Water\adec3c3ffmark"),
        watermark_pos = ui.new_combobox(tab, container, "» Water\adec3c3ffmark posiotion", {"left", "right", "bottom", "top"}),
        watermark_opt = ui.new_checkbox(tab, container, "» Remove \adec3c3ffspaces"),
        watermarkClr = ui.new_color_picker(tab, container, "» Watermark\adec3c3ff Color", lua_color.r, lua_color.g, lua_color.b, 255),
        watermark_og_opt = ui.new_multiselect(tab, container, "» Watermark\adec3c3ff Options", {"fps", "ping", "time"}),
        logs = ui.new_checkbox(tab, container, "» Screen\adec3c3ff Hit Logs"),
        logsClr = ui.new_color_picker(tab, container, "Logs\adec3c3ff Color", lua_color.r, lua_color.g, lua_color.b, 255),
        logs_style = ui.new_combobox(tab,container, "Logs\adec3c3ff Style", {"Default", "OG", "Normal"}),
    },
    miscTab = {
        trashTalk = ui.new_checkbox(tab, container, "» Trash\adec3c3ffTalk"),
        fastLadderEnabled = ui.new_checkbox(tab, container, "» Fast\adec3c3ff ladder"),
        fastLadder = ui.new_multiselect(tab, container, "\n » fast\adec3c3ff ladder", "Ascending", "Descending"),
        animationsEnabled = ui.new_checkbox(tab, container, "» Local\adec3c3ff animations"),
        animations = ui.new_multiselect(tab, container, "\n » animation\adec3c3ff breakers", "Break legs while in Aero", "Reset pitch on land", "Leg fucker", "Be Micheal Jackson"),
    },
    configTab = {
        list = ui.new_listbox(tab, container, "Configs", ""),
        name = ui.new_textbox(tab, container, "Name", ""),
        load = ui.new_button(tab, container, "Load", function() end),
        save = ui.new_button(tab, container, "Save", function() end),
        delete = ui.new_button(tab, container, "Delete", function() end),
        import = ui.new_button(tab, container, "Import Settings", function() end),
        export = ui.new_button(tab, container, "Share", function() end)
    },
}

local aaBuilder = {}
local aaContainer = {}
for i=1, #vars.aaStates do
    aaContainer[i] = func.hex({200,200,200}) .. "(" .. func.hex({222,55,55}) .. "" .. vars.pStates[i] .. "" .. func.hex({200,200,200}) .. ")" .. func.hex({155,155,155}) .. " "
    aaBuilder[i] = {
--    aa_builder[i].pitch = group:combobox("\v"..aa_state_full[i].."\r  Pitch", "Off", "Down", "Up")


        enableState = ui.new_checkbox(tab, container, "Enable " .. func.hex({lua_color.r, lua_color.g, lua_color.b}) .. vars.aaStates[i] .. func.hex({200,200,200})),
        pitch = ui.new_combobox(tab, container, "• Pitch\n" .. aaContainer[i], "Off", "Default", "Minimal", "Up", "Custom"),
        pitchSlider = ui.new_slider(tab, container, "\n• Pitch add" .. aaContainer[i], -89, 89, 0, true, "•", 1),
        yawBase = ui.new_combobox(tab, container, "• View\n" .. aaContainer[i], "Local view", "At targets"),
   --     'Off', '180', 'Spin', 'Static', '180 Z', 'Crosshair'
        yaw = ui.new_combobox(tab, container, "• Yaw\n" .. aaContainer[i], 'Off', '180', 'Spin', 'Static', '180 Z', 'Crosshair'),
        yawCondition = ui.new_combobox(tab, container, "• Yaw modes\n" .. aaContainer[i], "Static", "L & R", "Delay", "Tickbased"),
        yawStatic = ui.new_slider(tab, container, "• Amount\n" .. aaContainer[i], -180, 180, 0, true, "•", 1),
        yawLeft = ui.new_slider(tab, container, "• L\n" .. aaContainer[i], -180, 180, 0, true, "•", 1),
        yawRight = ui.new_slider(tab, container, "• R\n" .. aaContainer[i], -180, 180, 0, true, "•", 1),
        yawSpeed = ui.new_slider(tab, container, "• Delay\n" .. aaContainer[i], 1, 14, 6, 0),
        yawJitter = ui.new_combobox(tab, container, "• Yaw jitter mode\n" .. aaContainer[i], "Off", "Offset", "Center", "Random", "Sync", "TabJitter"),
        yawJitterCondition = ui.new_combobox(tab, container, "• Conditions\n" .. aaContainer[i], "Static", "L & R"),
        yawJitterStatic = ui.new_slider(tab, container, "\nyaw jitter limit" .. aaContainer[i], -180, 180, 0, true, "•", 1),
        yawJitterLeft = ui.new_slider(tab, container, "• L\nyaw jitter" .. aaContainer[i], -180, 180, 0, true, "•", 1),
        yawJitterRight = ui.new_slider(tab, container, "• R\nyaw jitter" .. aaContainer[i], -180, 180, 0, true, "•", 1),
        bodyYaw = ui.new_combobox(tab, container, "• Body yaw\n" .. aaContainer[i], "Off", "Opposite", "Jitter", "Static"),
        bodyYawSlider = ui.new_slider(tab, container, "\n• body yaw limit" .. aaContainer[i], -180, 180, 0, true, "•", 1),
        enabledefensive = ui.new_checkbox(tab, container, "Enable Defensive\n" .. aaContainer[i]),
        defensiveOpt = ui.new_combobox(tab, container, "• Defensive Mode\n" .. aaContainer[i], "None", "Always on", "Time to ticks", "Hold Ticks"),
        defensiveYaw = ui.new_combobox(tab, container, "• Defensive Type\n" .. aaContainer[i], "None", "Jitter", "Flick", "Spin", "Custom"),
        defensiveYawSlider = ui.new_slider(tab, container, "\n• DefensiveYawSlider" .. aaContainer[i], -180, 180, 0, true, "", 1),
        defensivePitch = ui.new_combobox(tab, container, "• Defensive pitch\n" .. aaContainer[i], "None", "Up", "Swap", "Custom", "Random"),
        defensivePitchSlider = ui.new_slider(tab, container, "\nDefensivePitchSlider" .. aaContainer[i], -89, 89, 0, true, "•", 1),
    }
end

local function getConfig(name)
    local database = database.read(lua.database.configs) or {}

    for i, v in pairs(database) do
        if v.name == name then
            return {
                config = v.config,
                index = i
            }
        end
    end

    for i, v in pairs(presets) do
        if v.name == name then
            return {
                config = v.config,
                index = i
            }
        end
    end

    return false
end
local function saveConfig(name)
    local db = database.read(lua.database.configs) or {}
    local config = {}

    if name:match("[^%w]") ~= nil then
        return
    end

    for key, value in pairs(vars.pStates) do
        config[value] = {}
        for k, v in pairs(aaBuilder[key]) do
            config[value][k] = ui.get(v)
        end
    end

    local cfg = getConfig(name)

    if not cfg then
        table.insert(db, { name = name, config = config })
    else
        db[cfg.index].config = config
    end

    database.write(lua.database.configs, db)
end
local function deleteConfig(name)
    local db = database.read(lua.database.configs) or {}

    for i, v in pairs(db) do
        if v.name == name then
            table.remove(db, i)
            break
        end
    end

    for i, v in pairs(presets) do
        if v.name == name then
            return false
        end
    end

    database.write(lua.database.configs, db)
end
local function getConfigList()
    local database = database.read(lua.database.configs) or {}
    local config = {}

    for i, v in pairs(presets) do
        table.insert(config, v.name)
    end

    for i, v in pairs(database) do
        table.insert(config, v.name)
    end

    return config
end
local function typeFromString(input)
    if type(input) ~= "string" then return input end

    local value = input:lower()

    if value == "true" then
        return true
    elseif value == "false" then
        return false
    elseif tonumber(value) ~= nil then
        return tonumber(value)
    else
        return tostring(input)
    end
end
local inspect = try_require('gamesense/inspect')
local function loadSettings(e)
    for key, value in pairs(vars.pStates) do
        for k, v in pairs(aaBuilder[key]) do
            if (e[value][k] ~= nil) then
                ui.set(v, e[value][k])
            end
        end 
    end
end
local alph = "base64"
local function importSettings()
    local frombuffer = clipboard.get()
    local decode = base64.decode(frombuffer, alph)
    local toTable = json.parse(decode)
    loadSettings(toTable.config)
end
local function importPreset()
    local frombuffer = "eyJpbmRleCI6MiwiY29uZmlnIjp7IkxBIjp7InBpdGNoIjoiT2ZmIiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOjAsInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJ5YXdMZWZ0IjowLCJkZWZlbnNpdmVQaXRjaCI6Ik5vbmUiLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOmZhbHNlLCJkZWZlbnNpdmVZYXciOiJOb25lIiwieWF3UmlnaHQiOjAsImJvZHlZYXciOiJPZmYiLCJ5YXciOiJPZmYiLCJ5YXdTdGF0aWMiOjAsInlhd0NvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlciI6Ik9mZiIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6Ik5vbmUiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJTdGF0aWMiLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJMb2NhbCB2aWV3In0sIlNXIjp7InBpdGNoIjoiRGVmYXVsdCIsInBpdGNoU2xpZGVyIjowLCJib2R5WWF3U2xpZGVyIjotMTksInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJ5YXdMZWZ0IjotMTksImRlZmVuc2l2ZVBpdGNoIjoiTm9uZSIsImVuYWJsZWRlZmVuc2l2ZSI6ZmFsc2UsImRlZmVuc2l2ZVBpdGNoU2xpZGVyIjowLCJlbmFibGVTdGF0ZSI6dHJ1ZSwiZGVmZW5zaXZlWWF3IjoiTm9uZSIsInlhd1JpZ2h0IjoyNywiYm9keVlhdyI6IkppdHRlciIsInlhdyI6IjE4MCIsInlhd1N0YXRpYyI6MCwieWF3Q29uZGl0aW9uIjoiTCAmIFIiLCJ5YXdKaXR0ZXIiOiJDZW50ZXIiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjoyNywiZGVmZW5zaXZlT3B0IjoiTm9uZSIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiUyI6eyJwaXRjaCI6IkRlZmF1bHQiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6LTE5LCJ5YXdKaXR0ZXJMZWZ0IjozOCwieWF3Sml0dGVyUmlnaHQiOjQxLCJ5YXdMZWZ0IjotMTUsImRlZmVuc2l2ZVBpdGNoIjoiTm9uZSIsImVuYWJsZWRlZmVuc2l2ZSI6ZmFsc2UsImRlZmVuc2l2ZVBpdGNoU2xpZGVyIjowLCJlbmFibGVTdGF0ZSI6dHJ1ZSwiZGVmZW5zaXZlWWF3IjoiTm9uZSIsInlhd1JpZ2h0Ijo5LCJib2R5WWF3IjoiSml0dGVyIiwieWF3IjoiMTgwIiwieWF3U3RhdGljIjowLCJ5YXdDb25kaXRpb24iOiJMICYgUiIsInlhd0ppdHRlciI6IkNlbnRlciIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6Ik5vbmUiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJMICYgUiIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiQUMiOnsicGl0Y2giOiJEZWZhdWx0IiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOi0xOSwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsInlhd0xlZnQiOi00MSwiZGVmZW5zaXZlUGl0Y2giOiJOb25lIiwiZW5hYmxlZGVmZW5zaXZlIjpmYWxzZSwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjp0cnVlLCJkZWZlbnNpdmVZYXciOiJOb25lIiwieWF3UmlnaHQiOi0yOCwiYm9keVlhdyI6IkppdHRlciIsInlhdyI6IjE4MCIsInlhd1N0YXRpYyI6MCwieWF3Q29uZGl0aW9uIjoiTCAmIFIiLCJ5YXdKaXR0ZXIiOiJPZmZzZXQiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjo2MSwiZGVmZW5zaXZlT3B0IjoiTm9uZSIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiQSI6eyJwaXRjaCI6IkRlZmF1bHQiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6LTIxLCJ5YXdKaXR0ZXJMZWZ0IjowLCJ5YXdKaXR0ZXJSaWdodCI6MCwieWF3TGVmdCI6LTQxLCJkZWZlbnNpdmVQaXRjaCI6Ik5vbmUiLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOnRydWUsImRlZmVuc2l2ZVlhdyI6Ik5vbmUiLCJ5YXdSaWdodCI6MjgsImJvZHlZYXciOiJKaXR0ZXIiLCJ5YXciOiIxODAiLCJ5YXdTdGF0aWMiOjAsInlhd0NvbmRpdGlvbiI6IkwgJiBSIiwieWF3Sml0dGVyIjoiT2Zmc2V0IiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6NSwiZGVmZW5zaXZlT3B0IjoiTm9uZSIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiTSI6eyJwaXRjaCI6IkRlZmF1bHQiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6LTE5LCJ5YXdKaXR0ZXJMZWZ0IjowLCJ5YXdKaXR0ZXJSaWdodCI6MCwieWF3TGVmdCI6LTMyLCJkZWZlbnNpdmVQaXRjaCI6Ik5vbmUiLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOnRydWUsImRlZmVuc2l2ZVlhdyI6Ik5vbmUiLCJ5YXdSaWdodCI6MjcsImJvZHlZYXciOiJKaXR0ZXIiLCJ5YXciOiIxODAiLCJ5YXdTdGF0aWMiOjAsInlhd0NvbmRpdGlvbiI6IkwgJiBSIiwieWF3Sml0dGVyIjoiQ2VudGVyIiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6MTAsImRlZmVuc2l2ZU9wdCI6Ik5vbmUiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJTdGF0aWMiLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJBdCB0YXJnZXRzIn0sIkMiOnsicGl0Y2giOiJEZWZhdWx0IiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOi0xOSwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsInlhd0xlZnQiOi0yNSwiZGVmZW5zaXZlUGl0Y2giOiJOb25lIiwiZW5hYmxlZGVmZW5zaXZlIjpmYWxzZSwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjp0cnVlLCJkZWZlbnNpdmVZYXciOiJOb25lIiwieWF3UmlnaHQiOjE0LCJib2R5WWF3IjoiSml0dGVyIiwieWF3IjoiMTgwIiwieWF3U3RhdGljIjowLCJ5YXdDb25kaXRpb24iOiJMICYgUiIsInlhd0ppdHRlciI6Ik9mZnNldCIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjM0LCJkZWZlbnNpdmVPcHQiOiJOb25lIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiU3RhdGljIiwiZGVmZW5zaXZlWWF3U2xpZGVyIjowLCJ5YXdCYXNlIjoiQXQgdGFyZ2V0cyJ9LCJHIjp7InBpdGNoIjoiRGVmYXVsdCIsInBpdGNoU2xpZGVyIjowLCJib2R5WWF3U2xpZGVyIjotMSwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsInlhd0xlZnQiOi00NiwiZGVmZW5zaXZlUGl0Y2giOiJSYW5kb20iLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOnRydWUsImRlZmVuc2l2ZVlhdyI6IkppdHRlciIsInlhd1JpZ2h0IjozOSwiYm9keVlhdyI6IkppdHRlciIsInlhdyI6IjE4MCIsInlhd1N0YXRpYyI6MCwieWF3Q29uZGl0aW9uIjoiTCAmIFIiLCJ5YXdKaXR0ZXIiOiJPZmYiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjowLCJkZWZlbnNpdmVPcHQiOiJIb2xkIFRpY2tzIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiTCAmIFIiLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJBdCB0YXJnZXRzIn19fQ=="
    local decode = base64.decode(frombuffer, alph)
    local toTable = json.parse(decode)
    loadSettings(toTable.config)
end
local function importPresetClear()
    local frombuffer = "eyJpbmRleCI6OCwiY29uZmlnIjp7IkxBIjp7InBpdGNoIjoiT2ZmIiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOjAsInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJib2R5WWF3IjoiT2ZmIiwiZGVmZW5zaXZlUGl0Y2giOiItIiwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjpmYWxzZSwiZGVmZW5zaXZlWWF3IjoiLSIsInlhd1JpZ2h0IjowLCJ5YXdKaXR0ZXJEaXNhYmxlcnMiOnt9LCJ5YXdTdGF0aWMiOjAsInlhdyI6Ik9mZiIsInlhd0NvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlciI6Ik9mZiIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6e30sInlhd0xlZnQiOjAsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkxvY2FsIHZpZXcifSwiU1ciOnsicGl0Y2giOiJPZmYiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6MCwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsImJvZHlZYXciOiJPZmYiLCJkZWZlbnNpdmVQaXRjaCI6Ii0iLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOmZhbHNlLCJkZWZlbnNpdmVZYXciOiItIiwieWF3UmlnaHQiOjAsInlhd0ppdHRlckRpc2FibGVycyI6e30sInlhd1N0YXRpYyI6MCwieWF3IjoiT2ZmIiwieWF3Q29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyIjoiT2ZmIiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6MCwiZGVmZW5zaXZlT3B0Ijp7fSwieWF3TGVmdCI6MCwiZGVmZW5zaXZlWWF3U2xpZGVyIjowLCJ5YXdCYXNlIjoiTG9jYWwgdmlldyJ9LCJTIjp7InBpdGNoIjoiT2ZmIiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOjAsInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJib2R5WWF3IjoiT2ZmIiwiZGVmZW5zaXZlUGl0Y2giOiItIiwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjpmYWxzZSwiZGVmZW5zaXZlWWF3IjoiLSIsInlhd1JpZ2h0IjowLCJ5YXdKaXR0ZXJEaXNhYmxlcnMiOnt9LCJ5YXdTdGF0aWMiOjAsInlhdyI6Ik9mZiIsInlhd0NvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlciI6Ik9mZiIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6e30sInlhd0xlZnQiOjAsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkxvY2FsIHZpZXcifSwiQUMiOnsicGl0Y2giOiJPZmYiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6MCwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsImJvZHlZYXciOiJPZmYiLCJkZWZlbnNpdmVQaXRjaCI6Ii0iLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOmZhbHNlLCJkZWZlbnNpdmVZYXciOiItIiwieWF3UmlnaHQiOjAsInlhd0ppdHRlckRpc2FibGVycyI6e30sInlhd1N0YXRpYyI6MCwieWF3IjoiT2ZmIiwieWF3Q29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyIjoiT2ZmIiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6MCwiZGVmZW5zaXZlT3B0Ijp7fSwieWF3TGVmdCI6MCwiZGVmZW5zaXZlWWF3U2xpZGVyIjowLCJ5YXdCYXNlIjoiTG9jYWwgdmlldyJ9LCJBIjp7InBpdGNoIjoiT2ZmIiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOjAsInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJib2R5WWF3IjoiT2ZmIiwiZGVmZW5zaXZlUGl0Y2giOiItIiwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjpmYWxzZSwiZGVmZW5zaXZlWWF3IjoiLSIsInlhd1JpZ2h0IjowLCJ5YXdKaXR0ZXJEaXNhYmxlcnMiOnt9LCJ5YXdTdGF0aWMiOjAsInlhdyI6Ik9mZiIsInlhd0NvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlciI6Ik9mZiIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6e30sInlhd0xlZnQiOjAsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkxvY2FsIHZpZXcifSwiTSI6eyJwaXRjaCI6Ik9mZiIsInBpdGNoU2xpZGVyIjowLCJib2R5WWF3U2xpZGVyIjowLCJ5YXdKaXR0ZXJMZWZ0IjowLCJ5YXdKaXR0ZXJSaWdodCI6MCwiYm9keVlhdyI6Ik9mZiIsImRlZmVuc2l2ZVBpdGNoIjoiLSIsImRlZmVuc2l2ZVBpdGNoU2xpZGVyIjowLCJlbmFibGVTdGF0ZSI6ZmFsc2UsImRlZmVuc2l2ZVlhdyI6Ii0iLCJ5YXdSaWdodCI6MCwieWF3Sml0dGVyRGlzYWJsZXJzIjp7fSwieWF3U3RhdGljIjowLCJ5YXciOiJPZmYiLCJ5YXdDb25kaXRpb24iOiJTdGF0aWMiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJTdGF0aWMiLCJ5YXdKaXR0ZXIiOiJPZmYiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjowLCJkZWZlbnNpdmVPcHQiOnt9LCJ5YXdMZWZ0IjowLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJMb2NhbCB2aWV3In0sIkMiOnsicGl0Y2giOiJPZmYiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6MCwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsImJvZHlZYXciOiJPZmYiLCJkZWZlbnNpdmVQaXRjaCI6Ii0iLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOmZhbHNlLCJkZWZlbnNpdmVZYXciOiItIiwieWF3UmlnaHQiOjAsInlhd0ppdHRlckRpc2FibGVycyI6e30sInlhd1N0YXRpYyI6MCwieWF3IjoiT2ZmIiwieWF3Q29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyIjoiT2ZmIiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6MCwiZGVmZW5zaXZlT3B0Ijp7fSwieWF3TGVmdCI6MCwiZGVmZW5zaXZlWWF3U2xpZGVyIjowLCJ5YXdCYXNlIjoiTG9jYWwgdmlldyJ9LCJHIjp7InBpdGNoIjoiT2ZmIiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOjAsInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJib2R5WWF3IjoiT2ZmIiwiZGVmZW5zaXZlUGl0Y2giOiItIiwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjp0cnVlLCJkZWZlbnNpdmVZYXciOiItIiwieWF3UmlnaHQiOjAsInlhd0ppdHRlckRpc2FibGVycyI6e30sInlhd1N0YXRpYyI6MCwieWF3IjoiT2ZmIiwieWF3Q29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiU3RhdGljIiwieWF3Sml0dGVyIjoiT2ZmIiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6MCwiZGVmZW5zaXZlT3B0Ijp7fSwieWF3TGVmdCI6MCwiZGVmZW5zaXZlWWF3U2xpZGVyIjowLCJ5YXdCYXNlIjoiTG9jYWwgdmlldyJ9fX0="
    local decode = base64.decode(frombuffer, alph)
    local toTable = json.parse(decode)
    loadSettings(toTable.config)
end
local function importPreset2()
    local frombuffer = "eyJpbmRleCI6MiwiY29uZmlnIjp7IkxBIjp7InBpdGNoIjoiT2ZmIiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOjAsInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJ5YXdMZWZ0IjowLCJkZWZlbnNpdmVQaXRjaCI6Ik5vbmUiLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOmZhbHNlLCJkZWZlbnNpdmVZYXciOiJOb25lIiwieWF3UmlnaHQiOjAsImJvZHlZYXciOiJPZmYiLCJ5YXciOiJPZmYiLCJ5YXdTdGF0aWMiOjAsInlhd0NvbmRpdGlvbiI6IlN0YXRpYyIsInlhd0ppdHRlciI6Ik9mZiIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6Ik5vbmUiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJTdGF0aWMiLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJMb2NhbCB2aWV3In0sIlNXIjp7InBpdGNoIjoiRGVmYXVsdCIsInBpdGNoU2xpZGVyIjowLCJib2R5WWF3U2xpZGVyIjotMTksInlhd0ppdHRlckxlZnQiOjAsInlhd0ppdHRlclJpZ2h0IjowLCJ5YXdMZWZ0IjotMTksImRlZmVuc2l2ZVBpdGNoIjoiTm9uZSIsImVuYWJsZWRlZmVuc2l2ZSI6ZmFsc2UsImRlZmVuc2l2ZVBpdGNoU2xpZGVyIjowLCJlbmFibGVTdGF0ZSI6dHJ1ZSwiZGVmZW5zaXZlWWF3IjoiTm9uZSIsInlhd1JpZ2h0IjoyNywiYm9keVlhdyI6IkppdHRlciIsInlhdyI6IjE4MCIsInlhd1N0YXRpYyI6MCwieWF3Q29uZGl0aW9uIjoiTCAmIFIiLCJ5YXdKaXR0ZXIiOiJDZW50ZXIiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjoyNywiZGVmZW5zaXZlT3B0IjoiTm9uZSIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiUyI6eyJwaXRjaCI6IkRlZmF1bHQiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6LTE5LCJ5YXdKaXR0ZXJMZWZ0IjozOCwieWF3Sml0dGVyUmlnaHQiOjQxLCJ5YXdMZWZ0IjotMTUsImRlZmVuc2l2ZVBpdGNoIjoiTm9uZSIsImVuYWJsZWRlZmVuc2l2ZSI6ZmFsc2UsImRlZmVuc2l2ZVBpdGNoU2xpZGVyIjowLCJlbmFibGVTdGF0ZSI6dHJ1ZSwiZGVmZW5zaXZlWWF3IjoiTm9uZSIsInlhd1JpZ2h0Ijo5LCJib2R5WWF3IjoiSml0dGVyIiwieWF3IjoiMTgwIiwieWF3U3RhdGljIjowLCJ5YXdDb25kaXRpb24iOiJMICYgUiIsInlhd0ppdHRlciI6IkNlbnRlciIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjAsImRlZmVuc2l2ZU9wdCI6Ik5vbmUiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJMICYgUiIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiQUMiOnsicGl0Y2giOiJEZWZhdWx0IiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOi0xOSwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsInlhd0xlZnQiOi00MSwiZGVmZW5zaXZlUGl0Y2giOiJOb25lIiwiZW5hYmxlZGVmZW5zaXZlIjpmYWxzZSwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjp0cnVlLCJkZWZlbnNpdmVZYXciOiJOb25lIiwieWF3UmlnaHQiOi0yOCwiYm9keVlhdyI6IkppdHRlciIsInlhdyI6IjE4MCIsInlhd1N0YXRpYyI6MCwieWF3Q29uZGl0aW9uIjoiTCAmIFIiLCJ5YXdKaXR0ZXIiOiJPZmZzZXQiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjo2MSwiZGVmZW5zaXZlT3B0IjoiTm9uZSIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiQSI6eyJwaXRjaCI6IkRlZmF1bHQiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6LTIxLCJ5YXdKaXR0ZXJMZWZ0IjowLCJ5YXdKaXR0ZXJSaWdodCI6MCwieWF3TGVmdCI6LTQxLCJkZWZlbnNpdmVQaXRjaCI6Ik5vbmUiLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOnRydWUsImRlZmVuc2l2ZVlhdyI6Ik5vbmUiLCJ5YXdSaWdodCI6MjgsImJvZHlZYXciOiJKaXR0ZXIiLCJ5YXciOiIxODAiLCJ5YXdTdGF0aWMiOjAsInlhd0NvbmRpdGlvbiI6IkwgJiBSIiwieWF3Sml0dGVyIjoiT2Zmc2V0IiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6NSwiZGVmZW5zaXZlT3B0IjoiTm9uZSIsInlhd0ppdHRlckNvbmRpdGlvbiI6IlN0YXRpYyIsImRlZmVuc2l2ZVlhd1NsaWRlciI6MCwieWF3QmFzZSI6IkF0IHRhcmdldHMifSwiTSI6eyJwaXRjaCI6IkRlZmF1bHQiLCJwaXRjaFNsaWRlciI6MCwiYm9keVlhd1NsaWRlciI6LTE5LCJ5YXdKaXR0ZXJMZWZ0IjowLCJ5YXdKaXR0ZXJSaWdodCI6MCwieWF3TGVmdCI6LTMyLCJkZWZlbnNpdmVQaXRjaCI6Ik5vbmUiLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOnRydWUsImRlZmVuc2l2ZVlhdyI6Ik5vbmUiLCJ5YXdSaWdodCI6MjcsImJvZHlZYXciOiJKaXR0ZXIiLCJ5YXciOiIxODAiLCJ5YXdTdGF0aWMiOjAsInlhd0NvbmRpdGlvbiI6IkwgJiBSIiwieWF3Sml0dGVyIjoiQ2VudGVyIiwieWF3U3BlZWQiOjYsInlhd0ppdHRlclN0YXRpYyI6MTAsImRlZmVuc2l2ZU9wdCI6Ik5vbmUiLCJ5YXdKaXR0ZXJDb25kaXRpb24iOiJTdGF0aWMiLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJBdCB0YXJnZXRzIn0sIkMiOnsicGl0Y2giOiJEZWZhdWx0IiwicGl0Y2hTbGlkZXIiOjAsImJvZHlZYXdTbGlkZXIiOi0xOSwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsInlhd0xlZnQiOi0yNSwiZGVmZW5zaXZlUGl0Y2giOiJOb25lIiwiZW5hYmxlZGVmZW5zaXZlIjpmYWxzZSwiZGVmZW5zaXZlUGl0Y2hTbGlkZXIiOjAsImVuYWJsZVN0YXRlIjp0cnVlLCJkZWZlbnNpdmVZYXciOiJOb25lIiwieWF3UmlnaHQiOjE0LCJib2R5WWF3IjoiSml0dGVyIiwieWF3IjoiMTgwIiwieWF3U3RhdGljIjowLCJ5YXdDb25kaXRpb24iOiJMICYgUiIsInlhd0ppdHRlciI6Ik9mZnNldCIsInlhd1NwZWVkIjo2LCJ5YXdKaXR0ZXJTdGF0aWMiOjM0LCJkZWZlbnNpdmVPcHQiOiJOb25lIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiU3RhdGljIiwiZGVmZW5zaXZlWWF3U2xpZGVyIjowLCJ5YXdCYXNlIjoiQXQgdGFyZ2V0cyJ9LCJHIjp7InBpdGNoIjoiRGVmYXVsdCIsInBpdGNoU2xpZGVyIjowLCJib2R5WWF3U2xpZGVyIjotMSwieWF3Sml0dGVyTGVmdCI6MCwieWF3Sml0dGVyUmlnaHQiOjAsInlhd0xlZnQiOi00NiwiZGVmZW5zaXZlUGl0Y2giOiJSYW5kb20iLCJlbmFibGVkZWZlbnNpdmUiOmZhbHNlLCJkZWZlbnNpdmVQaXRjaFNsaWRlciI6MCwiZW5hYmxlU3RhdGUiOnRydWUsImRlZmVuc2l2ZVlhdyI6IkppdHRlciIsInlhd1JpZ2h0IjozOSwiYm9keVlhdyI6IkppdHRlciIsInlhdyI6IjE4MCIsInlhd1N0YXRpYyI6MCwieWF3Q29uZGl0aW9uIjoiTCAmIFIiLCJ5YXdKaXR0ZXIiOiJPZmYiLCJ5YXdTcGVlZCI6NiwieWF3Sml0dGVyU3RhdGljIjowLCJkZWZlbnNpdmVPcHQiOiJIb2xkIFRpY2tzIiwieWF3Sml0dGVyQ29uZGl0aW9uIjoiTCAmIFIiLCJkZWZlbnNpdmVZYXdTbGlkZXIiOjAsInlhd0Jhc2UiOiJBdCB0YXJnZXRzIn19fQ=="
    local decode = base64.decode(frombuffer, alph)
    local toTable = json.parse(decode)
    loadSettings(toTable.config)
end

local function exportSettings(name)
    local config = getConfig(name)
    local toString = json.stringify(config)
    local toExport = base64.encode(toString, alph)
    clipboard.set(toExport)
end
local function loadConfig(name)
    local config = getConfig(name)
    loadSettings(config.config)
end

local function initDatabase()
    if database.read(lua.database.configs) == nil then
        database.write(lua.database.configs, {})
    end

    local link = "https://pastebin.com/raw/afg2YkEv"

    http.get(link, function(success, response)
        if not success then
            print("Failed to load config [422]")
            return
        end
    
        local data = json.parse(response.body)
    
        for i, preset in pairs(data.presets) do
            table.insert(presets, { name = "*"..preset.name, config = preset.config})
            ui.set(menu.configTab.name, "*"..preset.name)
        end
        ui.update(menu.configTab.list, getConfigList())
    end)
end
initDatabase()

local anim_time = 0.3
local max_notifs = 6
local data = {}
local notifications = {

    new = function(string, r, g, b)
        table.insert(data, {
            time = globals.curtime(),
            string = string,
            color = {r, g, b, 255},
            fraction = 0
        })
        local time = 5
        for i = #data, 1, -1 do
            local notif = data[i]
            if #data - i + 1 > max_notifs and notif.time + time - globals.curtime() > 0 then
                notif.time = globals.curtime() - time
            end
        end
    end,

    render = function()
        local x, y = client.screen_size()
        local to_remove = {}
        local Offset = 0
        for i = 1, #data do
            local notif = data[i]

            local data = {rounding = 3, size = 2, glow = 2, time = 2}

            if notif.time + data.time - globals.curtime() > 0 then
                notif.fraction = func.clamp(notif.fraction + globals.frametime() / anim_time, 0, 1)
            else
                notif.fraction = func.clamp(notif.fraction - globals.frametime() / anim_time, 0, 1)
            end

            if notif.fraction <= 0 and notif.time + data.time - globals.curtime() <= 0 then
                table.insert(to_remove, i)
            end

            if i > 7 then
                table.remove(notif, i)
            end

            local fraction = func.easeInOut(notif.fraction)

            local r, g, b, a = unpack(notif.color)
            local string = color_text(notif.string, r, g, b, a * fraction)

            local strw, strh = renderer.measure_text("", string)
            local strw2 = renderer.measure_text("b", "")

            local paddingx, paddingy = 7, data.size
            local offsetY = y /2 - 350 --ui.get(menu.visualsTab.logOffset)
            local icon_size = 35
            local watermarkClr = {}
            watermarkClr.r, watermarkClr.g, watermarkClr.b = ui.get(menu.visualsTab.indicatorsClr)
            local width2 = vector(renderer.measure_text('', ("xo-yaw for gamesense | %s"):format(login.build)));


            if ui.get(menu.visualsTab.logs_style) == "Default" then
                Offset = Offset + (strh + paddingy*2 + 	math.sqrt(data.glow/10)*10 + 5) 
                solus_render.container(x/2 - (strw + strw2)/2 * fraction - paddingx,y - offsetY - Offset * fraction - 10, (strw + strw2) + 10, 21,  watermarkClr.r, watermarkClr.g, watermarkClr.b, 50 * 1, 5, 255)
                --logo:draw(x/2 + (strw/2 + 19) * fraction - paddingx, y - offsetY - Offset - (icon_size/2) + 2 - paddingy + 5, icon_size, nil,  watermarkClr.r, watermarkClr.g, watermarkClr.b, 255, true)
                logo:draw(x/2 - (strw/2 + 40) * fraction - paddingx, y - offsetY - Offset - (icon_size/2) - paddingy + 3, icon_size, nil,  watermarkClr.r, watermarkClr.g, watermarkClr.b, 255, true)
                --glow_module(x/2 - (strw + strw2)/2 - paddingx * fraction , y - offsetY - strh/2 - paddingy - Offset * fraction, strw + strw2 + paddingx*2, strh + paddingy*2, data.glow, data.rounding, {r, g, b, 155 * fraction}, {25,25,25,155 * fraction})
                renderer.text(x/2 + strw2/2 * fraction, y - offsetY - Offset * fraction, 255, 255, 255, 255 * fraction, "c", 0, string)
            elseif ui.get(menu.visualsTab.logs_style) == "OG" then
                Offset = Offset + (strh + paddingy*2 + 	math.sqrt(data.glow/10)*10 + 9) 
                render_ogskeet_border(x/2 - (strw/2), y - offsetY - Offset * fraction - 10, strw, 13, 255 * fraction, string)
                --renderer.text(x/2 - (strw/2), y - offsetY - Offset * fraction - 10, 255, 255, 255, 255 * fraction, "c", 0, string)
            elseif ui.get(menu.visualsTab.logs_style) == "Normal" then
                Offset = Offset + (strh + paddingy*2 + 	math.sqrt(data.glow/10)*8) 
                renderer.text(x/2, y - offsetY - Offset * fraction - 10, 255, 255, 255, 255 * fraction, "c", 0, string)
            end
        end
        

        for i = #to_remove, 1, -1 do
            table.remove(data, to_remove[i])
        end
    end,

    clear = function()
        data = {}
    end
}



local function onHit(e)
    local group = vars.hitgroup_names[e.hitgroup + 1] or '?'
	local r, g, b, a = ui.get(menu.visualsTab.indicatorsClr)
	notifications.new(string.format("Hit %s's $%s$ for $%d$ damage", entity.get_player_name(e.target), group:lower(), e.damage), r, g, b) 
    --	notifications.new(string.format("Hit %s's $%s$ for $%d$ damage ($%d$ health remaining)", entity.get_player_name(e.target), group:lower(), e.damage, entity.get_prop(e.target, 'm_iHealth')), r, g, b) 


end

local function onMiss(e)
    local group = vars.hitgroup_names[e.hitgroup + 1] or '?'
    local ping = math.min(999, client.real_latency() * 1000)
    local ping_col = (ping >= 100) and { 255, 0, 0 } or { 150, 200, 60 }
    local hc = math.floor(e.hit_chance + 0.5);
    local hc_col = (hc < ui.get(refs.hitChance)) and { 255, 0, 0 } or { 150, 200, 60 };
    e.reason = e.reason == "?" and "resolver" or e.reason
	notifications.new(string.format("Missed %s's $%s$ due to $%s$", entity.get_player_name(e.target), group:lower(), e.reason), 255, 120, 120)
    --	notifications.new(string.format("Hit %s's $%s$ for $%d$ damage ($%d$ health remaining)", entity.get_player_name(e.target), group:lower(), e.damage, entity.get_prop(e.target, 'm_iHealth')), r, g, b) 

end

local aa = {
	ignore = false,
	manualAA= 0,
	input = 0,
}
client.set_event_callback("player_connect_full", function() 
	aa.ignore = false
	aa.manualAA= 0
	aa.input = globals.curtime()
end)

local clantag = {
    steam = steamworks.ISteamFriends,
    prev_ct = "",
    orig_ct = "",
    enb = false,
}

local function get_original_clantag()
    local clan_id = cvar.cl_clanid.get_int()
    if clan_id == 0 then return "\0" end

    local clan_count = clantag.steam.GetClanCount()
    for i = 0, clan_count do 
        local group_id = clantag.steam.GetClanByIndex(i)
        if group_id == clan_id then
            return clantag.steam.GetClanTag(group_id)
        end
    end
end

local prev_simulation_time = 0

local tick = 0
local ticker = 0
local lerp_alpha = 0




local current_tick = func.time_to_ticks(globals.realtime())
client.set_event_callback("setup_command", function(cmd)
    vars.localPlayer = entity.get_local_player()

    if not vars.localPlayer or not entity.is_alive(vars.localPlayer) or not ui.get(masterSwitch) then return end
	local flags = entity.get_prop(vars.localPlayer, "m_fFlags")
    local onground = bit.band(flags, 1) ~= 0 and cmd.in_jump == 0
	local valve = entity.get_prop(entity.get_game_rules(), "m_bIsValveDS")
	local origin = vector(entity.get_prop(vars.localPlayer, "m_vecOrigin"))
	local velocity = vector(entity.get_prop(vars.localPlayer, "m_vecVelocity"))
	local camera = vector(client.camera_angles())
	local eye = vector(client.eye_position())
	local speed = math.sqrt((velocity.x * velocity.x) + (velocity.y * velocity.y) + (velocity.z * velocity.z))
    local weapon = entity.get_player_weapon()
	local pStill = math.sqrt(velocity.x ^ 2 + velocity.y ^ 2) < 5
    local bodyYaw = entity.get_prop(vars.localPlayer, "m_flPoseParameter", 11) * 120 - 60

    local weapon = entity.get_player_weapon(vars.localPlayer)

    local isSlow = ui.get(refs.slow[1]) and ui.get(refs.slow[2])
	local isOs = ui.get(refs.os[1]) and ui.get(refs.os[2])
	local isFd = ui.get(refs.fakeDuck)
	local isDt = ui.get(refs.dt[1]) and ui.get(refs.dt[2])
    local isLegitAA = ui.get(aaBuilder[8].enableState) and client.key_state(0x45)
    local isDefensive = (func.defensive.defensive > 1 and func.defensive.defensive < 14)
    local safeKnife =  func.includes(ui.get(menu.aaTab.lol), "Safe Knife") and entity.get_classname(weapon) == "CKnife"

    -- search for states
    vars.pState = 1
    if pStill then vars.pState = 2 end
    if not pStill then vars.pState = 3 end
    if isSlow then vars.pState = 4 end
    if entity.get_prop(vars.localPlayer, "m_flDuckAmount") > 0.1 then vars.pState = 5 end
    if not onground then vars.pState = 6 end
    if not onground and entity.get_prop(vars.localPlayer, "m_flDuckAmount") > 0.1 then vars.pState = 7 end

    if ui.get(aaBuilder[vars.pState].enableState) == false and vars.pState ~= 1 then
        vars.pState = 1
    end

    if isLegitAA and not vars.should_disable then
        vars.pState = 8
    end

    local nextAttack = entity.get_prop(vars.localPlayer, "m_flNextAttack")
    local nextPrimaryAttack = entity.get_prop(entity.get_player_weapon(vars.localPlayer), "m_flNextPrimaryAttack")
    local dtActive = false
    local isFl = ui.get(ui.reference("AA", "Fake lag", "Enabled"))
    if nextPrimaryAttack ~= nil then
        dtActive = not (math.max(nextPrimaryAttack, nextAttack) > globals.curtime())
    end

    local side_yaw = 2
    if cmd.chokedcommands == 0 then
        vars.choke1 = vars.choke1 + 1
        vars.choke2 = vars.choke2 + 1
        vars.choke3 = vars.choke3 + 1
        vars.choke4 = vars.choke4 + 1
    end
    if vars.choke1 >= 5 then
        vars.choke1 = 0
    end
    if vars.choke2 >= 8 then
        vars.choke2 = 0
    end
    if vars.choke3 >= 8 then
        vars.choke3 = 5
    end

    if globals.tickcount() % ui.get(aaBuilder[vars.pState].yawSpeed) == 1 then
        vars.switch = not vars.switch
    end

    local tickcount = globals.tickcount()

    local side = bodyYaw > 0 and 1 or -1

        -- manual aa
        local isStatic = func.includes(ui.get(menu.aaTab.lol), "Static on Manual")

        ui.set(menu.keys.manualTab.manualLeft, "On hotkey")
        ui.set(menu.keys.manualTab.manualRight, "On hotkey")
        ui.set(menu.keys.manualTab.manualForward, "On hotkey")

        if aa.input + 0.182 < globals.curtime() then
            if aa.manualAA == 0 then
                if ui.get(menu.keys.manualTab.manualLeft) then
                    aa.manualAA = 1
                    aa.input = globals.curtime()    
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))
                elseif ui.get(menu.keys.manualTab.manualRight) then
                    aa.manualAA = 2
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))
                elseif ui.get(menu.keys.manualTab.manualForward) then
                    aa.manualAA = 3
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))   
                end
            elseif aa.manualAA == 1 then
                if ui.get(menu.keys.manualTab.manualRight) then
                    aa.manualAA = 2
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                elseif ui.get(menu.keys.manualTab.manualForward) then
                    aa.manualAA = 3
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                elseif ui.get(menu.keys.manualTab.manualLeft) then
                    aa.manualAA = 0
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                end
            elseif aa.manualAA == 2 then
                if ui.get(menu.keys.manualTab.manualLeft) then
                    aa.manualAA = 1
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                elseif ui.get(menu.keys.manualTab.manualForward) then
                    aa.manualAA = 3
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                elseif ui.get(menu.keys.manualTab.manualRight) then
                    aa.manualAA = 0
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                end
            elseif aa.manualAA == 3 then
                if ui.get(menu.keys.manualTab.manualForward) then
                    aa.manualAA = 0
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                elseif ui.get(menu.keys.manualTab.manualLeft) then
                    aa.manualAA = 1
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                elseif ui.get(menu.keys.manualTab.manualRight) then
                    aa.manualAA = 2
                    aa.input = globals.curtime()
                    ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
                    ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))  
                end
            end

            if aa.manualAA == 1 or aa.manualAA == 2 or aa.manualAA == 3 then
                aa.ignore = true

                if isStatic then
                    ui.set(refs.yawJitter[1], "Off")
                    ui.set(refs.yawJitter[2], 0)
                    ui.set(refs.bodyYaw[1], "Static")
                    ui.set(refs.bodyYaw[2], 180)

                    if aa.manualAA == 1 then
                        ui.set(refs.yawBase, "local view")
                        ui.set(refs.yaw[1], "180")
                        ui.set(refs.yaw[2], -90)
                    elseif aa.manualAA == 2 then
                        ui.set(refs.yawBase, "local view")
                        ui.set(refs.yaw[1], "180")
                        ui.set(refs.yaw[2], 90)
                    elseif aa.manualAA == 3 then
                        ui.set(refs.yawBase, "local view")
                        ui.set(refs.yaw[1], "180")
                        ui.set(refs.yaw[2], 180)
                    end
                elseif not isStatic and ui.get(aaBuilder[vars.pState].enableState) then
                    if ui.get(aaBuilder[vars.pState].yawJitter) == "Sync" then
                        -- ui.set(refs.yawJitter[1], "Center")
                        -- ui.set(refs.yawJitter[2], (side == 1 and ui.get(aaBuilder[vars.pState].yawJitterLeft)*math.random(-1, 1)  or ui.get(aaBuilder[vars.pState].yawJitterRight)*math.random(-1, 1) ))
                        ui.set(refs.yawJitter[1], "Center")
                        local ways = {
                            2,
                            6,
                            10
                        }
                        ui.set(refs.yawJitter[2], ways[(globals.tickcount() % 3) + 1] )
                    elseif ui.get(aaBuilder[vars.pState].yawJitter) == "L & R" then
                        ui.set(refs.yawJitter[1], "Center")
                        ui.set(refs.yawJitter[2], (side == 1 and ui.get(aaBuilder[vars.pState].yawJitterLeft) or ui.get(aaBuilder[vars.pState].yawJitterRight)))
                    else
                        ui.set(refs.yawJitter[1], ui.get(aaBuilder[vars.pState].yawJitter))
                        ui.set(refs.yawJitter[2], ui.get(aaBuilder[vars.pState].yawJitterStatic))
                    end

                    if ui.get(aaBuilder[vars.pState].yawCondition) == "L & R" then
                        ui.set(refs.bodyYaw[1], "Jitter")
                        ui.set(refs.bodyYaw[2], -1)
                    else
                        ui.set(refs.bodyYaw[1], "Static")
                        ui.set(refs.bodyYaw[2], -180)
                    end

                    if aa.manualAA == 1 then
                        ui.set(refs.yawBase, "local view")
                        ui.set(refs.yaw[1], "180")
                        ui.set(refs.yaw[2], -90)
                    elseif aa.manualAA == 2 then
                        ui.set(refs.yawBase, "local view")
                        ui.set(refs.yaw[1], "180")     
                        ui.set(refs.yaw[2], 90)
                    elseif aa.manualAA == 3 then
                        ui.set(refs.yawBase, "local view")
                        ui.set(refs.yaw[1], "180")
                        ui.set(refs.yaw[2], 180)
                    end
                end
            else
                aa.ignore = false
            end
        elseif aa.input > globals.curtime() then
        --    aa.ignore = false
        --    aa.manualAA = 0
            aa.input = globals.curtime()
        end

    -- check height advantage and head safety
    local heightAdvantage = false
    local safetyAlert = false
    local enemies = entity.get_players(true)
	for i=1, #enemies do
        if entity.is_dormant(enemies[i]) then heightAlert = false sidewaysAlert = false return end
		local playerX, playerY, playerZ  = entity.get_prop(enemies[i], "m_vecOrigin")
		local playerFlags = entity.get_prop(enemies[i], "m_fFlags")
		local playerOnGround = bit.band(playerFlags, 1) ~= 0
		local lengthDistance = math.sqrt((playerX - origin.x)^2 + (playerY - origin.y)^2 + (playerZ - origin.z)^2)
		if ((playerZ + 100 < origin.z) and lengthDistance <= 300) then
			heightAdvantage = true
		else
			heightAdvantage = false
		end

        if ((bodyYaw >= 40 or bodyYaw <= -40) and func.headVisible(enemies[i])) then
			safetyAlert = true
		else
			safetyAlert = false
		end
	end

    if ui.get(aaBuilder[vars.pState].enableState) then
        if ui.get(aaBuilder[vars.pState].enabledefensive) and ui.get(refs.dt[1]) and ui.get(refs.dt[2]) then
            if ui.get(aaBuilder[vars.pState].defensiveOpt) == "None" and ui.get(refs.dt[1]) and ui.get(refs.dt[2]) then
                cmd.force_defensive = false
            else
            cmd.force_defensive = globals.tickcount() % 20 < 3
            end
        end
        
        if ui.get(aaBuilder[vars.pState].defensiveOpt) == "Time to ticks" then
            if ui.get(aaBuilder[vars.pState].defensiveOpt) == "None" and not ui.get(refs.dt[1]) and not ui.get(refs.dt[2])  then
                cmd.force_defensive = false
            else
            cmd.force_defensive = globals.tickcount() % 10 < 3
            end
        end

        if ui.get(aaBuilder[vars.pState].defensiveOpt) == "Hold Ticks" then
            if ui.get(aaBuilder[vars.pState].defensiveOpt) == "None" and not ui.get(refs.dt[1]) and not ui.get(refs.dt[2])  then
                cmd.force_defensive = false
            else
            cmd.force_defensive = globals.tickcount() % 15 < 3
            end
        end
        
        
        if cmd.chokedcommands > 1 then
            cmd.allow_send_packet = false
        else
            cmd.allow_send_packet = true
        end
        
        
        if cmd.force_defensive == true then isDefensive = true end
        
        
        if aa.ignore then return end
        
        if ui.get(aaBuilder[vars.pState].defensivePitch) == "Custom" and isDefensive then
            ui.set(refs.pitch[1], "Custom")
            ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].defensivePitchSlider))
        elseif ui.get(aaBuilder[vars.pState].defensivePitch) == "Random" and isDefensive then
            ui.set(refs.pitch[1], "Custom")
            ui.set(refs.pitch[2], math.random(-89,89))
        elseif ui.get(aaBuilder[vars.pState].defensivePitch) == "Up" and isDefensive then
            ui.set(refs.pitch[1], "up")
        elseif ui.get(aaBuilder[vars.pState].defensivePitch) == "Swap" and isDefensive then
            ui.set(refs.pitch[1], "Custom")
            ui.set(refs.pitch[2], math.random(39, -39))
        else
            ui.set(refs.pitch[1], ui.get(aaBuilder[vars.pState].pitch))
            ui.set(refs.pitch[2], ui.get(aaBuilder[vars.pState].pitchSlider))
        end    
        
        
        ui.set(refs.yawBase, ui.get(aaBuilder[vars.pState].yawBase))
        
        ui.set(refs.yaw[1], ui.get(aaBuilder[vars.pState].yaw))
        
        if ui.get(aaBuilder[vars.pState].defensiveYaw) == "Jitter" and isDefensive then
            ui.set(refs.yaw[2], tickcount % 3 == 0 and client.random_int(90, -90) or tickcount % 3 == 1 and 180 or tickcount % 3 == 2 and client.random_int(-90, 90) or 0)
        elseif ui.get(aaBuilder[vars.pState].defensiveYaw) == "Custom" and isDefensive then
            ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].defensiveYawSlider))
        elseif ui.get(aaBuilder[vars.pState].defensiveYaw) == "Spin" and isDefensive then
            ui.set(refs.yaw[1], "Spin")
        elseif ui.get(aaBuilder[vars.pState].defensiveYaw) == "Flick" and isDefensive then
        --    ui.set(refs.yawJitter[2], ui.get(aaBuilder[vars.pState].yawJitterStatic)*math.random(-1, 1) )
            ui.set(refs.pitch[1], "up")
            ui.set(refs.yaw[2], (globals.tickcount() % 6 > 3) and 111 or -111)
        elseif ui.get(aaBuilder[vars.pState].defensiveYaw) == "Slow Jitter" and isDefensive then
            ui.set(refs.yaw[2], switch and ui.get(aaBuilder[vars.pState].yawJitterRight) or ui.get(aaBuilder[vars.pState].yawJitterLeft))
        elseif ui.get(aaBuilder[vars.pState].yawCondition) == "L & R" then

            ui.set(refs.yaw[2],(side == 1 and ui.get(aaBuilder[vars.pState].yawLeft) or ui.get(aaBuilder[vars.pState].yawRight)))

        elseif ui.get(aaBuilder[vars.pState].yawCondition) == "Tickbased" then

            if vars.choke2 == 0 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawRight))
            elseif vars.choke2 == 1 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawLeft))
            elseif vars.choke2 == 2 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawLeft))
            elseif vars.choke2 == 3 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawLeft))
            elseif vars.choke2 == 4 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawRight))
            elseif vars.choke2 == 5 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawLeft))
            elseif vars.choke2 == 6 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawRight))
            elseif vars.choke2 == 7 then
                ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawRight))
            end

            

        elseif ui.get(aaBuilder[vars.pState].yawCondition) == "Delay" then
            ui.set(refs.yaw[1], "180")
            ui.set(refs.yaw[2], vars.switch and ui.get(aaBuilder[vars.pState].yawLeft) or ui.get(aaBuilder[vars.pState].yawRight))
            side_yaw = 0
        else
            ui.set(refs.yaw[2], ui.get(aaBuilder[vars.pState].yawStatic))
            side_yaw = 2
        end

        local switch = false
        if ui.get(aaBuilder[vars.pState].yawJitter) == "Sync" then
            ui.set(refs.yawJitter[1], "Center")
        elseif ui.get(aaBuilder[vars.pState].yawJitter) == "TabJitter" then
            ui.set(refs.yawJitter[1], "Center")
            ui.set(refs.yawJitter[2], (side == 1 and ui.get(aaBuilder[vars.pState].yawJitterLeft) or ui.get(aaBuilder[vars.pState].yawJitterRight)) * math.random(-10, 10))
        else
            ui.set(refs.yawJitter[1], ui.get(aaBuilder[vars.pState].yawJitter))
        end
        if ui.get(aaBuilder[vars.pState].yawJitterCondition) == "L & R" then
            if ui.get(aaBuilder[vars.pState].yawJitter) == "Sync" then
                ui.set(refs.yawJitter[2], (side == 1 and ui.get(aaBuilder[vars.pState].yawJitterLeft)*math.random(-1, 1)  or ui.get(aaBuilder[vars.pState].yawJitterRight)*math.random(-1, 1) ))
            elseif ui.get(aaBuilder[vars.pState].yawJitter) == "Slow Jitter" then
                ui.set(refs.yaw[2], switch and ui.get(aaBuilder[vars.pState].yawJitterRight) or ui.get(aaBuilder[vars.pState].yawJitterLeft))
            else
                ui.set(refs.yawJitter[2], (side == 1 and ui.get(aaBuilder[vars.pState].yawJitterLeft) or ui.get(aaBuilder[vars.pState].yawJitterRight)))
            end
            
        else
            if  ui.get(aaBuilder[vars.pState].yawJitter) == "Sync" then
                ui.set(refs.yawJitter[2], ui.get(aaBuilder[vars.pState].yawJitterStatic)*math.random(-1, 1) )
            elseif ui.get(aaBuilder[vars.pState].yawJitter) == "Slow Jitter" then
                ui.set(refs.yaw[2], switch and ui.get(aaBuilder[vars.pState].yawJitterStatic) or -ui.get(aaBuilder[vars.pState].yawJitterStatic))
            else
                ui.set(refs.yawJitter[2], ui.get(aaBuilder[vars.pState].yawJitterStatic) )
            end
        end
        
        if ui.get(aaBuilder[vars.pState].yawCondition) == "Delay" then
            ui.set(refs.bodyYaw[1], "Static")
            ui.set(refs.bodyYaw[2], 0)
        elseif ui.get(aaBuilder[vars.pState].yawCondition) == "Tickbased" then
            ui.set(refs.bodyYaw[1], "Static")
            ui.set(refs.bodyYaw[2], 0)
        else
            ui.set(refs.bodyYaw[1], ui.get(aaBuilder[vars.pState].bodyYaw))
            ui.set(refs.bodyYaw[2], ui.get(aaBuilder[vars.pState].bodyYawSlider))
        end

        if reversed and ui.get(aaBuilder[vars.pState].antiBruteSet) then
            ui.set(refs.yaw[2], angle)
        end

        ui.set(refs.fsBodyYaw, false)
    elseif not ui.get(aaBuilder[vars.pState].enableState) then
        ui.set(refs.pitch[1], "Off")
        ui.set(refs.yawBase, "Local view")
        ui.set(refs.yaw[1], "Off")
        ui.set(refs.yaw[2], 0)
        ui.set(refs.yawJitter[1], "Off")
        ui.set(refs.yawJitter[2], 0)
        ui.set(refs.bodyYaw[1], "Off")
        ui.set(refs.bodyYaw[2], 0)
        ui.set(refs.fsBodyYaw, false)
        ui.set(refs.edgeYaw, false)
        ui.set(refs.roll, 0)
    end

    --safe safe
    if func.includes(ui.get(menu.aaTab.lol), "Safe Knife") then
        if entity.get_classname(entity.get_player_weapon(entity.get_local_player())) == "CKnife" and vars.pState == 7 then
            ui.set(refs.pitch[1], "Default")
            ui.set(refs.yawBase, "At targets")
            ui.set(refs.yaw[1], "180")
            ui.set(refs.yaw[2], 0)
            ui.set(refs.yawJitter[1], "Off")
            ui.set(refs.yawJitter[2], 0)
            ui.set(refs.bodyYaw[1], "Static")
            ui.set(refs.bodyYaw[2], 0)
            ui.set(refs.fsBodyYaw, false)
            ui.set(refs.edgeYaw, false)
            ui.set(refs.roll, 0)
        end
    end

    -- -- fix hideshots
	-- if ui.get(menu.aaTab.fixHideshots) then
	-- 	if isOs and not isDt and not isFd then
    --         if not hsSaved then
    --             hsValue = ui.get(refs.fakeLag[1])
    --             hsSaved = true
    --         end
	-- 		ui.set(refs.fakeLag[1], 1)
	-- 	elseif hsSaved then
	-- 		ui.set(refs.fakeLag[1], hsValue)
    --         hsSaved = false
	-- 	end
	-- end

    distance_knife = {}
    distance_knife.anti_knife_dist = function (x1, y1, z1, x2, y2, z2)
        return math.sqrt((x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2)
    end

----resolver 


    -- Avoid backstab
    if  func.includes(ui.get(menu.aaTab.lol), "Avoid Backstab") then
        local players = entity.get_players(true)
        local lx, ly, lz = entity.get_prop(entity.get_local_player(), "m_vecOrigin")
        if players == nil then return end
        for i=1, #players do
            local x, y, z = entity.get_prop(players[i], "m_vecOrigin")
            local distance = distance_knife.anti_knife_dist(lx, ly, lz, x, y, z)
            local weapon = entity.get_player_weapon(players[i])
            if entity.get_classname(weapon) == "CKnife" and distance <= 200 then
                ui.set(refs.yaw[2], 180)
                ui.set(refs.yawBase, "At targets")
            end
        end
    end
    
    
    -- fast ladder
    if ui.get(menu.miscTab.fastLadderEnabled) then
        local pitch, yaw = client.camera_angles()
        if entity.get_prop(vars.localPlayer, "m_MoveType") == 9 then
            cmd.yaw = math.floor(cmd.yaw+0.5)
            cmd.roll = 0
    
            if func.includes(ui.get(menu.miscTab.fastLadder), "Ascending") then
                if cmd.forwardmove > 0 then
                    if pitch < 45 then
                        cmd.pitch = 89
                        cmd.in_moveright = 1
                        cmd.in_moveleft = 0
                        cmd.in_forward = 0
                        cmd.in_back = 1
                        if cmd.sidemove == 0 then
                            cmd.yaw = cmd.yaw + 90
                        end
                        if cmd.sidemove < 0 then
                            cmd.yaw = cmd.yaw + 150
                        end
                        if cmd.sidemove > 0 then
                            cmd.yaw = cmd.yaw + 30
                        end
                    end 
                end
            end
            if func.includes(ui.get(menu.miscTab.fastLadder), "Descending") then
                if cmd.forwardmove < 0 then
                    cmd.pitch = 89
                    cmd.in_moveleft = 1
                    cmd.in_moveright = 0
                    cmd.in_forward = 1
                    cmd.in_back = 0
                    if cmd.sidemove == 0 then
                        cmd.yaw = cmd.yaw + 90
                    end
                    if cmd.sidemove > 0 then
                        cmd.yaw = cmd.yaw + 150
                    end
                    if cmd.sidemove < 0 then
                        cmd.yaw = cmd.yaw + 30
                    end
                end
            end
        end
    end

    -- edgeyaw
    ui.set(refs.edgeYaw, ui.get(menu.keys.edgeYawHotkey))
end)

client.set_event_callback("setup_command", function(e)
    if not vars.localPlayer or not entity.is_alive(vars.localPlayer) or not ui.get(masterSwitch) then return end
	local flags = entity.get_prop(vars.localPlayer, "m_fFlags")
    local onground = bit.band(flags, 1) ~= 0 and e.in_jump == 0
    local isSlow = ui.get(refs.slow[1]) and ui.get(refs.slow[2])

    local Aero = func.includes(ui.get(menu.keys.freestandDisablers), "Aero") and not onground
    local duck = func.includes(ui.get(menu.keys.freestandDisablers), "Duck") and entity.get_prop(vars.localPlayer, "m_flDuckAmount") > 0.1
    local manul = func.includes(ui.get(menu.keys.freestandDisablers), "Manual") and (aa.manualAA == 2 or aa.manualAA == 1) and aa.ignore
    local fs_disabler = Aero or duck

    if ui.get(menu.keys.freestandHotkey) and not fs_disabler then
        vars.fs = true
        ui.set(refs.freeStand[2], "Always on")
        ui.set(refs.freeStand[1], true)
    else
        vars.fs = false
        ui.set(refs.freeStand[1], false)
        ui.set(refs.freeStand[2], "On hotkey")
    end    
end)

client.set_event_callback("setup_command", function(cmd)
    local using = true
    local defusing = false
    vars.should_disable = false

    if entity.get_classname(entity.get_player_weapon(vars.localPlayer)) == "CC4" then
        vars.should_disable = true
        return
    end

    local planted_bomb = entity.get_all("CPlantedC4")[1]
    local classnames = {"CWorld","CCSPlayer","CFuncBrush","CPropDoorRotating","CHostage"}

    if planted_bomb ~= nil then
        local bomb_distance = vector(entity.get_origin(vars.localPlayer)):dist(vector(entity.get_origin(planted_bomb)))
        
        if bomb_distance <= 64 and entity.get_prop(vars.localPlayer, "m_iTeamNum") == 3 then
            vars.should_disable = true
            defusing = true
        end
    end

    local pitch, yaw = client.camera_angles()
    local direct_vec = vector(func.vec_angles(pitch, yaw))

    local eye_pos = vector(client.eye_position())
    local fraction, ent = client.trace_line(vars.localPlayer, eye_pos.x, eye_pos.y, eye_pos.z, eye_pos.x + (direct_vec.x * 8192), eye_pos.y + (direct_vec.y * 8192), eye_pos.z + (direct_vec.z * 8192))

    local using = true

    if ent ~= nil and ent ~= -1 then
        for i=0, #classnames do
            if entity.get_classname(ent) == classnames[i] then
                using = false
            end
        end
    end

    if not vars.should_disable and client.key_state(0x45) and not using and not defusing and ui.get(aaBuilder[8].enableState) then
        cmd.in_use = 0
    end

--    local key = ui.get(menu.aaTab.BombEfix)
end)




-- local function clantag_set()
--     local lua_name = "#T@b$eNsE"
--     if ui.get(menu.miscTab.clanTag) then
--         if ui.get(ui.reference("Misc", "Miscellaneous", "Clan tag spammer")) then return end

-- 		local clan_tag = clantag_anim(lua_name, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 11, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25})

--         if entity.get_prop(entity.get_game_rules(), "m_gamePhase") == 5 then
--             clan_tag = clantag_anim('#T@b$eNsE', {13})
--             client.set_clan_tag(clan_tag)
--         elseif entity.get_prop(entity.get_game_rules(), "m_timeUntilNextPhaseStarts") ~= 0 then
--             clan_tag = clantag_anim('#T@b$eNsE', {13})
--             client.set_clan_tag(clan_tag)
--         elseif clan_tag ~= clantag.prev_ct  then
--             client.set_clan_tag(clan_tag)
--         end

--         clantag.prev_ct = clan_tag
--         clantag.enb = true
--     elseif clantag.enb == true then
--         client.set_clan_tag(get_original_clantag())
--         clantag.enb = false
--     end
-- end

-- clantag.paint = function()
--     if entity.get_local_player() ~= nil then
--         if globals.tickcount() % 2 == 0 then
--             clantag_set()
--         end
--     end
-- end

-- clantag.run_command = function(e)
--     if entity.get_local_player() ~= nil then 
--         if e.chokedcommands == 0 then
--             clantag_set()
--         end
--     end
-- end

-- clantag.player_connect_full = function(e)
--     if client.userid_to_entindex(e.userid) == entity.get_local_player() then 
--         clantag.orig_ct = get_original_clantag()
--     end
-- end

-- clantag.shutdown = function()
--     client.set_clan_tag(get_original_clantag())
-- end

-- client.set_event_callback("paint", clantag.paint)
-- client.set_event_callback("run_command", clantag.run_command)
-- client.set_event_callback("player_connect_full", clantag.player_connect_full)
-- client.set_event_callback("shutdown", clantag.shutdown)

ui.set_callback(menu.miscTab.trashTalk, function() 
    local callback = ui.get(menu.miscTab.trashTalk) and client.set_event_callback or client.unset_event_callback
    callback('player_death', trashtalk)
end)

ui.set_callback(menu.visualsTab.logs, function() 
    local callback = ui.get(menu.visualsTab.logs) and client.set_event_callback or client.unset_event_callback
    callback("aim_miss", onMiss)
    callback("aim_hit", onHit)
end)

client.set_event_callback("player_death", function(e)
    local v, a = e.userid, e.attacker
    local lp_death = client.userid_to_entindex(v)
    if lp_death ~= entity.get_local_player() then return end
    client.delay_call(1, notifications.clear)
end)

client.set_event_callback("player_connect_full", function(e)
    if client.userid_to_entindex(e.userid) == entity.get_local_player() then 
        notifications.clear()
    end
end)

local legsTypes = {[1] = "Off", [2] = "Always slide", [3] = "Never slide"}
local ground_ticks = 0
client.set_event_callback("setup_command", function(e)
    local is_on_ground = e.in_jump == 0
    if func.includes(ui.get(menu.miscTab.animations), "Leg fucker") then
        if func.includes(ui.get(menu.miscTab.animations), "Leg fucker") then
            ui.set(refs.legMovement, e.command_number % 3 == 0 and "Off" or "Always slide")
        end
    end
end)

function rgba_to_hex(b,c,d,e)
    return string.format('%02x%02x%02x%02x',b,c,d,e)
end

client.set_event_callback("pre_render", function()
    local lp = entity.get_local_player()
    if not lp then return end
    if ui.get(menu.miscTab.animationsEnabled) == false then return end
    local flags = entity.get_prop(lp, "m_fFlags")
    ground_ticks = bit.band(flags, 1) == 0 and 0 or (ground_ticks < 5 and ground_ticks + 1 or ground_ticks)

    if func.includes(ui.get(menu.miscTab.animations), "Break legs while in Aero") and bit.band(flags, 1) == 0 then
        entity.set_prop(lp, "m_flPoseParameter", 1, 6) 
    end

    if func.includes(ui.get(menu.miscTab.animations), "Leg fucker") then
        entity.set_prop(lp, "m_flPoseParameter", 1, globals.tickcount() % 4 > 1 and 5 / 10 or 1)
    end

    if func.includes(ui.get(menu.miscTab.animations), "Reset pitch on land") then
        ground_ticks = bit.band(flags, 1) == 1 and ground_ticks + 1 or 0

        if ground_ticks > 20 and ground_ticks < 150 then
            entity.set_prop(lp, "m_flPoseParameter", 0.5, 12)
        end
    end

    if func.includes(ui.get(menu.miscTab.animations), "Be Micheal Jackson") then
        entity.set_prop(lp, "m_flPoseParameter", 1, 7)
        ui.set(refs.legMovement, "Never slide")
    end
    
end)


-- @region AA_CALLBACKS end

-- @region INDICATORS start
local alpha = 0
local scopedFraction = 0
local scopedFraction2 = 0
local defensiveFraction = 0
local activeFraction = 0
local inactiveFraction = 0
local hideFraction = 0
local hideInactiveFraction = 0
local dtPos = {y = 0}
local osPos = {y = 0}

local mainIndClr = {r = 0, g = 0, b = 0, a = 0}
local dtClr = {r = 0, g = 0, b = 0, a = 0}
local chargeClr = {r = 0, g = 0, b = 0, a = 0}
local chargeInd = {w = 0, x = 0, y = 25}
local psClr = {r = 0, g = 0, b = 0, a = 0}
local dtInd = {w = 0, x = 0, y = 25}
local qpInd = {w = 0, x = 0, y = 25, a = 0}
local fdInd = {w = 0, x = 0, y = 25, a = 0}
local spInd = {w = 0, x = 0, y = 25, a = 0}
local baInd = {w = 0, x = 0, y = 25, a = 0}
local fsInd = {w = 0, x = 0, y = 25, a = 0}
local osInd = {w = 0, x = 0, y = 25, a = 0}
local psInd = {w = 0, x = 0, y = 25}
local wAlpha = 0
local value = 0
local once1 = false
local once2 = false
local dt_a = 0
local dt_y = 45
local dt_x = 0
local dt_w = 0
local os_a = 0
local os_y = 45
local os_x = 0
local os_w = 0
local fs_a = 0
local fs_y = 45
local fs_x = 0
local fs_w = 0
local n_x = 0
local n2_x = 0
local n3_x = 0
local n4_x = 0
local testx = 0
local aaa = 0
local lele = 0
local hitler = {}
hitler.lerp = function(start, vend, time)
    return start + (vend - start) * time
end

function normalize_yaw(yaw)
	while yaw > 180 do yaw = yaw - 360 end
	while yaw < -180 do yaw = yaw + 360 end
	return yaw
end

function ang_on_screen(x, y)
	if x == 0 and y == 0 then return 0 end

	return math.deg(math.atan2(y, x))
end

local best_enemy = nil
function get_best_enemy()
    best_enemy = nil

    local enemies = entity.get_players(true)
    local best_fov = 180

    local lx, ly, lz = client.eye_position()
    local view_x, view_y, roll = client.camera_angles()
    
    for i=1, #enemies do
        local cur_x, cur_y, cur_z = entity.get_prop(enemies[i], "m_vecOrigin")
        local cur_fov = math.abs(normalize_yaw(ang_on_screen(lx - cur_x, ly - cur_y) - view_y + 180))
        if cur_fov < best_fov then
            best_fov = cur_fov
            best_enemy = enemies[i]
        end
    end
end

client.set_event_callback("setup_command", function()
    defensive_indicator()
end)

client.set_event_callback("paint", function()
    local local_player = entity.get_local_player()
    if local_player == nil or entity.is_alive(local_player) == false then return end
    local sizeX, sizeY = client.screen_size()
    local weapon = entity.get_player_weapon(local_player)
    local bodyYaw = entity.get_prop(local_player, "m_flPoseParameter", 11) * 120 - 60
    local side = bodyYaw > 0 and 1 or -1
    local state = vars.intToS[vars.pState]:upper()
    local mainClr = {}
    mainClr.r, mainClr.g, mainClr.b, mainClr.a = ui.get(menu.visualsTab.indicatorsClr)
    local arrowClr = {}
    arrowClr.r, arrowClr.g, arrowClr.b, arrowClr.a = ui.get(menu.visualsTab.arrowClr)
    local fake = math.floor(antiaim_funcs.get_desync(1))
    local isDefensive = (func.defensive.defensive > 1 and func.defensive.defensive < 14)

    local function get_velocity(player)
        local x, y, z = entity.get_prop(player, "m_vecVelocity")
        if x == nil then
            return
        end
        return math.sqrt(x * x + y * y + z * z)
    end
    
    local function clamp(value, minVal, maxVal)
        return math.max(minVal, math.min(value, maxVal))
    end




    local aa_functions = {
        aa_number = "Stand",
        jitter_way_number = 1,
        old_weapon = 0,
        actual_weapon = 0,
        actual_tick = 0,
        to_start = false,
        to_jitter = false,  
        bomb_was_bombed = false,
        bomb_was_defused = false,
        can_defensive = false,
        def_ticks = 0,
    }

    local prev_simulation_time = 0
    function aa_functions:sim_diff() 
        local current_simulation_time = math.floor(0.5 + (entity.get_prop(entity.get_local_player(), "m_flSimulationTime") / globals.tickinterval())) 
        local diff = current_simulation_time - prev_simulation_time
        prev_simulation_time = current_simulation_time
        return diff
    end
      
    local indicators = 0

    local function gradient_text(text, col, speed)
        local final_text = ''
        local curtime = globals.curtime()
        local r, g, b, a = col.r, col.g, col.b, col.a
        local center = math.floor(#text / 2) + 1  -- calculate the center of the text
        for i=1, #text do
            -- calculate the distance from the center character
            local distance = math.abs(i - center)
            -- calculate the alpha based on the distance and the speed and time
            a = 255 - math.abs(255 * math.sin(speed * curtime / 4 - distance * 4 / 20))
            local col = color.new(r, g, b, a):hex()
            final_text = final_text .. '\a' .. col .. text:sub(i, i)
        end
        return final_text
    end

    local watermarkClr = {}
    watermarkClr.r, watermarkClr.g, watermarkClr.b = ui.get(menu.visualsTab.watermarkClr)

    local w,h = client.screen_size()
    local wm = { ui.get(menu.visualsTab.watermarkClr) }
    local float = math.sin(globals.realtime() * 2.3) * 15

    local screensize = { client.screen_size() };
    local center = { screensize[1] / 2, screensize[2] / 2 };
    local x = center[1]
    local y = center[2]
    local width2 = vector(renderer.measure_text('cb', gradient_text("TABSENSE",color.new(wm[1], wm[2], wm[3], wm[4]), 5),"", " ["..string.upper(login.build), "]"))
    local x = (screensize[1] - width2.x) / 2;
    local y = screensize[2] / 1.019;


    function text_fade_animation(speed, r, g, b, a, text)
        local final_text = ''
        local curtime = globals.curtime()
        for i=0, #text do
            local color = rgba_to_hex(r, g, b, a*math.abs(1*math.cos(2*speed*curtime/4+i*5/30)))
            final_text = final_text..'\a'..color..text:sub(i, i)
        end
        return final_text
    end
    
    function text_fade_animation_guwno(speed, r, g, b, a, text)
        local final_text = ''
        local curtime = globals.curtime()
        for i = 0, #text do
            local color = rgba_to_hex(r, g, b, a * math.abs(1 * math.cos(2 * speed * curtime / 4 - i * 5 / 30)))
            final_text = final_text .. '\a' .. color .. text:sub(i, i)
        end
        return final_text
    end
    
    if ui.get(menu.visualsTab.watermark) then
        local watermark_colorek = {}
        local r,g,b = wm[1], wm[2], wm[3]

        local text = "\affffffe5tab\a"..rgba_to_hex(r,g,b,230).."sense\affffffe5 | "..login.username..""
        if func.includes(ui.get(menu.visualsTab.watermark_og_opt), "fps") then
            text = text .. " | " .. get_fps() .. " fps"
        end
        
        if func.includes(ui.get(menu.visualsTab.watermark_og_opt), "ping") then
            local fr_r, fr_g, fr_b = lerp_color_yellow_red(client.latency(), 210, 240, 300, {255,255,255})
            text = text .. " | \a"..rgba_to_hex(fr_r,fr_g,fr_b,229).."".. round(client.latency()*1000, 0) .. "ms\affffffe5"
        end

        if func.includes(ui.get(menu.visualsTab.watermark_og_opt), "time") then
            local hours, minutes, seconds, milliseconds = client.system_time()
            hours, minutes = string.format("%02d", hours), string.format("%02d", minutes)
            text = text .. " | ".. hours .. ":" .. minutes .. ""
        end

        local text_size = vector(renderer.measure_text("", text))

        render_ogskeet_border(X - text_size.x - 20, 55, text_size.x + 2, 12, 255, text)
    else
       local text = "\a"..rgba_to_hex(wm[1], wm[2], wm[3], 220).."T A B "..text_fade_animation_guwno(2,255,255,255,220,"S E N S E") .."\a"..rgba_to_hex(wm[1], wm[2], wm[3], 220).." ["..string.upper(login.build).. "]"
       local text_size = vector(renderer.measure_text("c", text))
       if ui.get(menu.visualsTab.watermark_opt) then
        text = text:gsub(" ", "")
       end

       if ui.get(menu.visualsTab.watermark_pos) == "left" then
        renderer.text(text_size.x/2+10, Y/2 - 10, 255 , 255, 255, 255, "c",  nil, text)
       elseif ui.get(menu.visualsTab.watermark_pos) == "right" then
        renderer.text(X - text_size.x /2 - 10, Y/2 - 10, 255 , 255, 255, 255, "c",  nil, text)
       elseif ui.get(menu.visualsTab.watermark_pos) == "bottom" then  
        renderer.text(X / 2, Y - 15, 255 , 255, 255, 255, "c",  nil, text)
       elseif ui.get(menu.visualsTab.watermark_pos) == "top" then
        renderer.text(X / 2, 70, 255 , 255, 255, 255, "c",  nil, text)
       end
    end



    if func.includes(ui.get(menu.visualsTab.defensive_indicator), "Defensive") then
        icon_size = 30
    
        local r,g,b,a = ui.get(menu.visualsTab.defensive_indicatorClr)

        if to_draw == "yes" then
    
            draw_art = to_draw_ticks * 100 / 40
        
            renderer.text(X / 2 , Y / 2  * 0.5 - 10 , 255, 255, 255, 255, "c", 0, string.format("\aFFFFFFFFdefensive \a%schoking", rgba_to_hex(255, 255, 255, 255)))
            script.renderer:glow_module(X / 2 - 50, Y / 2  * 0.5,100,3, 14,2,{r,g,b,50}, {30,30,30,255})
            renderer.rectangle(X / 2, Y / 2  * 0.5 +1,draw_art / 2,2,r,g,b,255)
            renderer.rectangle(X / 2, Y / 2  * 0.5 + 1,-draw_art / 2,2,r,g,b,255)
            --renderer.rectangle(w / 2 - 55, h / 2  - 265, 110, 10, 8, 8, 8, lerp_alpha <= 150 and lerp_alpha or 150)
           -- renderer.texture(tex_id, w / 2 - 55, h / 2 - 265, 110,10, 255, 255, 255, 255, "r")
            --renderer.texture(tex_id, w / 2 - 55, h / 2 - 262, 110,10, 255, 255, 255, 255, "r")
            --renderer.text(w / 2 - 2, h / 2 - 240 ,255,255,255,lerp_alpha,"c-",0, isDefensive and " DEFENSIVE ")
            --renderer.gradient(w / 2 -55, h / 2 - 265 , 110,1, 59, 175, 222, 255, 202, 70, 205, 255,true)
           -- renderer.gradient(w / 2 -55, h / 2 - 252 , 110,1, 59, 175, 222, 255, 202, 70, 205, 255,true)
            logo:draw(X / 2 - icon_size / 2, Y / 2 * 0.46 - (icon_size/2), icon_size, nil, r,g,b,a, true)
    

            if to_draw_ticks == 39 then
                to_draw_ticks = 0
                to_draw = "no"
                lerp_alpha = lerp(lerp_alpha,0, globals.frametime() * 30)
            end
            to_draw_ticks = to_draw_ticks + 1
            ---print(to_draw_ticks)
        end
    end

    calculatePercentage = function(ticks, przez)
        local percentage = (ticks / przez) * 100
        return percentage
    end

    if func.includes(ui.get(menu.visualsTab.defensive_indicator), "Slowdown") then
        local is_defensive = to_draw == "yes" and ui.get(refs.dt[2])
        local slowed_down_value = entity.get_prop(entity.get_local_player(),"m_flVelocityModifier") * 100
        local size_bar = slowed_down_value * 98 / 100
        local r,g,b,a = ui.get(menu.visualsTab.defensive_indicatorClr)

        if slowed_down_value < 100 then
            renderer.text(X / 2 , is_defensive and Y / 2 * 0.55 - 10 or Y / 2  * 0.5 - 10 , 255, 255, 255, 255, "c", 0, string.format("\aFFFFFFFFslowed down \aFFFFFFFF(\a%s%s%%\aFFFFFFFF)", rgba_to_hex(255,255,255, 255), math.floor(calculatePercentage(size_bar, 100))))
            --renderer.rectangle(X / 2 - 50, Y / 2  * 0.5 + 0.3,100,4,50,50,50,255)
            --ctx.m_render:glow_module(X / 2 - 50, is_defensive and Y / 2 * 0.55 or Y / 2 * 0.5,100,3, 14,2,{r,g,b,50}, {30,30,30,255})
            script.renderer:glow_module(X / 2 - 50, is_defensive and Y / 2 * 0.55 or Y / 2 * 0.5,100,3, 14,2,{r,g,b,50}, {30,30,30,255})
            renderer.rectangle(X / 2, is_defensive and Y / 2 * 0.55 + 1 or Y / 2 * 0.5 + 1,size_bar / 2,2,r,g,b,255)
            renderer.rectangle(X / 2, is_defensive and Y / 2 * 0.55 + 1 or Y / 2 * 0.5 + 1,-size_bar / 2,2,r,g,b,255)
        end
    end

    if ui.is_menu_open() then
        local is_defensive = true
        local slowed_down_value = entity.get_prop(entity.get_local_player(),"m_flVelocityModifier") * 100
        local size_bar = to_draw_ticks * 100 / 40
        local r,g,b,a = ui.get(menu.visualsTab.defensive_indicatorClr)


        renderer.text(X / 2 , is_defensive and Y / 2 * 0.55 - 10 or Y / 2  * 0.5 - 10 , 255, 255, 255, 255, "c", 0, string.format("\aFFFFFFFFslowed down \aFFFFFFFF(\a%s%s%%\aFFFFFFFF)", rgba_to_hex(255,255,255, 255), math.floor(calculatePercentage(size_bar, 100))))
        --renderer.rectangle(X / 2 - 50, Y / 2  * 0.5 + 0.3,100,4,50,50,50,255)
        --ctx.m_render:glow_module(X / 2 - 50, is_defensive and Y / 2 * 0.55 or Y / 2 * 0.5,100,3, 14,2,{r,g,b,50}, {30,30,30,255})
        script.renderer:glow_module(X / 2 - 50, is_defensive and Y / 2 * 0.55 or Y / 2 * 0.5,100,3, 14,2,{r,g,b,50}, {30,30,30,255})
        renderer.rectangle(X / 2, is_defensive and Y / 2 * 0.55 + 1 or Y / 2 * 0.5 + 1,size_bar / 2,2,r,g,b,255)
        renderer.rectangle(X / 2, is_defensive and Y / 2 * 0.55 + 1 or Y / 2 * 0.5 + 1,-size_bar / 2,2,r,g,b,255)


        draw_art = to_draw_ticks * 100 / 40
        
        renderer.text(X / 2 , Y / 2  * 0.5 - 10 , 255, 255, 255, 255, "c", 0, string.format("\aFFFFFFFFdefensive \a%schoking", rgba_to_hex(255, 255, 255, 255)))
        script.renderer:glow_module(X / 2 - 50, Y / 2  * 0.5,100,3, 14,2,{r,g,b,50}, {30,30,30,255})
        renderer.rectangle(X / 2, Y / 2  * 0.5 +1,draw_art / 2,2,r,g,b,255)
        renderer.rectangle(X / 2, Y / 2  * 0.5 + 1,-draw_art / 2,2,r,g,b,255)
        --renderer.rectangle(w / 2 - 55, h / 2  - 265, 110, 10, 8, 8, 8, lerp_alpha <= 150 and lerp_alpha or 150)
       -- renderer.texture(tex_id, w / 2 - 55, h / 2 - 265, 110,10, 255, 255, 255, 255, "r")
        --renderer.texture(tex_id, w / 2 - 55, h / 2 - 262, 110,10, 255, 255, 255, 255, "r")
        --renderer.text(w / 2 - 2, h / 2 - 240 ,255,255,255,lerp_alpha,"c-",0, isDefensive and " DEFENSIVE ")
        --renderer.gradient(w / 2 -55, h / 2 - 265 , 110,1, 59, 175, 222, 255, 202, 70, 205, 255,true)
       -- renderer.gradient(w / 2 -55, h / 2 - 252 , 110,1, 59, 175, 222, 255, 202, 70, 205, 255,true)
        --logo:draw(X / 2 - icon_size / 2, Y / 2 * 0.46 - (icon_size/2), icon_size, nil, r,g,b,a, true)


        if to_draw_ticks == 39 then
            to_draw_ticks = 0
            to_draw = "no"
            lerp_alpha = lerp(lerp_alpha,0, globals.frametime() * 30)
        end
        to_draw_ticks = to_draw_ticks + 1
    end

    local vel_adap = (ui.get(menu.visualsTab.velocity_ada) and get_velocity(entity.get_local_player()) * 45 / 450)  or 0
    
    if ui.get(menu.visualsTab.arrows) then
        if ui.get(menu.visualsTab.arrowIndicatorStyle) == "Normal" then
            alpha = (aa.manualAA == 2 or aa.manualAA == 1) and func.lerp(alpha, 255, globals.frametime() * 20) or func.lerp(alpha, 0, globals.frametime() * 20)
            renderer.text(sizeX / 2 + 45, sizeY / 2 - 2.5, aa.manualAA == 2 and arrowClr.r or 200, aa.manualAA == 2 and arrowClr.g or 200, aa.manualAA == 2 and arrowClr.b or 200, alpha, "c+", 0, '>')
            renderer.text(sizeX / 2 - 45, sizeY / 2 - 2.5, aa.manualAA == 1 and arrowClr.r or 200, aa.manualAA == 1 and arrowClr.g or 200, aa.manualAA == 1 and arrowClr.b or 200, alpha, "c+", 0, '<')
        end
    
        if ui.get(menu.visualsTab.arrowIndicatorStyle) == "Teamskeet" then
            renderer.triangle(sizeX / 2 + 55 + vel_adap, sizeY / 2 + 2, sizeX / 2 + 42 + vel_adap, sizeY / 2 - 7, sizeX / 2 + 42 + vel_adap, sizeY / 2 + 11, 
            aa.manualAA == 2 and arrowClr.r or 25, 
            aa.manualAA == 2 and arrowClr.g or 25, 
            aa.manualAA == 2 and arrowClr.b or 25, 
            aa.manualAA == 2 and arrowClr.a or 160)
    
            renderer.triangle(sizeX / 2 - 55 + -vel_adap, sizeY / 2 + 2, sizeX / 2 - 42 + -vel_adap, sizeY / 2 - 7, sizeX / 2 - 42 + -vel_adap, sizeY / 2 + 11, 
            aa.manualAA == 1 and arrowClr.r or 25, 
            aa.manualAA == 1 and arrowClr.g or 25, 
            aa.manualAA == 1 and arrowClr.b or 25, 
            aa.manualAA == 1 and arrowClr.a or 160)
        
            renderer.rectangle(sizeX / 2 + 38 + vel_adap, sizeY / 2 - 7, 2, 18, 
            bodyYaw < -10 and arrowClr.r or 25,
            bodyYaw < -10 and arrowClr.g or 25,
            bodyYaw < -10 and arrowClr.b or 25,
            bodyYaw < -10 and arrowClr.a or 160)
            renderer.rectangle(sizeX / 2 - 40 + -vel_adap, sizeY / 2 - 7, 2, 18,			
            bodyYaw > 10 and arrowClr.r or 25,
            bodyYaw > 10 and arrowClr.g or 25,
            bodyYaw > 10 and arrowClr.b or 25,
            bodyYaw > 10 and arrowClr.a or 160)
        end
    end

    local scopeLevel = entity.get_prop(weapon, 'm_zoomLevel')
    local scoped = entity.get_prop(local_player, 'm_bIsScoped') == 1
    local resumeZoom = entity.get_prop(local_player, 'm_bResumeZoom') == 1
    local isValid = weapon ~= nil and scopeLevel ~= nil
    local act = isValid and scopeLevel > 0 and scoped and not resumeZoom
    local time = globals.frametime() * 30

    if act then
        if scopedFraction < 1 then
            scopedFraction = func.lerp(scopedFraction, 1 + 0.1, time)
            scopedFraction2  = func.lerp(scopedFraction, 1 + 0.1, time)
        else
            scopedFraction = 1
            scopedFraction2 = 1.45
        end
    else
        scopedFraction = func.lerp(scopedFraction, 0, time)
        scopedFraction2 = func.lerp(scopedFraction, 0, time)
    end

    -- if ui.get(menu.visualsTab.indicators) == "Default" then
    --     local dpi = ui.get(ui.reference("MISC", "Settings", "DPI scale")):gsub('%%', '') - 100
    --     local globalFlag = "cd"
    --     local globalMoveY = globalFlag == "cd-" and 5 + dpi/10 or 9 + dpi/10
    --     local indX, indY = renderer.measure_text(globalFlag, "DT")
    --     local yDefault = 18 or 9
    --     local indCount = 0
    --     indY = globalFlag == "cd-" and indY - 3 or indY - 2
    
    --     local isCharged = antiaim_funcs.get_double_tap()
    --     local isFs = ui.get(menu.keys.freestandHotkey)
    --     local isBa = ui.get(refs.forceBaim)
    --     local isSp = ui.get(refs.safePoint)
    --     local isQp = ui.get(refs.quickPeek[2])
    --     local isSlow = ui.get(refs.slow[1]) and ui.get(refs.slow[2])
    --     local isOs = ui.get(refs.os[1]) and ui.get(refs.os[2])
    --     local isFd = ui.get(refs.fakeDuck)
    --     local isDt = ui.get(refs.dt[1]) and ui.get(refs.dt[2])
    
    --     local state = vars.intToS[vars.pState]:lower()
    
    --         indicators = indicators + 1
    --         local namex, namey = renderer.measure_text(globalFlag, globalFlag == "cd-" and lua_name:lower() or lua_name:lower())
    --         local logo = animate_text(globals.curtime(), globalFlag == "cd-" and lua_name:lower() or lua_name:lower(), mainClr.r, mainClr.g, mainClr.b, 255)
    
    --         renderer.text(sizeX/2 + ((namex + 2)/2) * scopedFraction, sizeY/2 + 20 - dpi/10, 255, 255, 255, 255, globalFlag, nil, unpack(logo))

    
    --         indicators = indicators + 1
    --         local namex, namey = renderer.measure_text(globalFlag, globalFlag == "cd-" and lua_name:lower() or lua_name:lower())
    --         local stateX, stateY = renderer.measure_text(globalFlag, state:lower())
    --         local string = state:lower()
    --         renderer.text(sizeX/2 + (stateX + 2)/2 * scopedFraction, sizeY/2 + 20 + namey/1.2, 255, 255, 255, 255, globalFlag, 0, string)
    
    --         indicators = indicators + 1
    --         if isDt then 
    --             dtClr.a = func.lerp(dtClr.a, 255, time)
    --             if dtInd.y < yDefault + indY * indCount then
    --                 dtInd.y = func.lerp(dtInd.y, yDefault + indY * indCount + 1, time)
    --             else
    --                 dtInd.y = yDefault + indY * indCount
    --             end
    --             chargeInd.w = 0.1
    --             if not isCharged and func.defensive.defensive > 1 then
    --                 dtClr.r = func.lerp(dtClr.r, 144, time)
    --                 dtClr.g = func.lerp(dtClr.g, 238, time)
    --                 dtClr.b = func.lerp(dtClr.b, 144, time)
    --             elseif not isCharged then
    --                 dtClr.r = func.lerp(dtClr.r, 222, time)
    --                 dtClr.g = func.lerp(dtClr.g, 55, time)
    --                 dtClr.b = func.lerp(dtClr.b, 55, time)
    --             else
    --                 dtClr.r = func.lerp(dtClr.r, 144, time)
    --                 dtClr.g = func.lerp(dtClr.g, 238, time)
    --                 dtClr.b = func.lerp(dtClr.b, 144, time)
    --             end
    --             indCount = indCount + 1
    --         elseif not isDt then 
    --             dtClr.a = func.lerp(dtClr.a, 0, time)
    --             dtInd.y = func.lerp(dtInd.y, yDefault - 5, time)
    --         end
    
    --         renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "DT" or "dt") + 2)/2) * scopedFraction , sizeY / 2 + dtInd.y + 13 + globalMoveY, dtClr.r, dtClr.g, dtClr.b, dtClr.a, globalFlag, dtInd.w, globalFlag == "cd-" and "DT" or "dt")
    
    --         indicators = indicators + 1
    --         if isOs then 
    --             osInd.a = func.lerp(osInd.a, 255, time)
    --             if osInd.y < yDefault + indY * indCount then
    --                 osInd.y = func.lerp(osInd.y, yDefault + indY * indCount + 1, time)
    --             else
    --                 osInd.y = yDefault + indY * indCount
    --             end
        
    --             indCount = indCount + 1
    --         elseif not isOs then
    --             osInd.a = func.lerp(osInd.a, 0, time)
    --             osInd.y = func.lerp(osInd.y, yDefault - 5, time)
    --         end
    --         renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "HS" or "hs") + 2)/2) * scopedFraction, sizeY / 2 + osInd.y + 13 + globalMoveY, 255, 255, 255, osInd.a, globalFlag, osInd.w, globalFlag == "cd-" and "HS" or "hs")
    
    --         indicators = indicators + 1
    --         if isFs then 
    --             fsInd.a = func.lerp(fsInd.a, 255, time)
    --             if fsInd.y < yDefault + indY * indCount then
    --                 fsInd.y = func.lerp(fsInd.y, yDefault + indY * indCount + 1, time)
    --             else
    --                 fsInd.y = yDefault + indY * indCount
    --             end
    --             indCount = indCount + 1
    --         elseif not isFs then 
    --             fsInd.a = func.lerp(fsInd.a, 0, time)
    --             fsInd.y = func.lerp(fsInd.y, yDefault - 5, time)
    --         end
    --         local fs_col = vars.fs and {255,255,255} or {222,55,55}
    --         renderer.text(sizeX / 2 + fsInd.x + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "FS" or "fs") + 2)/2) * scopedFraction, sizeY / 2 + fsInd.y + 13 + globalMoveY, fs_col[1], fs_col[2], fs_col[3], fsInd.a, globalFlag, fsInd.w, globalFlag == "cd-" and "FS" or "fs")
    

    --         indicators = indicators + 1
    --         if isSp then 
    --             spInd.a = func.lerp(spInd.a, 255, time)
    --             if spInd.y < yDefault + indY * indCount then
    --                 spInd.y = func.lerp(spInd.y, yDefault + indY * indCount + 1, time)
    --             else
    --                 spInd.y = yDefault + indY * indCount
    --             end
    --             indCount = indCount + 1
    --         elseif not isSp then 
    --             spInd.a = func.lerp(spInd.a, 0, time)
    --             spInd.y = func.lerp(spInd.y, yDefault - 5, time)
    --         end
    --         renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "SP" or "sp") + 2)/2) * scopedFraction, sizeY / 2 + spInd.y + 13 + globalMoveY, 255, 255, 255, spInd.a, globalFlag, 0, globalFlag == "cd-" and "SP" or "sp")

    

    --         indicators = indicators + 1
    --         if isBa then
    --             baInd.a = func.lerp(baInd.a, 255, time)
    --             if baInd.y < yDefault + indY * indCount then
    --                 baInd.y = func.lerp(baInd.y, yDefault + indY * indCount + 1, time)
    --             else
    --                 baInd.y = yDefault + indY * indCount
    --             end
    --             indCount = indCount + 1
    --         elseif not isBa then 
    --             baInd.a = func.lerp(baInd.a, 0, time)
    --             baInd.y = func.lerp(baInd.y, yDefault - 5, time)
    --         end
    --         renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "BA" or "ba") + 2)/2) * scopedFraction, sizeY / 2 + baInd.y + 13 + globalMoveY, 255, 255, 255, baInd.a, globalFlag, 0, globalFlag == "cd-" and "BA" or "ba")

    

    --         indicators = indicators + 1
    --         if isFd then
    --             fdInd.a = func.lerp(fdInd.a, 255, time)
    --             if fdInd.y < yDefault + indY * indCount then
    --                 fdInd.y = func.lerp(fdInd.y, yDefault + indY * indCount + 1, time)
    --             else
    --                 fdInd.y = yDefault + indY * indCount
    --             end
    --             indCount = indCount + 1
    --         elseif not isFd then 
    --             fdInd.a = func.lerp(fdInd.a, 0, time)
    --             fdInd.y = func.lerp(fdInd.y, yDefault - 5, time)
    --         end
    --         renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "FD" or "fd") + 2)/2) * scopedFraction, sizeY / 2 + fdInd.y + 13 + globalMoveY, 255, 255, 255, fdInd.a, globalFlag, 0, globalFlag == "cd-" and "FD" or "fd")
        if ui.get(menu.visualsTab.indicators) == "New" then
            local dpi = ui.get(ui.reference("MISC", "Settings", "DPI scale")):gsub('%%', '') - 100
            local globalFlag3 = "cd"
            local globalFlag2 = "cb"
            local globalFlag = "cd"
            local globalMoveY = globalFlag == "cd-" and 5 + dpi/10 or 9 + dpi/10
            local indX, indY = renderer.measure_text(globalFlag, "DT")
            local yDefault = 18 or 9
            local indCount = 0
            indY = globalFlag == "cd-" and indY - 3 or indY - 2
        
            local isCharged = antiaim_funcs.get_double_tap()
            local isFs = ui.get(menu.keys.freestandHotkey)
            local isBa = ui.get(refs.forceBaim)
            local isSp = ui.get(refs.safePoint)
            local isQp = ui.get(refs.quickPeek[2])
            local isSlow = ui.get(refs.slow[1]) and ui.get(refs.slow[2])
            local isOs = ui.get(refs.os[1]) and ui.get(refs.os[2])
            local isFd = ui.get(refs.fakeDuck)
            local isDt = ui.get(refs.dt[1]) and ui.get(refs.dt[2])
            local state = vars.intToS[vars.pState]:lower()

            local logo = animate_text(globals.curtime(), globalFlag2 == "cd-" and login.build:lower() or login.build:lower(), mainClr.r, mainClr.g, mainClr.b, 255)
            local namex, namey = renderer.measure_text(globalFlag2, globalFlag2 == "cd-" and lua_name:lower() or lua_name:lower())

            renderer.text(sizeX/2 + ((namex + 2)/2) * scopedFraction, sizeY/2 + 20 - dpi/10, 255, 255, 255, 255, globalFlag2, nil, unpack(logo))
    
            indicators = indicators + 1
            local namex, namey = renderer.measure_text(globalFlag3, globalFlag3 == "cd-" and lua_name:upper() or lua_name:lower())
            local logo = animate_text(globals.curtime(), globalFlag3 == "cd-" and lua_name:lower() or lua_name:lower(), mainClr.r, mainClr.g, mainClr.b, 255)
    
            renderer.text(sizeX/2 + ((namex + 2)/2) * scopedFraction, sizeY/2 + 31 - dpi/10, 255, 255, 255, 255, globalFlag3, nil, unpack(logo))

    
            indicators = indicators + 1
            local namex, namey = renderer.measure_text(globalFlag3, globalFlag3 == "cd-" and lua_name:lower() or lua_name:lower())
            local stateX, stateY = renderer.measure_text(globalFlag3, state:lower())
            local string = state:lower()

    
    
            indicators = indicators + 1
            if isDt then 
                dtClr.a = func.lerp(dtClr.a, 255, time)
                if dtInd.y < yDefault + indY * indCount then
                    dtInd.y = func.lerp(dtInd.y, yDefault + indY * indCount + 1, time)
                else
                    dtInd.y = yDefault + indY * indCount
                end
                chargeInd.w = 0.1
                if not isCharged and func.defensive.defensive > 1 then
                    dtClr.r = func.lerp(dtClr.r, 144, time)
                    dtClr.g = func.lerp(dtClr.g, 238, time)
                    dtClr.b = func.lerp(dtClr.b, 144, time)
                elseif not isCharged then
                    dtClr.r = func.lerp(dtClr.r, 222, time)
                    dtClr.g = func.lerp(dtClr.g, 55, time)
                    dtClr.b = func.lerp(dtClr.b, 55, time)
                else
                    dtClr.r = func.lerp(dtClr.r, 144, time)
                    dtClr.g = func.lerp(dtClr.g, 238, time)
                    dtClr.b = func.lerp(dtClr.b, 144, time)
                end
                indCount = indCount + 1
            elseif not isDt then 
                dtClr.a = func.lerp(dtClr.a, 0, time)
                dtInd.y = func.lerp(dtInd.y, yDefault - 5, time)
            end
    
            renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "doubletap" or "doubletap") + 2)/2) * scopedFraction , sizeY / 2 + dtInd.y + 16 + globalMoveY, dtClr.r, dtClr.g, dtClr.b, dtClr.a, globalFlag, dtInd.w, globalFlag == "cd-" and "doubletap" or "doubletap")
    
            indicators = indicators + 1
            if isOs then 
                osInd.a = func.lerp(osInd.a, 255, time)
                if osInd.y < yDefault + indY * indCount then
                    osInd.y = func.lerp(osInd.y, yDefault + indY * indCount + 1, time)
                else
                    osInd.y = yDefault + indY * indCount
                end
        
                indCount = indCount + 1
            elseif not isOs then
                osInd.a = func.lerp(osInd.a, 0, time)
                osInd.y = func.lerp(osInd.y, yDefault - 5, time)
            end
            --renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "hideshots" or "hideshots") + 2)/2) * scopedFraction, sizeY / 2 + osInd.y + 20 + globalMoveY, 255, 255, 255, osInd.a, globalFlag, osInd.w, globalFlag == "cd-" and "hideshots" or "hideshots")
    
            indicators = indicators + 1
            if isFs then 
                fsInd.a = func.lerp(fsInd.a, 255, time)
                if fsInd.y < yDefault + indY * indCount then
                    fsInd.y = func.lerp(fsInd.y, yDefault + indY * indCount + 1, time)
                else
                    fsInd.y = yDefault + indY * indCount
                end
                indCount = indCount + 1
            elseif not isFs then 
                fsInd.a = func.lerp(fsInd.a, 0, time)
                fsInd.y = func.lerp(fsInd.y, yDefault - 5, time)
            end
            local fs_col = vars.fs and {255,255,255} or {222,55,55}
            renderer.text(sizeX / 2 + fsInd.x + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "freestanding" or "freestanding") + 2)/2) * scopedFraction, sizeY / 2 + fsInd.y + 18 + globalMoveY, fs_col[1], fs_col[2], fs_col[3], fsInd.a, globalFlag, fsInd.w, globalFlag == "cd-" and "freestanding" or "freestanding")

    

            indicators = indicators + 1
            if isBa then
                baInd.a = func.lerp(baInd.a, 255, time)
                if baInd.y < yDefault + indY * indCount then
                    baInd.y = func.lerp(baInd.y, yDefault + indY * indCount + 1, time)
                else
                    baInd.y = yDefault + indY * indCount
                end
                indCount = indCount + 1
            elseif not isBa then 
                baInd.a = func.lerp(baInd.a, 0, time)
                baInd.y = func.lerp(baInd.y, yDefault - 5, time)
            end
            renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "baim" or "baim") + 2)/2) * scopedFraction, sizeY / 2 + baInd.y + 19 + globalMoveY, 255, 255, 255, baInd.a, globalFlag, 0, globalFlag == "cd-" and "baim" or "baim")

    

            indicators = indicators + 1
            if isFd then
                fdInd.a = func.lerp(fdInd.a, 255, time)
                if fdInd.y < yDefault + indY * indCount then
                    fdInd.y = func.lerp(fdInd.y, yDefault + indY * indCount + 1, time)
                else
                    fdInd.y = yDefault + indY * indCount
                end
                indCount = indCount + 1
            elseif not isFd then 
                fdInd.a = func.lerp(fdInd.a, 0, time)
                fdInd.y = func.lerp(fdInd.y, yDefault - 5, time)
            end
            renderer.text(sizeX / 2 + ((renderer.measure_text(globalFlag, globalFlag == "cd-" and "fakeduck" or "fakeduck") + 2)/2) * scopedFraction, sizeY / 2 + fdInd.y + 18 + globalMoveY, 255, 255, 255, fdInd.a, globalFlag, 0, globalFlag == "cd-" and "fakeduck" or "fakeduck")

        elseif ui.get(menu.visualsTab.indicators) == "Second" then

            local nextAttack = entity.get_prop(vars.localPlayer, "m_flNextAttack")
            local nextPrimaryAttack = entity.get_prop(entity.get_player_weapon(vars.localPlayer), "m_flNextPrimaryAttack")
            local dtActive = false
            if nextPrimaryAttack ~= nil then
                dtActive = not (math.max(nextPrimaryAttack, nextAttack) > globals.curtime())
            end

            local dpi = ui.get(ui.reference("MISC", "Settings", "DPI scale")):gsub('%%', '') - 100
            local globalFlag3 = "cd"
            local globalFlag2 = "cd"
            local globalFlag = "cd"
            local globalMoveY = globalFlag == "cd" and 5 + dpi/10 or 9 + dpi/10
            local indX, indY = renderer.measure_text(globalFlag, "DT")
            local yDefault = 18 or 9
            local indCount = 0
            indY = globalFlag == "cd" and indY - 3 or indY - 2
            local isCharged = dtActive
            
        
         --   local isCharged = antiaim_funcs.get_double_tap()
            local isFs = ui.get(menu.keys.freestandHotkey)
            local isBa = ui.get(refs.forceBaim)
            local isSp = ui.get(refs.safePoint)
            local isQp = ui.get(refs.quickPeek[2])
            local isSlow = ui.get(refs.slow[1]) and ui.get(refs.slow[2])
            local isOs = ui.get(refs.os[1]) and ui.get(refs.os[2])
            local isFd = ui.get(refs.fakeDuck)
            local isDt = ui.get(refs.dt[1]) and ui.get(refs.dt[2])
            local state = vars.intToS[vars.pState]:lower()
            local strike_w, strike_h = renderer.measure_text("-cd", lua_name)
            local logo = animate_text(globals.curtime(), string.upper("T  A  B  S  E  N  S  E"), mainClr.r, mainClr.g, mainClr.b, 255)
    
            glow_module(sizeX/2 + ((strike_w)/2) * scopedFraction2 - strike_w/2 + 2, sizeY/2 + 20 - dpi/10, strike_w - 0, 0, 12, 0, {mainClr.r, mainClr.g, mainClr.b, 100 * math.abs(math.cos(globals.curtime()*2))}, {mainClr.r, mainClr.g, mainClr.b, 200 * math.abs(math.cos(globals.curtime()*2))})
            renderer.text(sizeX/2 + ((strike_w + 2)/2) * scopedFraction2, sizeY/2 + 20 - dpi/10, 255, 255, 255, 255, "-cd", nil, unpack(logo))
    
            local count = 0
    
            if isDt and dtActive and isDefensive == false then
                activeFraction = func.clamp(activeFraction + globals.frametime()/0.15, 0, 1)
                if dtPos.y < indY * count then
                    dtPos.y = func.lerp(dtPos.y, indY * count + 0.1, time)
                else
                    dtPos.y = indY * count
                end
                count = count + 1
            else
                activeFraction = func.clamp(activeFraction - globals.frametime()/0.15, 0, 1)
            end
    
            if isDt and dtActive and isDefensive then
                defensiveFraction = func.clamp(defensiveFraction + globals.frametime()/0.15, 0, 1)
                if dtPos.y < indY * count then
                    dtPos.y = func.lerp(dtPos.y, indY * count + 0.1, time)
                else
                    dtPos.y = indY * count
                end
                count = count + 1
            else
                defensiveFraction = func.clamp(defensiveFraction - globals.frametime()/0.15, 0, 1)
                isDefensive = false
            end
    
            if isDt and not dtActive then
                inactiveFraction = func.clamp(inactiveFraction + globals.frametime()/0.15, 0, 1)
                if dtPos.y < indY * count then
                    dtPos.y = func.lerp(dtPos.y, indY * count + 0.1, time)
                else
                    dtPos.y = indY * count
                end
                count = count + 1
            else
                inactiveFraction = func.clamp(inactiveFraction - globals.frametime()/0.15, 0, 1)
            end
    
            if isOs and ui.get(ui.reference("Rage", "Other", "Silent aim")) and isDt then
                hideInactiveFraction = func.clamp(hideInactiveFraction + globals.frametime()/0.15, 0, 1)
                if osPos.y < indY * count then
                    osPos.y = func.lerp(osPos.y, indY * count + 0.1, time)
                else
                    osPos.y = indY * count
                end
                count = count + 1
            else
                hideInactiveFraction = func.clamp(hideInactiveFraction - globals.frametime()/0.15, 0, 1)
            end
    
            if isOs and ui.get(ui.reference("Rage", "Other", "Silent aim")) and not isDt then
                hideFraction = func.clamp(hideFraction + globals.frametime()/0.15, 0, 1)
                if osPos.y < indY * count then
                    osPos.y = func.lerp(osPos.y, indY * count + 0.1, time)
                else
                    osPos.y = indY * count
                end
                count = count + 1
            else
                hideFraction = func.clamp(hideFraction - globals.frametime()/0.15, 0, 1)
            end
    
            local globalMarginX, globalMarginY = renderer.measure_text("-cd", "DSAD")
            globalMarginY = globalMarginY - 2
            local dt_size = renderer.measure_text("-cd", "DT ")
            local ready_size = renderer.measure_text("-cd", "READY")
            renderer.text(sizeX/2 + ((dt_size + ready_size + 2)/2) * scopedFraction, sizeY/2 + 30 + globalMarginY + dtPos.y, 255, 255, 255, activeFraction * 255, "-cd", dt_size + activeFraction * ready_size + 1, "DT ", "\a" .. func.RGBAtoHEX(155, 255, 155, 255 * activeFraction) .. "READY")
    
            local charging_size = renderer.measure_text("-cd", "CHARGING")
            local ret = animate_text(globals.curtime(), "CHARGING", 255, 100, 100, 255)
            renderer.text(sizeX/2 + ((dt_size + charging_size + 2)/2) * scopedFraction, sizeY/2 + 30 + globalMarginY + dtPos.y, 255, 255, 255, inactiveFraction * 255, "-cd", dt_size + inactiveFraction * charging_size + 1, "DT ", unpack(ret))
    
            local defensive_size = renderer.measure_text("-cd", "DEFENSIVE")
            local def = animate_text(globals.curtime(), "DEFENSIVE", mainClr.r, mainClr.g, mainClr.b, 255)
            renderer.text(sizeX/2 + ((dt_size + defensive_size + 2)/2) * scopedFraction, sizeY/2 + 30 + globalMarginY + dtPos.y, 255, 255, 255, defensiveFraction * 255, "-cd", dt_size + defensiveFraction * defensive_size + 1, "DT ", unpack(def))
    
            local hide_size = renderer.measure_text("-cd", "OSAA ")
            local active_size = renderer.measure_text("-cd", "ACTIVE")
            renderer.text(sizeX/2 + ((hide_size + active_size + 2)/2) * scopedFraction, sizeY/2 + 30 + globalMarginY + osPos.y, 255, 255, 255, hideFraction * 255, "-cd", hide_size + hideFraction * active_size + 1, "OSAA ", "\a" .. func.RGBAtoHEX(155, 255, 155, 255 * hideFraction) .. "ACTIVE")
            
            local inactive_size = renderer.measure_text("-cd", "INACTIVE")
            local osin = animate_text(globals.curtime(), "INACTIVE", 255, 100, 100, 255)
            renderer.text(sizeX/2 + ((hide_size + inactive_size + 2)/2) * scopedFraction, sizeY/2 + 30 + globalMarginY + osPos.y, 255, 255, 255, hideInactiveFraction * 255, "-cd", hide_size + hideInactiveFraction * inactive_size + 1, "OSAA ", unpack(osin))
        
            local state_size = renderer.measure_text("-cd", '>' .. string.upper(state) .. '<')
            renderer.text(sizeX/2 + ((state_size + 2)/2) * scopedFraction, sizeY/2 + 30 , 255, 255, 255, 255, "-cd", 0, '>' .. string.upper(state) .. '<')
        end

    if func.includes(ui.get(menu.visualsTab.defensive_indicator), "Kibit") and entity.get_classname(weapon) ~= "CKnife" and ui.get(refs.dmgOverride[1]) and ui.get(refs.dmgOverride[2]) then
        local dmg = ui.get(refs.dmgOverride[3])
        renderer.text(sizeX / 2 + 2, sizeY / 2 - 14, 255, 255, 255, 255, "d", 0, dmg)
    end

    if func.includes(ui.get(menu.resolver.xddd), "Debug Panel") then
        get_best_enemy()
        local target = best_enemy
        local desync_amount = antiaim_funcs.get_desync(2)
        local xd = antiaim_funcs.get_tickbase_shifting()
        local xd2 = antiaim_funcs.get_body_yaw(2)
        local text_size = vector(renderer.measure_text("", "tabsense.lua - " .. string.lower(login.username)))

        if client.key_state(0x01) and ui.is_menu_open() then
            local mouse_pos = { ui.mouse_position() }
            if intersect(debug_x - 5, debug_y - 60, text_size.x + 12, 83 + 34) then
                debug_x = mouse_pos[1] - 65
                debug_y = mouse_pos[2]
            end
        end

        if ui.get(menu.resolver.debug_style) == "Skeet border" then
            render_ogskeet_border(debug_x, debug_y, text_size.x + 7, 83 + 9, 255, "")
        end


        renderer.text(debug_x, debug_y - 44 + 4, 255, 255, 255, 255, "", 0, "tabsense.lua - " .. string.lower(login.username))
        renderer.text(debug_x, debug_y - 44 + 14, 255, 255, 255, 255, "", 0, "version: \a" ..rgba_to_hex(255,255,255,255 * math.abs(math.cos(globals.curtime()*2))) .. string.lower(login.build))
        renderer.text(debug_x, debug_y - 44 + 24, 255, 255, 255, 255, "", 0, "target: " .. string.lower(entity.get_player_name(target)))
        renderer.text(debug_x, debug_y - 44 + 34, 255, 255, 255, 255, "", 0, "enemy yaw: " .. yaw_save)
        renderer.text(debug_x, debug_y - 44 + 44, 255, 255, 255, 255, "", 0, "old target value: " .. yaw_save / 2 or yaw_save * 2)
        renderer.text(debug_x, debug_y - 44 + 54, 255, 255, 255, 255, "", 0, "body yaw: " .. math.floor(xd2))
        renderer.text(debug_x, debug_y - 44 + 64, 255, 255, 255, 255, "", 0, "exploit charge: " .. xd) 
        renderer.text(debug_x, debug_y - 44 + 74, 255, 255, 255, 255, "", 0, "choke: " .. globals.chokedcommands())
        renderer.text(debug_x, debug_y - 44 + 84, 255, 255, 255, 255, "", 0, "overlap: " .. math.floor(antiaim_funcs.get_overlap() * 100))
    end


    if indicators == 0 then
        local watermarkX, watermarkY = renderer.measure_text("cd-", "")
        local lua_watermarkname = ''
        local logo = animate_text(globals.curtime(), globalFlag == "cd-" and lua_watermarkname:upper() or lua_watermarkname:upper(), mainClr.r, mainClr.g, mainClr.b, 255)
        renderer.text(sizeX/2-watermarkX/2+24, sizeY/1.025,  mainClr.r, mainClr.g, mainClr.b, 255, "c", 0, unpack(logo))
    end

    local call_back = ui.get(menu.visualsTab.logs) and client.set_event_callback or client.unset_event_callback

    notifications.render()
end)

local u8, device, localize, surface, notify = {}, {}, {}, {}, {}

do 
    function u8:len(s)
        return #s:gsub("[\128-\191]", "");
    end

    local string_mod; do
        local float = 0;
        local to_alpha = 1 / 255;

        local function fn(rgb, alpha)
            return string.format("%s%02x", rgb, float * tonumber(alpha, 16));
        end

        function string_mod(s, alpha)
            float = alpha * to_alpha;
            return s:gsub("(\a%x%x%x%x%x%x)(%x%x)", fn);
        end
    end

    function device:on_update()
        local new_rect = vector(client.screen_size());

        if new_rect ~= self.rect then
            self.rect = new_rect;
        end
    end

    function device:draw_text(x, y, r, g, b, a, flags, max_width, ...)
        local text = table.concat {...};
        text = string.mod(text, a);

        renderer.text(x, y, r, g, b, a, flags, max_width, text);
    end

    local native_ConvertAnsiToUnicode = vtable_bind("localize.dll", "Localize_001", 15, "int(__thiscall*)(void* thisptr, const char *ansi, wchar_t *unicode, int buffer_size)")
    local native_ConvertUnicodeToAnsi = vtable_bind("localize.dll", "Localize_001", 16, "int(__thiscall*)(void* thisptr, wchar_t *unicode, char *ansi, int buffer_size)")

    function localize:ansi_to_unicode(ansi, unicode, buffer_size)
        return native_ConvertAnsiToUnicode(ansi, unicode, buffer_size);
    end

    function localize:unicode_to_ansi(ansi, unicode, buffer_size)
        return native_ConvertUnicodeToAnsi(ansi, unicode, buffer_size);
    end

    local native_SetTextFont = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 23, "void*(__thiscall*)(void *thisptr, dword font_id)");
    local native_SetTextColor = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 25, "void*(__thiscall*)(void *thisptr, int r, int g, int b, int a)");
    local native_SetTextPos = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 26, "void*(__thiscall*)(void *thisptr, int x, int y)");
    local native_DrawPrintText = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 28, "void*(__thiscall*)(void *thisptr, const wchar_t *text, int maxlen, int draw_type)");

    local native_GetTextSize = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 79, "void(__thiscall*)(void *thisptr, size_t font, const wchar_t *text, int &wide, int &tall)");

    local native_GetFontName = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 134, "const char*(__thiscall*)(void *thisptr, size_t font)");

    local buffer = ffi.new("wchar_t[65535]");
    local wide, tall = ffi.new("int[1]"), ffi.new("int[1]");

    local to_alpha = 1 / 255;

    function surface:get_font_name(font_id)
        return ffi.string(native_GetFontName(font_id));
    end

    function surface:text(font, x, y, r, g, b, a, ...)
        local text = table.concat {...};
        localize:ansi_to_unicode(text, buffer, 65535);

        native_GetTextSize(font, buffer, wide, tall);

        native_SetTextFont(font);
        native_SetTextPos(x, y);
        native_SetTextColor(r, g, b, a);

        native_DrawPrintText(buffer, u8:len(text), 0);

        return wide[0], tall[0];
    end

    function surface:color_text(font, x, y, r, g, b, a, ...)
        local text = table.concat {...};
        local i, j = text:find "\a";

        if i ~= nil then
            x = x + self:text(font, x, y, r, g, b, a, text:sub(1, i - 1))

            while i ~= nil do
                local new_r, new_g, new_b, new_a = r, g, b, a;

                if text:sub(i, j + 7) == "\adefault" then
                    text = text:sub(1 + j + 7);
                else
                    local hex = text:sub(i + 1, j + 8);
                    text = text:sub(1 + j + 8);

                    new_r, new_g, new_b, new_a = func.frgba(hex);
                    new_a = new_a * (a * to_alpha);
                end

                i, j = text:find "\a";

                local new_text = text;

                if i ~= nil then
                    new_text = text:sub(1, i - 1);
                end

                x = x + self:text(font, x, y, new_r, new_g, new_b, new_a, new_text);
            end

            return;
        end

        self:text(font, x, y, r, g, b, a, text);
    end

    local native_ConsoleIsVisible = vtable_bind("engine.dll", "VEngineClient014", 11, "bool(__thiscall*)(void*)");
    local native_ColorPrint = vtable_bind("vstdlib.dll", "VEngineCvar007", 25, "void(__cdecl*)(void*, const color_t&, const char*, ...)");

    local queue = {};
    local current;

    local times = 6;
    local duration = 8;

    local buffer = ffi.new("color_t");
    local to_alpha = 1 / 255;

    local function color_print(r, g, b, a, ...)
        buffer.r, buffer.g, buffer.b, buffer.a = r, g, b, a;
        native_ColorPrint(buffer, ...);
    end

    function notify:color_log(r, g, b, a, ...)
        local text = table.concat {...};
        local i, j = text:find "\a";

        if i ~= nil then
            color_print(r, g, b, a, text:sub(1, i - 1));

            while i ~= nil do
                local new_r, new_g, new_b, new_a = r, g, b, a;

                if text:sub(i, j + 7) == "\adefault" then
                    text = text:sub(1 + j + 7);
                else
                    local hex = text:sub(i + 1, j + 8);
                    text = text:sub(1 + j + 8);

                    new_r, new_g, new_b, new_a = rgba(hex);
                    new_a = new_a * a * to_alpha;
                end

                i, j = text:find "\a";

                local new_text = text;

                if i ~= nil then
                    new_text = text:sub(1, i - 1);
                end

                color_print(new_r, new_g, new_b, new_a, new_text);
            end

            color_print(0, 0, 0, 0, "\n");
            return;
        end

        color_print(r, g, b, a, text .. "\n");
    end

    function notify:add_to_queue(r, g, b, a, ...)
        local text = table.concat {...};

        local this =
        {
            text = text,
            colour = {r, g, b, a},
            colored = true,
            liferemaining = duration
        };

        queue[#queue + 1] = this;

        while #queue > times do
            table.remove(queue, 1);
        end

        return this;
    end

    function notify:should_draw()
        local is_visible = false;
        local host_frametime = globals.frametime();

        if not native_ConsoleIsVisible() then
            for i = #queue, 1, -1 do
                local v = queue[i];
                v.liferemaining = v.liferemaining - host_frametime;

                if v.liferemaining <= 0 then
                    table.remove(queue, i);
                    goto continue;
                end

                is_visible = true;
                ::continue::
            end
        end

        return is_visible;
    end

    function notify:on_paint_ui()
        local x, y = 8, 5;
        local flags = "d";

        for i = 1, #queue do
            local v = queue[i];

            local colour = v.colour;
            local r, g, b, a = colour[1], colour[2], colour[3], colour[4];

            local text = v.text:gsub("\n", "");
            local measure = vector(renderer.measure_text(flags, text));

            local tall = measure.y + 1;

            if v.liferemaining < .5 then
                local f = func.fclamp(v.liferemaining, 0, .5) / .5;
                a = a * f;

                if i == 1 and f < .2 then
                    y = y - tall * (1 - f / .2);
                end
            end

            if v.colored then
                surface:color_text(63, x, y, r, g, b, a, text);
            else
                surface:text(63, x, y, r, g, b, a, text);
            end

            y = y + tall;
        end
    end

    function notify:on_output(e)
        local text = string.format("\a%02x%02x%02x%02x%s", e.r, e.g, e.b, e.a, e.text);
        local i = text:find "\0";

        if i ~= nil then
            text = text:sub(1, i - 1);
        end

        if current ~= nil then
            current.text = current.text .. text;

            if i == nil then
                current = nil;
            end

            return current;
        end

        local this = self:add_to_queue(e.r, e.g, e.b, e.a, text);
        this.colored = text:find "\a" ~= nil;

        if i ~= nil then
            current = this;
        end

        return this;
    end

    function notify:on_console_input(e)
        if e:find("clear") == 1 then
            for i = 1, #queue do
                queue[i] = nil;
            end
        end
    end
end

device:on_update()

client.set_event_callback("paint_ui", function()
    device:on_update()
    notify:should_draw()
    notify:on_paint_ui()
end)


-- @region UI_CALLBACKS start
ui.update(menu.configTab.list,getConfigList())
if database.read(lua.database.configs) == nil then
    database.write(lua.database.configs, {})
end
ui.set(menu.configTab.name, #database.read(lua.database.configs) == 0 and "" or database.read(lua.database.configs)[ui.get(menu.configTab.list)+1].name)
ui.set_callback(menu.configTab.list, function(value)
    local protected = function()
        if value == nil then return end
        local name = ""
    
        local configs = getConfigList()
        if configs == nil then return end
    
        name = configs[ui.get(value)+1] or ""
    
        ui.set(menu.configTab.name, name)
    end

    if pcall(protected) then

    end
end)

ui.set_callback(menu.configTab.load, function()
    local r, g, b = ui.get(menu.visualsTab.logsClr)
    local name = ui.get(menu.configTab.name)
    if name == "" then return end

    local protected = function()
        loadConfig(name)
    end

    if pcall(protected) then
        name = name:gsub('*', '')
        notifications.new(string.format('Successfully loaded config!'), r, g, b)
    else
        notifications.new(string.format('Failed to load config!'), 255, 120, 120)
    end
end)

ui.set_callback(menu.configTab.save, function()
    local r, g, b = ui.get(menu.visualsTab.logsClr)

    local name = ui.get(menu.configTab.name)
    if name == "" then return end

    for i, v in pairs(presets) do
        if v.name == name:gsub('*', '') then
            notifications.new(string.format('Disable presets [402]"', name:gsub('*', '')), 255, 120, 120) --cant save with ready-to-use presets
            return
        end
    end

    if name:match("[^%w]") ~= nil then
        notifications.new(string.format('[401] You cant save Default config', name), 255, 120, 120) --due to invalid characters
        return
    end

    local protected = function()
        saveConfig(name)
        ui.update(menu.configTab.list, getConfigList())
    end
    if pcall(protected) then
        notifications.new(string.format('Successfully saved config!'), r, g, b)
    else
        notifications.new(string.format('Failed to save config! [406]'), 255, 120, 120)
    end
end)

ui.set_callback(menu.configTab.delete, function()
    local name = ui.get(menu.configTab.name)
    if name == "" then return end
    local r, g, b = ui.get(menu.visualsTab.logsClr)
    if deleteConfig(name) == false then
        notifications.new(string.format('Error [403]'), 255, 120, 120) --failed to delete cfg
        ui.update(menu.configTab.list, getConfigList())
        return
    end

    for i, v in pairs(presets) do
        if v.name == name:gsub('*', '') then
            notifications.new(string.format('[410]"', name:gsub('*', '')), 255, 120, 120) -- cant delete ready-to-use presets
            return
        end
    end

    local protected = function()
        deleteConfig(name)
    end

    if pcall(protected) then
        ui.update(menu.configTab.list, getConfigList())
        ui.set(menu.configTab.list, #presets + #database.read(lua.database.configs) - #database.read(lua.database.configs))
        ui.set(menu.configTab.name, #database.read(lua.database.configs) == 0 and "" or getConfigList()[#presets + #database.read(lua.database.configs) - #database.read(lua.database.configs)+1])
        notifications.new(string.format('Deleted "$%s$"', name), r, g, b)
    end
end)

ui.set_callback(menu.configTab.import, function()
    local r, g, b = ui.get(menu.visualsTab.logsClr)

    local protected = function()
        importSettings()
    end

    if pcall(protected) then
        notifications.new(string.format('Successfully loaded config', name), r, g, b)
    else
        notifications.new(string.format('Bad import config!', name), 255, 120, 120)
    end
end)

ui.set_callback(menu.configTab.export, function()
    local name = ui.get(menu.configTab.name)
    if name == "" then return end

    local protected = function()
        exportSettings(name)
    end
    local r, g, b = ui.get(menu.visualsTab.logsClr)

    if pcall(protected) then
        notifications.new(string.format('Successfully shared config!', name), r, g, b)
    else
        notifications.new(string.format('Failed to export settings!', name), 255, 120, 120)
    end
end)

local logica1337 = "2"

ui.set_callback(menu.builderTab.PresetComboBox, function()
    if ui.get(menu.builderTab.PresetComboBox) == "Unmatched" then
        local r, g, b = ui.get(menu.visualsTab.logsClr)

        local protected = function()
            importPreset()
        end

        if pcall(protected) then
            notifications.new(string.format('Enabled Un\adec3c3ffmatched', name), r, g, b)
        else
            notifications.new(string.format('Invaild Settings', name), 255, 120, 120)
        end
    elseif ui.get(menu.builderTab.PresetComboBox) == "Community" then
        local r, g, b = ui.get(menu.visualsTab.logsClr)

        local protected = function()
            importPreset2()
        end

        if pcall(protected) then
            notifications.new(string.format('Enabled Comm\adec3c3ffunity', name), r, g, b)
        else
            notifications.new(string.format('Invaild Settings', name), 255, 120, 120)
        end
    end
end)

-- ui.set_callback(menu.builderTab.buttonPresets, function()
--     local r, g, b = ui.get(menu.visualsTab.logsClr)

--     local protected = function()
--         ui.set(menu.builderTab.LogicComboBox, "2")
--     end

--     if pcall(protected) then
--         --notifications.new(string.format('Pres\adec3c3ffets', name), r, g, b)
--     else
--         notifications.new(string.format('Failed to open Pres\adec3c3ffets', name), 255, 120, 120)
--     end
-- end)

ui.set_callback(menu.builderTab.buttonBuilder, function()
    local r, g, b = ui.get(menu.visualsTab.logsClr)

    local protected = function()
        ui.set(menu.builderTab.LogicComboBox, "1")
        ui.set(menu.builderTab.PresetComboBox, "Disabled")
        --importPresetClear()
    end

    if pcall(protected) then
        notifications.new(string.format('Successfully exported settings to your builder', name), r, g, b)
    else
        notifications.new(string.format('Disabled Presets', name), 255, 120, 120)
    end
end)

client.set_event_callback("paint_ui", function()
    vars.activeState = vars.sToInt[ui.get(menu.builderTab.state)]
    local isEnabled = ui.get(masterSwitch)
    local isAATab = ui_menu.selected_tab == 1 and ui.get(aaTabs) == "Other"
    local keys2 = ui_menu.selected_tab == 1 and ui.get(aaTabs) == "Keybinds"
    local isBuilderTab = ui_menu.selected_tab == 1 and ui.get(aaTabs) == "Builder"
    local isVisualsTab = ui_menu.selected_tab == 2
    local isMiscTab = ui_menu.selected_tab == 3
    local isCFGTab = ui_menu.selected_tab == 4
    local ispresetdisabled = ui.get(menu.builderTab.PresetComboBox) == "Disabled"
    local isLogicBuilder = ui.get(menu.builderTab.LogicComboBox) == "1"
    local isLogicPresets = ui.get(menu.builderTab.LogicComboBox) == "2"

    ui.set(aaBuilder[1].enableState, true)
    for i = 1, #vars.aaStates do
        local stateEnabled = ui.get(aaBuilder[i].enableState)
        local defensivedziala = ui.get(aaBuilder[i].enabledefensive)
        ui.set_visible(aaBuilder[i].enableState, vars.activeState == i and isBuilderTab and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].pitch, vars.activeState == i and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].pitchSlider , vars.activeState == i and isBuilderTab and stateEnabled and ui.get(aaBuilder[i].pitch) == "Custom" and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawBase, vars.activeState == i and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yaw, vars.activeState == i and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawCondition, vars.activeState == i and ui.get(aaBuilder[i].yaw) ~= "Off" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawStatic, vars.activeState == i and ui.get(aaBuilder[i].yaw) ~= "Off" and ui.get(aaBuilder[i].yawCondition) == "Static"  and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawLeft, vars.activeState == i and ui.get(aaBuilder[i].yaw) ~= "Off" and ui.get(aaBuilder[i].yawCondition) ~= "Static" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawRight, vars.activeState == i and ui.get(aaBuilder[i].yaw) ~= "Off" and ui.get(aaBuilder[i].yawCondition) ~= "Static" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawSpeed, vars.activeState == i and ui.get(aaBuilder[i].yaw) ~= "Off" and ui.get(aaBuilder[i].yawCondition) == "Delay" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawJitter, vars.activeState == i and ui.get(aaBuilder[i].yaw) ~= "Off" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawJitterCondition, vars.activeState == i and ui.get(aaBuilder[i].yawJitter) ~= "Off" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawJitterStatic, vars.activeState == i and ui.get(aaBuilder[i].yawJitter) ~= "Off" and ui.get(aaBuilder[i].yawJitterCondition) == "Static" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawJitterLeft, vars.activeState == i and ui.get(aaBuilder[i].yawJitter) ~= "Off" and ui.get(aaBuilder[i].yawJitterCondition) == "L & R" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].yawJitterRight, vars.activeState == i and ui.get(aaBuilder[i].yawJitter) ~= "Off" and ui.get(aaBuilder[i].yawJitterCondition) == "L & R" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
       -- ui.set_visible(aaBuilder[i].yawJitterDisablers, vars.activeState == i and ui.get(aaBuilder[i].yawJitter) ~= "Off" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].bodyYaw, vars.activeState == i and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].bodyYawSlider, vars.activeState == i and ui.get(aaBuilder[i].bodyYaw) ~= "Off" and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].enabledefensive, vars.activeState == i and isBuilderTab and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].defensiveOpt, vars.activeState == i and isBuilderTab and defensivedziala and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].defensiveYaw, vars.activeState == i and isBuilderTab and defensivedziala and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].defensiveYawSlider, vars.activeState == i and isBuilderTab and defensivedziala and stateEnabled and isEnabled and ui.get(aaBuilder[i].defensiveYaw) == "Custom" and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].defensivePitch, vars.activeState == i and isBuilderTab and defensivedziala and stateEnabled and isEnabled and ispresetdisabled and isLogicBuilder)
        ui.set_visible(aaBuilder[i].defensivePitchSlider, vars.activeState == i and isBuilderTab and defensivedziala and stateEnabled and isEnabled and ui.get(aaBuilder[i].defensivePitch) == "Custom" and ispresetdisabled and isLogicBuilder)
    end

    for i, feature in pairs(menu.aaTab) do
        if type(feature) ~= "table" then
            ui.set_visible(feature, isAATab and isEnabled and ui.get(aaTabs) == "Other")
        end
	end 

   -- local bindykurwa = ui.get(menu.keys.Bindyhehe)
   -- ui.set_visible(menu.keys.Bindyhehe, isBuilderTab and isEnabled and ispresetdisabled and isLogicBuilder)
    ui.set_visible(menu.builderTab.state, ui.get(menu.builderTab.PresetComboBox) == "Disabled" and isBuilderTab and isEnabled and isLogicBuilder)
    ui.set_visible(menu.builderTab.buttonBuilder, isBuilderTab and isEnabled and isLogicPresets)
   -- ui.set_visible(menu.builderTab.buttonPresets, isBuilderTab and isEnabled and isLogicBuilder)
    ui.set_visible(menu.builderTab.PresetComboBox, isBuilderTab and isEnabled and isLogicPresets)
    ui.set_visible(aaTabs, isBuilderTab or keys2 or isAATab and isEnabled)
    ui.set_visible(menu.builderTab.LogicComboBox, isBuilderTab and isEnabled and logica1337 == "1")

    ui.set_visible(menu.keys.freestandHotkey, keys2 and ui.get(aaTabs) == "Keybinds" and isEnabled) 
    ui.set_visible(menu.keys.edgeYawHotkey, keys2 and ui.get(aaTabs) == "Keybinds" and isEnabled)
    ui.set_visible(menu.keys.freestandDisablers, keys2 and ui.get(aaTabs) == "Keybinds" and isEnabled)
    --ui.set_visible(ctx.ui.menu.Normal.resolver2), 
    


    for i, feature in pairs(menu.visualsTab) do
        if type(feature) ~= "table" then
            ui.set_visible(feature, isVisualsTab and isEnabled)
        end
	end 
--2.0

    for i, feature in pairs(menu.keys.manualTab) do
        if type(feature) ~= "table" then
            ui.set_visible(feature,  keys2 and ui.get(aaTabs) == "Keybinds" and isEnabled)
        end
	end 


    ui.set_visible(menu.visualsTab.logsClr, ui.get(menu.visualsTab.logs) and isVisualsTab and isEnabled and ui.get(menu.visualsTab.logs_style) == "Default")
    ui.set_visible(menu.visualsTab.indicatorsClr, ui.get(menu.visualsTab.indicators) == "New" or ui.get(menu.visualsTab.indicators) == "Second" and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.arrowIndicatorStyle, ui.get(menu.visualsTab.arrows) and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.arrowClr, ui.get(menu.visualsTab.arrows) and isVisualsTab and isEnabled)
    --ui.set_visible(menu.visualsTab.watermarkClr, ui.get(menu.visualsTab.watermark) and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.watermark_opt, not ui.get(menu.visualsTab.watermark) and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.watermark_pos, not ui.get(menu.visualsTab.watermark) and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.watermark_og_opt, ui.get(menu.visualsTab.watermark) and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.logs_style, ui.get(menu.visualsTab.logs) and isVisualsTab and isEnabled)
    ui.set_visible(menu.visualsTab.velocity_ada, ui.get(menu.visualsTab.arrowIndicatorStyle) == "Teamskeet" and isVisualsTab and isEnabled)

    ui.set_visible(menu.resolver.debug_style, func.includes(ui.get(menu.resolver.xddd), "Debug"))
    ui.set_visible(menu.configTab.export, isCFGTab and isEnabled)
    
    for i, feature in pairs(menu.miscTab) do
        if type(feature) ~= "table" then
            ui.set_visible(feature, isMiscTab and isEnabled)
        end
	end
    ui.set_visible(menu.miscTab.fastLadder, ui.get(menu.miscTab.fastLadderEnabled) and isMiscTab and isEnabled)
    ui.set_visible(menu.miscTab.animations, ui.get(menu.miscTab.animationsEnabled) and isMiscTab and isEnabled)

    for i, feature in pairs(menu.configTab) do
		ui.set_visible(feature, isCFGTab and isEnabled)
	end

    -- for i, feature in pairs(menu.configTab) do
	-- 	ui.set_visible(feature, isLogicBuilder and isCFGTab and isEnabled)
	-- end

    if not isEnabled and not saved then
        func.resetAATab()
        ui.set(refs.fsBodyYaw, isEnabled)
        ui.set(refs.enabled, isEnabled)
        saved = true
    elseif isEnabled and saved then
        ui.set(refs.fsBodyYaw, not isEnabled)
        ui.set(refs.enabled, isEnabled)
        saved = false
    end
    func.setAATab()

end)

-------------------------------------------------------------------------------------------------reso

local miss_save = 0

local function GetPlayerVelocity(player)
    local vec_vel = vector(entity.get_prop(player, "m_vecVelocity"))
    return math.floor(math.sqrt(vec_vel.x^2 + vec_vel.y^2) + 0.5)
end

local function in_air(player)
    local flags = entity.get_prop(player, "m_fFlags")

    if bit.band(flags, 1) == 0 then
        return true
    end

    return false
end

-- local function normalize_yaw1(yaws)
--     while yaws > 180 do
--         yaws = yaws - 360
--     end
--     while yaws < -180 do
--         yaws = yaws + 360
--     end
--     return yaws
-- end

local get_entities = function(enemy_only, alive_only)
    local enemy_only = enemy_only ~= nil and enemy_only or false
    local alive_only = alive_only ~= nil and alive_only or true

    local result = {}

    local me = entity.get_local_player()
    local player_resource = entity.get_player_resource()

    for player = 1, globals.maxplayers() do
        local is_enemy, is_alive = true, true

        if enemy_only and not entity.is_enemy(player) then
            is_enemy = false
        end
        if is_enemy then
            if alive_only and entity.get_prop(player_resource, 'm_bAlive', player) ~= 1 then
                is_alive = false
            end
            if is_alive then
                table.insert(result, player)
            end
        end
    end

    return result
end

local vector_c = {}
local vector_mt = {
    __index = vector_c
}

function vector_c.eye_position(player)
    local origin = vector(entity.get_prop(player, "m_vecOrigin"))
    local duck_amount = entity.get_prop(eid, "m_flDuckAmount") or 0

    origin.z = origin.z + 46 + (1 - duck_amount) * 18

    return origin
end

local function get_anim_layer(b, c)
    c = c or 1;
    b = ffi.cast(classptr, b)
    return ffi.cast('struct animation_layer_t**', ffi.cast('char*', b) + 0x2990)[0][c]
end

yaw_save = 0

local function in_air(player)
    local flags = entity.get_prop(player, "m_fFlags")

    if bit.band(flags, 1) == 0 then
        return true
    end

    return false
end

-------------------------------------------------------------------------------------------------reso

local function ResolveJitter(player, currentYaw, currentEyeAnglesX, currentEyeAnglesY)
    local function AngleBetween(v1, v2)
        return math.deg(math.acos((v1.x * v2.x + v1.y * v2.y) / (math.sqrt(v1.x * v1.x + v1.y * v1.y) * math.sqrt(v2.x * v2.x + v2.y * v2.y))))
    end

    local animstate = GetAnimationState(player) 


    local yaw_body_xd = entity.get_prop(player, "m_flPoseParameter", 11)

    local currentYaw = entity.get_prop(player, "m_flLowerBodyYawTarget") --lowerbody
    local pitchYaw = entity.get_prop(player, "m_angEyeAngles[0]") --pitch
   -- local currentYaw1 = math.floor(normalize_yaw1(entity.get_prop(player, "m_angEyeAngles[1]"))) --yaw
    local currentYaw3 = entity.get_prop(player, "m_flLowerBodyYawTarget")


    local angle = math.deg(math.atan2(entity.get_prop(player, "m_angEyeAngles[1]") - entity.get_prop(player, "m_flLowerBodyYawTarget"), entity.get_prop(player, "m_angEyeAngles[0]")))
    local yawik = math.min(60, math.max(-60, (angle * 10000)))



    local enemyEyeAnglesY = entity.get_prop(player, "m_angEyeAngles[1]")
    local lowerBodyYawTarget = entity.get_prop(player, "m_flLowerBodyYawTarget")
    local current_time = globals.tickcount()
    local velocity = GetPlayerVelocity(player)
    local isinair = in_air(player)
    local enemyPosition = vector(entity.get_prop(player, "m_vecOrigin"))
    local nDuckAmount = entity.get_prop(player, "m_flDuckAmount")
    local slowwalkMultiplier = 0.8
    local duckMultiplier = 0.75
    local local_origin = vector(entity.get_prop(local_player, "m_vecAbsOrigin"))
    local enemyDistance = vector(entity.get_prop(player, "m_vecOrigin"))
    enemyDistance = local_origin:dist(enemyDistance)
    local r41_138 = require("vector");


    local prefix = function(x, z) 
        return (z and ("\aC84545FFtabsense \a698a6dFF~ \a414141FF(\ab5b5b5FF%s\a414141FF) \aC84545FF%s"):format(x, z) or ("\aC84545FFtabsense \a698a6dFF~ \aC84545FF%s"):format(x)) 
    end

   local yaws2 = yawik
    
  local r109_138 = false;
   if func.includes(ui.get(menu.resolver.other_menu), "Math Random Resolver") then
           plist.set(player, "Force body yaw", true)
           plist.set(player, "Force body yaw value", math.random(-60, 60))
--    elseif func.includes(ui.get(menu.resolver.xddd), "Resolver [Recode 0.1]") then
--     if func.includes(ui.get(menu.resolver.xddd), "Resolver [Recode 0.1]") then
--         r109_138 = true;
--         for r3_198, r4_198 in ipairs(entity.get_players(true)) do
--             local r6_198 = r35_138.new(r4_198);
--             local r8_198 = {entity.get_prop(r4_198, "m_angEyeAngles")};
--             local r7_198 = math.floor(math.min(60, (entity.get_prop(player, "m_flPoseParameter", 11) * 120) - 60));
--             local r10_1982 = math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw)));
--             if (math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw))) < (r7_198 + 1)) and ((r7_198 - 1) < math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw)))) then
--                 plist.set(player, "Force body yaw", false);
--             else
--                 local ang1 = entity.get_prop(player, "m_angEyeAngles[1]") * (180 / math.pi)
--                 local ang2 = entity.get_prop(player, "m_angEyeAngles[0]") * (180 / math.pi)
--                 local delta = r8_198[2] - r6_198:get_anim_state().current_feet_yaw * r6_198:get_anim_overlay().playback_rate
--                 local delta2 = r8_198[2] - r8_198[3] * r6_198:get_anim_overlay().playback_rate
--                 local r10_198 =  r8_198[2] - r6_198:get_anim_state().current_feet_yaw * r6_198:get_anim_overlay().playback_rate
--                 local r5_198 = {r89_0.get_bounding_box(r4_198)};
--                 local r6_198 = r35_138.new(r4_198);
--                 local r7_198 = math.floor(math.min(60, (entity.get_prop(r4_198, "m_flPoseParameter", 11) * 120) - 60));
--                 local r8_198 = {entity.get_prop(r4_198, "m_angEyeAngles")};
--                 local r9_198 = r1_0.band(entity.get_prop(r4_198, "m_fFlags"), 1) == 1;
--                 local isinair = in_air(player)

--                 local lastyawupdate = globals.tickcount() + 10
--                 local modelside = delta2

--                 local eye_angles = entity.get_prop(r4_198, "m_angEyeAngles")
                
--                 local foot_yaw = r6_198:get_anim_state().current_feet_yaw
                
--                 local eye_foot_delta = (r8_198[2] - foot_yaw) % 360
            
        

--                 if eye_foot_delta > 180 then
--                     eye_foot_delta = eye_foot_delta - 360
--                 elseif eye_foot_delta < -180 then
--                     eye_foot_delta = eye_foot_delta + 360
--                 end

--                 local yaws = eye_foot_delta


--                 if velocity == 0 or velocity == 1 then
--                     plist.set(player, "Force body yaw", false)    
--                -- print("stand")
--                 elseif (math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw))) < (r7_198 + 1)) and ((r7_198 - 1) < math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw)))) then
--                     plist.set(player, "Force body yaw", false);
--                     --print("delta")
--                 elseif delta == 0 then
--                     plist.set(player, "Force body yaw", false)
--                    -- print("0")
--                 elseif r6_198:get_anim_state().duck_amount > 0.5 and not isinair then
--                         r10_198 = r10_198 / 2;
--                      --   print("duck")
--                 elseif r10_198 > 90 then
--                     plist.set(player, "Force body yaw", true);
--                     plist.set(player, "Force body yaw value", yaws); --r10_198
--                    -- print("90")
--                 elseif isinair then --NOWE DO TESTU WCZESNIEJ NIE BYLO
--                     plist.set(player, "Force body yaw", true)
--                     plist.set(player, "Force body yaw value", yaws)  --r10_198
--                     if plist.set(player, "Force body yaw value", yaws) then
--                        -- print("inair-yaws")
--                     elseif plist.set(player, "Force body yaw value", r10_198) then 
--                        -- print("r10")
--                     end
--                 elseif math.abs(delta - delta2) == 0 then
--                     plist.set(player, "Force body yaw", true)
--                     plist.set(player, "Force body yaw value", 0)
--                    -- print("abs")
--                 elseif r41_138(entity.get_prop(player, "m_vecVelocity")):length2d() < 2 then
--                     plist.set(player, "Force body yaw", false);
--                    -- print("2d")
--                 elseif lastyawupdate > globals.tickcount() and eye_foot_delta == 0 then 
--                     plist.set(player, "Force body yaw value", (modelside) > 0 and 60 or -60)
--                    -- print("lastyaw")
--                 else
--                     plist.set(player, "Force body yaw", true)
--                     plist.set(player, "Force body yaw value", yaws) 
--                 end
--             end
--         end
--     elseif r109_138 == true then
--         for r3_198 = 1, globals.maxplayers(), 1 do
--             if (r25_138(r3_198) == "CCSPlayer") and (entity.get_prop(r3_198, "m_iTeamNum") ~= entity.get_prop(r28_138(), "m_iTeamNum")) then
--                 plist.set(r3_198, "Force body yaw", false);
--                 plist.set(r3_198, "Force body yaw value", 0);
--             end
--         end
--         r109_138 = false;
--     end
   end


   

-- elseif ui.get(menu.resolver.delta_mode) == "AI [ALPHA]" then
   
--     if ui.get(menu.resolver.delta_mode) == "AI [ALPHA]" then
--         r109_138 = true;
--         for r3_198, r4_198 in ipairs(entity.get_players(true)) do
--             local r5_198 = {r89_0.get_bounding_box(r4_198)};
--             local r6_198 = r35_138.new(r4_198);
--             local r7_198 = math.floor(math.min(60, (entity.get_prop(r4_198, "m_flPoseParameter", 11) * 120) - 60));
--             local r8_198 = {entity.get_prop(r4_198, "m_angEyeAngles")};
--             local r10_1982 = math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw)));
--             local r9_198 = r1_0.band(entity.get_prop(r4_198, "m_fFlags"), 1) == 1;

--              if velocity == 0 or velocity == 1 then
--                  plist.set(player, "Force body yaw", false)
--              end

--             if (math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw))) < (r7_198 + 1)) and ((r7_198 - 1) < math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw)))) then
--                 plist.set(r4_198, "Force body yaw", false);
--             else
--                 local r10_198 = math.floor(math.max(-60, math.min(60, r8_198[2] - r6_198:get_anim_state().current_feet_yaw)));
--                 if r87_0.is_menu_open() then
--                   --  plist.set(r4_198, "Force body yaw", false);
--                    -- plist.set(r4_198, "Force body yaw value", 0);
--                 elseif r41_138(entity.get_prop(r4_198, "m_vecVelocity")):length2d() < 2 then
--                     plist.set(r4_198, "Force body yaw", false);
--                 else
--                     if not r9_198 then
--                         r10_198 = r10_198 / 2;
--                     elseif r6_198:get_anim_state().duck_amount > 0.5 then
--                         r10_198 = r10_198 / 2;
--                     elseif r10_198 ~= 60 then
--                         if r10_198 == -60 then
--                             plist.set(r4_198, "Force body yaw", false);
--                         end
--                     else
--                         plist.set(r4_198, "Force body yaw", false);
--                     end
--                     plist.set(r4_198, "Force body yaw", true);
--                     plist.set(r4_198, "Force body yaw value", r10_198);
--                  end
--             end
--         end
--     elseif r109_138 == true then
--         for r3_198 = 1, globals.maxplayers(), 1 do
--             if (r25_138(r3_198) == "CCSPlayer") and (entity.get_prop(r3_198, "m_iTeamNum") ~= entity.get_prop(r28_138(), "m_iTeamNum")) then
--                 plist.set(r3_198, "Force body yaw", false);
--                 plist.set(r3_198, "Force body yaw value", 0);
--             end
--         end
--         r109_138 = false;
--     end

-- end

    yaw_save = plist.get(player, "Force body yaw value")
end


local function Resolver(player)
        if entity.is_dormant(player) or entity.get_prop(player, "m_bDormant") then
            return
        end

        if func.includes(ui.get(menu.resolver.other_menu), "Defensive Resolver") then
            for k,ent in ipairs(entity.get_players(true)) do
                local jump = bit.band(entity.get_prop(ent, "m_fFlags"), 1) 
                local y,p = entity.get_prop(ent,"m_angEyeAngles")
                local ent_flags = entity.get_esp_data(ent).flags
                
        
                if jump == 0 then
                    if y < -1 then
                        plist.set(ent,"Force pitch",true)
                        plist.set(ent,"Force pitch value",0)
                        plist.set(ent,"Force body yaw",true)
                        plist.set(ent,"Force body yaw value",0)
                      --  ui.set(accuracy_boost, "Low")
                    else
                        plist.set(ent,"Force pitch",false)
                      --  ui.set(accuracy_boost, accuracy_boost_save)
                    end
                end
            end
        end

        ResolveJitter(player)
end

local function ResolverUpdate()
    local enemies = entity.get_players(true)
    for i, enemy_ent in ipairs(enemies) do
        if enemy_ent and entity.is_alive(enemy_ent) and entity.get_prop(enemy_ent, "m_iTeamNum") ~= entity.get_prop(entity.get_local_player(), "m_iTeamNum") then
            Resolver(enemy_ent)
        end
    end
end


local function aim_hit(e)
    miss_save = 0
end

client.set_event_callback('round_start', function()
    miss_save = 0
end)

client.set_event_callback("aim_hit", aim_hit)
client.set_event_callback("setup_command", ResolverUpdate)
-------------------------------------------------------------------------------------------------reso


client.set_event_callback("shutdown", function()
    if hsValue ~= nil then
        ui.set(refs.fakeLag[1], hsValue)
    end
    if clanTag ~= nil then
        client.set_clan_tag("")
    end
    if dtSaved ~= nil then
        ui.set(refs.dt[3], "Defensive")
    end
    func.setAATab(true)
end)