
--local variables for API. Automatically generated by https://github.com/simpleavaster/gslua/blob/master/authors/sapphyrus/generate_api.lua
client_latency, client_log, client_draw_rectangle, client_draw_circle_outline, client_userid_to_entindex, client_draw_indicator, client_draw_gradient, client_set_event_callback, client_screen_size, client_eye_position = client.latency, client.log, client.draw_rectangle, client.draw_circle_outline, client.userid_to_entindex, client.draw_indicator, client.draw_gradient, client.set_event_callback, client.screen_size, client.eye_position
client_draw_circle, client_color_log, client_delay_call, client_draw_text, client_visible, client_exec, client_trace_line, client_set_cvar = client.draw_circle, client.color_log, client.delay_call, client.draw_text, client.visible, client.exec, client.trace_line, client.set_cvar
client_world_to_screen, client_draw_hitboxes, client_get_cvar, client_draw_line, client_camera_angles, client_draw_debug_text, client_random_int, client_random_float = client.world_to_screen, client.draw_hitboxes, client.get_cvar, client.draw_line, client.camera_angles, client.draw_debug_text, client.random_int, client.random_float
entity_get_local_player, entity_is_enemy, entity_hitbox_position, entity_get_player_name, entity_get_steam64, entity_get_bounding_box, entity_get_all, entity_set_prop = entity.get_local_player, entity.is_enemy, entity.hitbox_position, entity.get_player_name, entity.get_steam64, entity.get_bounding_box, entity.get_all, entity.set_prop
entity_is_alive, entity_get_player_weapon, entity_get_prop, entity_get_players, entity_get_classname = entity.is_alive, entity.get_player_weapon, entity.get_prop, entity.get_players, entity.get_classname
globals_realtime, globals_absoluteframetime, globals_tickcount, globals_curtime, globals_mapname, globals_tickinterval, globals_framecount, globals_frametime, globals_maxplayers = globals.realtime, globals.absoluteframetime, globals.tickcount, globals.curtime, globals.mapname, globals.tickinterval, globals.framecount, globals.frametime, globals.maxplayers
ui_new_slider, ui_new_combobox, ui_reference, ui_set_visible, ui_is_menu_open, ui_new_color_picker, ui_set_callback, ui_set, ui_new_checkbox, ui_new_hotkey, ui_new_button, ui_new_multiselect, ui_get = ui.new_slider, ui.new_combobox, ui.reference, ui.set_visible, ui.is_menu_open, ui.new_color_picker, ui.set_callback, ui.set, ui.new_checkbox, ui.new_hotkey, ui.new_button, ui.new_multiselect, ui.get
math_ceil, math_tan, math_log10, math_randomseed, math_cos, math_sinh, math_random, math_huge, math_pi, math_max, math_atan2, math_ldexp, math_floor, math_sqrt, math_deg, math_atan, math_fmod = math.ceil, math.tan, math.log10, math.randomseed, math.cos, math.sinh, math.random, math.huge, math.pi, math.max, math.atan2, math.ldexp, math.floor, math.sqrt, math.deg, math.atan, math.fmod
math_acos, math_pow, math_abs, math_min, math_sin, math_frexp, math_log, math_tanh, math_exp, math_modf, math_cosh, math_asin, math_rad = math.acos, math.pow, math.abs, math.min, math.sin, math.frexp, math.log, math.tanh, math.exp, math.modf, math.cosh, math.asin, math.rad
table_maxn, table_foreach, table_sort, table_remove, table_foreachi, table_move, table_getn, table_concat, table_insert = table.maxn, table.foreach, table.sort, table.remove, table.foreachi, table.move, table.getn, table.concat, table.insert
string_find, string_format, string_rep, string_gsub, string_len, string_gmatch, string_dump, string_match, string_reverse, string_byte, string_char, string_upper, string_lower, string_sub = string.find, string.format, string.rep, string.gsub, string.len, string.gmatch, string.dump, string.match, string.reverse, string.byte, string.char, string.upper, string.lower, string.sub
bit_band, client_delay_call, client_set_event_callback, entity_get_local_player, entity_get_player_weapon, entity_get_prop, print, func, select, table_insert, table_sort, type, ui_get, ui_name, ui_new_checkbox, ui_new_combobox, ui_new_multiselect, ui_reference, ui_set, ui_set_callback, ui_set_visible, xpcall, pairs = bit.band, client.delay_call, client.set_event_callback, entity.get_local_player, entity.get_player_weapon, entity.get_prop, print, func, select, table.insert, table.sort, type, ui.get, ui.name, ui.new_checkbox, ui.new_combobox, ui.new_multiselect, ui.reference, ui.set, ui.set_callback, ui.set_visible, xpcall, pairs
--end of local variables
------------------
----ScriptLock----
------------------

--client.log(keyvalue)


----------------------------------------------------------------------------------
client.color_log(0, 0, 0, "-------------------------------------------------------")
client.color_log(255, 0, 0, "welcome to hellbanianz.")
client.color_log(0, 0, 0, "-------------------------------------------------------")
----------------------------------------------------------------------------------

--database.write("key", keyvalue)
------------
-----UI-----
------------

------------DYNAMIC FOV
dynamicfov_enable = ui_new_checkbox('RAGE', 'Other', 'Dynamic FOV')
dynamicfov_select = ui_new_combobox('RAGE', 'Other', 'Dynamic FOV', 'Default', 'Adaptive weapon dynamic FOV')
dynamicfov_weapons = ui_new_combobox('RAGE', 'Other', 'Dynamic FOV Weapons', 'Pistols', 'Rifles', 'Awp/scout/auto', 'Smg/other')
dynamicfov_min = ui_new_slider('RAGE', 'Other', 'Dynamic FOV Min', 1, 180, 3, true, '°', 1)
dynamicfov_max = ui_new_slider('RAGE', 'Other', 'Dynamic FOV Max', 1, 180, 69, true, '°', 1)
dynamicfov_auto_factor = ui_new_slider('RAGE', 'Other', 'Dynamic FOV Auto Factor', 0, 250, 100, true, 'x', 0.01)
--pistols
dynamicfov_minpistol = ui_new_slider('RAGE', 'Other', 'Pistol Dynamic FOV Min', 1, 180, 3, true, '°', 1)
dynamicfov_maxpistol = ui_new_slider('RAGE', 'Other', 'Pistol Dynamic FOV Max', 1, 180, 69, true, '°', 1)
--rifle
dynamicfov_minrifle = ui_new_slider('RAGE', 'Other', 'Rifle Dynamic FOV Min', 1, 180, 3, true, '°', 1)
dynamicfov_maxrifle = ui_new_slider('RAGE', 'Other', 'Rifle Dynamic FOV Max', 1, 180, 69, true, '°', 1)
--scoped
dynamicfov_minscope = ui_new_slider('RAGE', 'Other', 'Awp/scout/auto Dynamic FOV Min', 1, 180, 3, true, '°', 1)
dynamicfov_maxscope = ui_new_slider('RAGE', 'Other', 'Awp/scout/auto Dynamic FOV Max', 1, 180, 69, true, '°', 1)
--other
dynamicfov_minother = ui_new_slider('RAGE', 'Other', 'Smg/other Dynamic FOV Min', 1, 180, 3, true, '°', 1)
dynamicfov_maxother = ui_new_slider('RAGE', 'Other', 'Smg/other Dynamic FOV Max', 1, 180, 69, true, '°', 1)
------------DYNAMIC LEGIT AA
legitAA = ui_new_checkbox("AA", "Anti-aimbot angles", "Legit anti-aim")
legitAAbase = ui_new_combobox("AA", "Anti-aimbot angles", "\n aa_legit_base", "Manual", "Dynamic")
LegitAAHotkey = ui_new_hotkey("AA", "Anti-aimbot angles", "Anti-aim switch key", true)
LegitAABreaker = ui_new_combobox("AA", "Anti-aimbot angles", "Anti-aim mode", "Smart", "Maximum", "Fast", "Slow", "Break bruteforce")
brutemode2 = ui.new_combobox("aa", "anti-aimbot angles", "Break Mode", "Slow", "Fast", "Jitter")

ui_indicator_combobox4 = ui.new_combobox("AA", "Anti-aimbot angles", "Anti-aim indicator", "Off", "Metro", "Point arrows", "Dashes")
ui_indicator_color_picker4 = ui.new_color_picker("AA", "Anti-aimbot angles", "Indicator colour", "0", "115", "255", "255")

enableaawm = ui.new_checkbox('AA', 'Anti-aimbot angles', 'Custom AA While moving')
legitaamoving = ui.new_combobox("AA", "Anti-aimbot angles", "\n aa_legit_bases", 'Off', 'Slow walk', 'Moving', 'Standing')
--slow walk
slowmode = ui.new_combobox('AA', 'Anti-aimbot angles', "Slow walk AA", "Smart", "Maximum", "Fast", "Slow", "Break bruteforce")
--move
movemode = ui.new_combobox('AA', 'Anti-aimbot angles', "Moving AA", "Smart", "Maximum", "Fast", "Slow", "Break bruteforce")
--stand
standmode = ui.new_combobox('AA', 'Anti-aimbot angles', "Stand AA", "Smart", "Maximum", "Fast", "Slow", "Break bruteforce")

------------TRIGGERMAGNET
tm_cb = ui.new_checkbox("Rage", "Other", "Triggermagnet")
triggermagnet = ui.new_hotkey("Rage", "Other", "Triggermagnet", true)
typeselect = ui.new_combobox("Rage", "Other", "Select", "Default", "Advanced")

triggerdmg = ui.new_slider("Rage", "Other", "Minimum damage override", 1, 100, 3, true)
triggerhtc = ui.new_slider("Rage", "Other", "Hitchance override", 1, 100, 3, true, "%")
------------AUTOWALL
trans_values2 = {
    [1] = "1%", [2] = "2%", [3] = "3%", [4] = "4%", [5] = "5%", [6] = "6%", [7] = "7%", [8] = "8%", [9] = "9%", [10] = "10%", [11] = "11%", [12] = "12%", [13] = "13%", [14] = "14%", [15] = "15%", [16] = "16%", [17] = "17%", [18] = "18%", [19] = "19%", [20] = "20%", [21] = "21%", [22] = "22%", [23] = "23%", [24] = "24%", [25] = "25%", [26] = "26%", [27] = "27%", [28] = "28%", [29] = "29%", [30] = "30%", [31] = "31%", [32] = "32%", [33] = "33%", [34] = "34%", [35] = "35%", [36] = "36%", [37] = "37%", [38] = "38%", [39] = "39%", [40] = "40%", [41] = "41%", [42] = "42%", [43] = "43%", [44] = "44%", [45] = "45%", [46] = "46%", [47] = "47%", [48] = "48%", [49] = "49%", [50] = "50%", [51] = "51%", [52] = "52%", [53] = "53%", [54] = "54%", [55] = "55%", [56] = "56%", [57] = "57%", [58] = "58%", [59] = "59%", [60] = "60%", [61] = "61%", [62] = "62%", [63] = "63%", [64] = "64%", [65] = "65%", [66] = "66%", [67] = "67%", [68] = "68%", [69] = "69%", [70] = "70%", [71] = "71%", [72] = "72%", [73] = "73%", [74] = "74%", [75] = "75%", [76] = "76%", [77] = "77%", [78] = "78%", [79] = "79%", [80] = "80%", [81] = "81%", [82] = "82%", [83] = "83%", [84] = "84%", [85] = "85%", [86] = "86%", [87] = "87%", [88] = "88%", [89] = "89%", [90] = "90%", [91] = "91%", [92] = "92%", [93] = "93%", [94] = "94%", [95] = "95%", [96] = "96%", [97] = "97%", [98] = "98%", [99] = "99%", [100] = "100%",
}
autowallbutton = ui.new_checkbox("RAGE", "Other", "Autowall")
autowalltoggle = ui.new_hotkey("RAGE", "Other", "Automatic Penetration Toggle", true)
auto_autowall = ui.new_multiselect("RAGE", "Other", "Auto autowall modes", "Transparent props", "Penetration reticle", "Min dmg override", "Dynamic autowall FOV", "Autowall if shot me", "Edge autowall", "Autowall specific players", "Autowall if was visible")
slider_trans = ui.new_slider('rage', 'other', 'Transparent props', 1, 100, 1, true, "", 1, trans_values2)

dynamicfov_minaw = ui_new_slider('RAGE', 'Other', 'Dynamic FOV Min', 1, 180, 3, true, '°', 1)
dynamicfov_maxaw = ui_new_slider('RAGE', 'Other', 'Dynamic FOV Max', 1, 180, 69, true, '°', 1)
dynamicfov_auto_factoraw = ui_new_slider('RAGE', 'Other', 'Dynamic FOV Auto Factor', 0, 250, 100, true, 'x', 0.01)
autowalldmg = ui.new_slider("Rage", "Other", "Autowall Minimum damage override", 1, 100, 3, true)
edgeautowallbutton = ui.new_checkbox("Players", "Adjustments", "Edge autowall")
edgeautowalltype = ui.new_combobox("RAGE", "Other", "Edge autowall players", "All players", "Selected players")
legit_pen_threshold_ref = ui.new_slider("RAGE", "Other", "Visible hitbox threshold", 0, 18, 4, true)

beforedelay = ui.new_slider("RAGE", "Other", "How long until autowall turns on", 1, 1000, 1, true, 's')
autodely = ui.new_slider("RAGE", "Other", "How long autowall stays on", 1, 1000, 1, true, 's')
autowallplayerbutton = ui.new_checkbox("PLAYERS", "Adjustments", 'Autowall this player')
_autowall_mode_auto_trigger_delay = ui.new_slider('rage', 'other', 'How long autowall stays on after seeing player', 0, 2500, 850, true, 'ms')
autowallvar1 = false
autowallvar2 = false
autowallvar3 = false
autowallvar4 = false
autowallvar5 = false
autowallvar6 = false
------------INDICATORS
indicate_enable = ui.new_checkbox("RAGE", "Other", "Indicators")
indicate_on = ui.new_combobox("RAGE", "Other", "Indicators (drag to move small and big)", "Off", "Small", "Big", "Default")
indicate_color = ui.new_color_picker("RAGE", "Other", "Indicators")
indicate_select = ui.new_multiselect("RAGE", "Other", "Indicator select", "Triggermagnet", "Silent aim", "Autowall", "Legitbot improvements", "FOV", "Bruteforce", "Force body aim", "Safe point")
indicateposition = ui.new_slider("RAGE", "Other", "Reposition Indicators X", 0, 40, 0, true, "x")
------------FLAGS
flag_enable = ui.new_checkbox("RAGE", "Other", "Flags")
flag_color = ui.new_color_picker("RAGE", "Other", "\n flags")
flag_select = ui.new_multiselect("RAGE", "Other", "\n flags", "Override")
------------FAKELAG
flcheckbox = ui.new_checkbox("AA", "Fake lag", "Fake lag")
flmulti = ui.new_multiselect("AA", "Fake lag", "Fake lag", "Fakelag presets", "Custom fake lag while moving")
legitflmode = ui_new_combobox("AA", "Fake lag", "\n aa_legit_fl_mode", {
    "On peek",
    "On peek & visibility",
    "Always on",
})
------------LEGITBOT IMPROVEMENTS
legitbotimprovements = ui.new_checkbox("RAGE", "Other", "Legitbot improvements")
------------SILENT AIM
silentbuttonenable = ui.new_checkbox("RAGE", "Other", "Silent settings")
silentmulti = ui.new_multiselect("RAGE", "Other", "Silent aim settings", "Silent aim on key", "Silent aim if in fov", "Silent aim in distance", "Silent aim while slow walking")
silentkey = ui.new_hotkey("RAGE", "Other", "Silent Aim On Toggle")
silentvar1 = false
silentvar2 = false
silentvar3 = false
silentvar4 = false
silentvar5 = false
------------SILENT AIM IF FOV
silentfovslider = ui.new_slider("RAGE", "Other", "Silent aim if in fov", 1, 180, 1, true, "°")
------------SILENT AIM IN DISTANCE
silentdistance = ui.new_slider('RAGE', 'Other', 'Silent aim enable in distance', 1, 3000, 1)
distancecircle = ui.new_checkbox("rage", "other", "Distance circle")
------------RESOLVER
--OVERRIDE
overridebutton = ui.new_checkbox("rage", "other", "Resolver")
resolverselect = ui.new_combobox("rage", "other", "Resolver", "Override", "Opposite resolver")
overridekey = ui.new_hotkey("rage", "other", "Override key: Right/Left/Off")

oppositeenable = ui.new_checkbox("PLAYERS", "Adjustments", "Enable resolver")
------------CUSTOM FAKELAG TRIGGERS
enablecfl = ui.new_checkbox('AA', 'Fake lag', 'Custom fake lag triggers')
enablecflcombo = ui.new_combobox('AA', 'Fake lag', 'Custom fake lag triggers', 'Off', 'Slow walk', 'Moving', 'Standing', 'Jumping')
--slow walk
slowvariance = ui.new_slider('AA', 'Fake lag', 'Slowwalk variance', 0, 100, 0, true, '%')
slowlimit = ui.new_slider('AA', 'Fake lag', 'Slowwalk limit', 1, 14, 1, true)
slowamount = ui.new_combobox('AA', 'Fake lag', 'Slowwalk amount', 'Dynamic', 'Maximum', 'Fluctuate')
--move
movevariance = ui.new_slider('AA', 'Fake lag', 'Moving variance', 0, 100, 0, true, '%')
movelimit = ui.new_slider('AA', 'Fake lag', 'Moving limit', 1, 14, 1, true)
moveamount = ui.new_combobox('AA', 'Fake lag', 'Moving amount', 'Dynamic', 'Maximum', 'Fluctuate')
--stand
standvariance = ui.new_slider('AA', 'Fake lag', 'Standing variance', 0, 100, 0, true, '%')
standlimit = ui.new_slider('AA', 'Fake lag', 'Standing limit', 1, 14, 1, true)
standamount = ui.new_combobox('AA', 'Fake lag', 'Standing amount', 'Dynamic', 'Maximum', 'Fluctuate')
--stand
jumpvariance = ui.new_slider('AA', 'Fake lag', 'Jumping variance', 0, 100, 0, true, '%')
jumplimit = ui.new_slider('AA', 'Fake lag', 'Jumping limit', 1, 14, 1, true)
jumpamount = ui.new_combobox('AA', 'Fake lag', 'Jumping amount', 'Dynamic', 'Maximum', 'Fluctuate')
------------killsay
talkshitenable = ui.new_checkbox('RAGE', 'Other', 'Killsay')
talkshittype = ui.new_combobox('RAGE', 'Other', "Killsay type", 'Basic kill says', 'Custom')
talkshittext = ui.new_textbox('RAGE', 'Other', "\n text")
------------
--REFRENCE--
------------

ragebot_maximum_fov = ui.reference('RAGE', 'Aimbot', 'maximum fov')
forcesafepoint = ui.reference('RAGE', 'Aimbot', 'Force safe point')

aaenablers = ui.reference("AA", "Anti-aimbot angles", "Enabled")
pitch = ui.reference("AA", "Anti-aimbot angles", "Pitch")
yaw_base = ui.reference("AA", "Anti-aimbot angles", "Yaw base")
yaw, yaw_num = ui.reference("AA", "Anti-aimbot angles", "Yaw")
yaw_jitter = ui.reference("AA", "Anti-aimbot angles", "Yaw jitter")
body, body_num = ui.reference("AA", "Anti-aimbot angles", "Body yaw")
limit = ui.reference("AA", "Anti-aimbot angles", "Fake yaw limit")

rageautofire = ui.reference("Rage", "Aimbot", "Automatic Fire")
ragebot, ragebotmode = ui.reference("Rage", "Aimbot", "Enabled")
autowall = ui.reference("RAGE", "Aimbot", "Automatic Penetration")
min_dmg = ui.reference('rage', 'aimbot', 'minimum damage')
trans = ui.reference('VISUALS', 'Effects', 'Transparent props')
FOVS5 = ui.reference('RAGE', 'AIMBOT', 'Maximum FOV')
preticle = ui.reference("VISUALS", "Other ESP", "Penetration reticle")
ref_fl = ui.reference("AA", "Fake lag", "Limit")
ref_fakeduck = ui.reference("Rage", "Other", "Duck peek assist")
trigger = ui.reference("RAGE", "Aimbot", "Automatic fire")
rage_enabl = ui.reference("RAGE", "Aimbot", "Enabled")
silent = ui.reference("RAGE", "Aimbot", "Silent aim")
force_body_aim = ui.reference("RAGE", "Other", "Force body aim")
Max_f0v = ui.reference("RAGE", "Aimbot", "Maximum FOV")
selectedplayer = ui.reference("players", "players", "player list")
forcebody1, body_slider1 = ui.reference("players", "adjustments", "force body yaw")
resetlist = ui.reference("players", "players", "reset all")
applyall = ui.reference("players", "adjustments", "Apply to all")
fakelag_enable, fakelag_key = ui.reference("AA", "Fake lag", "Enabled")
fl, fl_enable = ui.reference("AA", "Fake lag", "Enabled")
ref_aimbot_enabled = ui.reference("RAGE", "Aimbot", "Enabled")
ui_fd = ui.reference("Rage", "Other", "Duck peek assist")
forcebody = ui.reference("players", "adjustments", "force body yaw")
body_slider = ui.reference("PLAYERS", "Adjustments", "Force body yaw value")
resetlist = ui.reference("players", "players", "reset all")
applyall = ui.reference("players", "adjustments", "Apply to all")
autodirection, autodirection_key = ui.reference("AA", "Anti-aimbot angles", "Freestanding")
edgeyaw = ui.reference("AA", "Anti-aimbot angles", "Edge yaw")
bodyyaw_freestand = ui.reference("AA", "Anti-aimbot angles", "Freestanding body yaw")
fakelag_limit = ui.reference("AA", "Fake lag", "Limit")
checkbox_reference, hotkey_reference = ui.reference("AA", "Other", "Slow motion")
brightness, adjustment = ui.reference("Visuals", "Effects", "Brightness adjustment")
variance = ui.reference("AA", "Fake lag", "Variance")
amount = ui.reference("AA", "Fake lag", "Amount")
hitchance = ui.reference("RAGE", "Aimbot", "Minimum hit chance")
thirdpersonk, forcethirdpkey = ui.reference("VISUALS", "Effects", "Force third person (alive)")
thirdpersondead = ui.reference("VISUALS", "Effects", "Force third person (dead)")
infiniteduck = ui.reference("MISC", "Movement", "Infinite duck")

getui = ui.get

function table_contains(tbl, value)
    for i = 1, #tbl do
        if tbl[i] == value then
            return true
        end
    end
    return false
end

--adaptive weapon

bit_band, client_delay_call, client_set_event_callback, entity_get_local_player, entity_get_player_weapon, entity_get_prop, print, func, select, table_insert, table_sort, type, ui.get, ui_name, ui_new_checkbox, ui_new_combobox, ui_new_multiselect, ui_reference, ui.set, ui.set_callback, ui.set_visible, xpcall, pairs = bit.band, client.delay_call, client.set_event_callback, entity.get_local_player, entity.get_player_weapon, entity.get_prop, print, func, select, table.insert, table.sort, type, ui.get, ui.name, ui.new_checkbox, ui.new_combobox, ui.new_multiselect, ui.reference, ui.set, ui.set_callback, ui.set_visible, xpcall, pairs
adaptive_weapons = {
    ["Global"] = {},
    ["Auto"] = { 11, 38 },
    ["Awp"] = { 9 },
    ["Scout"] = { 40 },
    ["Desert Eagle"] = { 1 },
    ["Revolver"] = { 64 },
    ["Pistol"] = { 2, 3, 4, 30, 32, 36, 61, 63 },
    ["Rifle"] = { 7, 8, 10, 13, 16, 39, 60 },
    --["Submachine gun"]  = {17, 19, 24, 26, 33, 34},
    --["Machine gun"]     = {14, 28},
    --["Shotgun"]         = {25, 27, 29, 35},
}

local adaptive = {}
local references = {}
local callbacks = {}
local active_config = "Global"
local weapon_id_lookup_table
local run_command

function collect_keys(tbl, sort)
    local keys = {}
    sort = sort or true
    for k in pairs(tbl) do
        keys[#keys + 1] = k
    end
    if sort then
        table_sort(keys)
    end
    return keys
end
function table_contains(tbl, value)
    for i = 1, #tbl do
        if tbl[i] == value then
            return true
        end
    end
    return false
end
function create_lookup_table(tbl)
    local result = {}
    for name, weapon_ids in pairs(tbl) do
        for i = 1, #weapon_ids do
            result[weapon_ids[i]] = name
        end
    end
    return result
end

adaptive_options2 = ui_new_multiselect("RAGE", "Other", "asddd", "Log", "Visible")
adaptive_config2 = ui_new_combobox("RAGE", "Aimbot", "addd", collect_keys(adaptive_weapons))

function update_menu(visible)
    ui.set(adaptive_config2, active_config)
    if visible then
    end
end

run_command = function()
    local local_player = entity_get_local_player()
    local weapon_entindex = entity_get_player_weapon(local_player)
    local item_definition_index = bit_band(65535, entity_get_prop(weapon_entindex, "m_iItemDefinitionIndex"))
    local config_name = weapon_id_lookup_table[item_definition_index] or "Global"
    if config_name ~= active_config then
        active_config = config_name
        local options = ui.get(adaptive_options2)
        if table_contains(options, "Log") then
            print(active_config, " config loaded.")
        end
        update_menu(table_contains(options, "Visible"))
    end
end

function init()
    -- Create and reference menu items

    -- Create the lookup table
    weapon_id_lookup_table = create_lookup_table(adaptive_weapons)

    -- Set custom callbacks for the default menu items
    for name, reference in pairs(references) do
        set_callback(reference, update_settings)
    end

    -- Set callbacks for all of the adaptive menu items
    for config, items in pairs(adaptive) do
        for name, reference in pairs(items) do
            ui.set_callback(reference, handle_adaptive_config)
        end
    end
    client.set_event_callback("run_command", run_command)
end

init()

--dynamic fov
hitbox_head, hitbox_neck, hitbox_pelvis, hitbox_spine_0, hitbox_spine_1, hitbox_spine_2, hitbox_spine_3, hitbox_leg_upper_L, hitbox_leg_upper_R, hitbox_leg_lower_L, hitbox_leg_lower_R, hitbox_ankle_L, hitbox_ankle_R, hitbox_hand_L, hitbox_hand_R, hitbox_arm_upper_L, hitbox_arm_lower_L, hitbox_arm_upper_R, hitbox_arm_lower_R = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18

adaptiveselect = ui.reference('RAGE', 'Aimbot', 'addd')

dynamicfov_new_fov = 0
bool_in_fov = false
closest_enemy = nil

function dynamicfov_logic()
    local local_player = entity_get_local_player()

    if not local_player or not entity.is_alive(local_player) then
        return
    end
    if ui.get(dynamicfov_enable, true) then
    else
        return
    end
    if ui.get(dynamicfov_select) == "Adaptive weapon dynamic FOV" then
        return
    end
    local old_fov = ui.get(ragebot_maximum_fov)
    dynamicfov_new_fov = old_fov
    local enemy_players = entity_get_players(true)

    local min_fov = ui.get(dynamicfov_min)
    local max_fov = ui.get(dynamicfov_max)

    if min_fov > max_fov then
        local store_min_fov = min_fov
        min_fov = max_fov
        max_fov = store_min_fov
    end

    if #enemy_players ~= 0 then
        local own_x, own_y, own_z = client_eye_position()
        local own_pitch, own_yaw = client_camera_angles()
        local closest_enemy = nil
        local closest_distance = 999999999

        for i = 1, #enemy_players do
            local enemy = enemy_players[i]
            local enemy_x, enemy_y, enemy_z = entity_hitbox_position(enemy, 0)

            local x = enemy_x - own_x
            local y = enemy_y - own_y
            local z = enemy_z - own_z

            local yaw = ((math_atan2(y, x) * 180 / math_pi))
            local pitch = -(math_atan2(z, math_sqrt(math_pow(x, 2) + math_pow(y, 2))) * 180 / math_pi)

            local yaw_dif = math_abs(own_yaw % 360 - yaw % 360) % 360
            local pitch_dif = math_abs(own_pitch - pitch) % 360

            if yaw_dif > 180 then
                yaw_dif = 360 - yaw_dif
            end

            local real_dif = math_sqrt(math_pow(yaw_dif, 2) + math_pow(pitch_dif, 2))

            if closest_distance > real_dif then
                closest_distance = real_dif
               local closest_enemy = enemy
            end
        end

        if closest_enemy ~= nil then
            local closest_enemy_x, closest_enemy_y, closest_enemy_z = entity_hitbox_position(closest_enemy, 0)
            local real_distance = math_sqrt(math_pow(own_x - closest_enemy_x, 2) + math_pow(own_y - closest_enemy_y, 2) + math_pow(own_z - closest_enemy_z, 2))

            dynamicfov_new_fov = (3800 / real_distance) * (ui.get(dynamicfov_auto_factor) * 0.01)

            if (dynamicfov_new_fov > max_fov) then
                dynamicfov_new_fov = max_fov
            elseif dynamicfov_new_fov < min_fov then
                dynamicfov_new_fov = min_fov
            end
        end

        dynamicfov_new_fov = math_floor(dynamicfov_new_fov + 0.5)

        if (dynamicfov_new_fov > closest_distance) then
            bool_in_fov = true
        else
            bool_in_fov = false
        end
    else
        dynamicfov_new_fov = min_fov
        bool_in_fov = false
    end

    if dynamicfov_new_fov ~= old_fov then
        ui.set(ragebot_maximum_fov, dynamicfov_new_fov)
    end

end
--drawing
function on_paint(ctx)
    dynamicfov_logic()
end

client.set_event_callback('paint', on_paint)

--pistol 

function dynamicfov_logicpistol()
    local local_player = entity_get_local_player()

    if not local_player or not entity.is_alive(local_player) then
        return
    end
    if ui.get(dynamicfov_enable, true) then
    else
        return
    end
    if ui.get(dynamicfov_select) == "Adaptive weapon dynamic FOV" then
    else
        return
    end
    if ui.get(adaptiveselect) == "Desert Eagle" then
    elseif ui.get(adaptiveselect) == "Pistol" then
    elseif ui.get(adaptiveselect) == "Revolver" then
    else
        return
    end
    local old_fov = ui.get(ragebot_maximum_fov)
    dynamicfov_new_fov = old_fov
    local enemy_players = entity_get_players(true)

    local min_fov = ui.get(dynamicfov_minpistol)
    local max_fov = ui.get(dynamicfov_maxpistol)

    if min_fov > max_fov then
        local store_min_fov = min_fov
        min_fov = max_fov
        max_fov = store_min_fov
    end

    if #enemy_players ~= 0 then
        local own_x, own_y, own_z = client_eye_position()
        local own_pitch, own_yaw = client_camera_angles()
        closest_enemy = nil
        local closest_distance = 999999999

        for i = 1, #enemy_players do
            local enemy = enemy_players[i]
            local enemy_x, enemy_y, enemy_z = entity_hitbox_position(enemy, 0)

            local x = enemy_x - own_x
            local y = enemy_y - own_y
            local z = enemy_z - own_z

            local yaw = ((math_atan2(y, x) * 180 / math_pi))
            local pitch = -(math_atan2(z, math_sqrt(math_pow(x, 2) + math_pow(y, 2))) * 180 / math_pi)

            local yaw_dif = math_abs(own_yaw % 360 - yaw % 360) % 360
            local pitch_dif = math_abs(own_pitch - pitch) % 360

            if yaw_dif > 180 then
                yaw_dif = 360 - yaw_dif
            end

            local real_dif = math_sqrt(math_pow(yaw_dif, 2) + math_pow(pitch_dif, 2))

            if closest_distance > real_dif then
                closest_distance = real_dif
                closest_enemy = enemy
            end
        end

        if closest_enemy ~= nil then
            local closest_enemy_x, closest_enemy_y, closest_enemy_z = entity_hitbox_position(closest_enemy, 0)
            local real_distance = math_sqrt(math_pow(own_x - closest_enemy_x, 2) + math_pow(own_y - closest_enemy_y, 2) + math_pow(own_z - closest_enemy_z, 2))

            dynamicfov_new_fov = (3800 / real_distance) * (ui.get(dynamicfov_auto_factor) * 0.01)

            if (dynamicfov_new_fov > max_fov) then
                dynamicfov_new_fov = max_fov
            elseif dynamicfov_new_fov < min_fov then
                dynamicfov_new_fov = min_fov
            end
        end

        dynamicfov_new_fov = math_floor(dynamicfov_new_fov + 0.5)

        if (dynamicfov_new_fov > closest_distance) then
            bool_in_fov = true
        else
            bool_in_fov = false
        end
    else
        dynamicfov_new_fov = min_fov
        bool_in_fov = false
    end

    if dynamicfov_new_fov ~= old_fov then
        ui.set(ragebot_maximum_fov, dynamicfov_new_fov)
    end

end
function on_paintpistol(ctx)
    dynamicfov_logicpistol()
end
client.set_event_callback('paint', on_paintpistol)

--rifle

function dynamicfov_logicrifle()
    local local_player = entity_get_local_player()

    if not local_player or not entity.is_alive(local_player) then
        return
    end
    if ui.get(dynamicfov_enable, true) then
    else
        return
    end
    if ui.get(dynamicfov_select) == "Adaptive weapon dynamic FOV" then
    else
        return
    end
    if ui.get(adaptiveselect) == "Rifle" then
    else
        return
    end
    local old_fov = ui.get(ragebot_maximum_fov)
    dynamicfov_new_fov = old_fov
    local enemy_players = entity_get_players(true)

    local min_fov = ui.get(dynamicfov_minrifle)
    local max_fov = ui.get(dynamicfov_maxrifle)

    if min_fov > max_fov then
        local store_min_fov = min_fov
        min_fov = max_fov
        max_fov = store_min_fov
    end

    if #enemy_players ~= 0 then
        local own_x, own_y, own_z = client_eye_position()
        local own_pitch, own_yaw = client_camera_angles()
        closest_enemy = nil
        local closest_distance = 999999999

        for i = 1, #enemy_players do
            local enemy = enemy_players[i]
            local enemy_x, enemy_y, enemy_z = entity_hitbox_position(enemy, 0)

            local x = enemy_x - own_x
            local y = enemy_y - own_y
            local z = enemy_z - own_z

            local yaw = ((math_atan2(y, x) * 180 / math_pi))
            local pitch = -(math_atan2(z, math_sqrt(math_pow(x, 2) + math_pow(y, 2))) * 180 / math_pi)

            local yaw_dif = math_abs(own_yaw % 360 - yaw % 360) % 360
            local pitch_dif = math_abs(own_pitch - pitch) % 360

            if yaw_dif > 180 then
                yaw_dif = 360 - yaw_dif
            end

            local real_dif = math_sqrt(math_pow(yaw_dif, 2) + math_pow(pitch_dif, 2))

            if closest_distance > real_dif then
                closest_distance = real_dif
                closest_enemy = enemy
            end
        end

        if closest_enemy ~= nil then
            local closest_enemy_x, closest_enemy_y, closest_enemy_z = entity_hitbox_position(closest_enemy, 0)
            local real_distance = math_sqrt(math_pow(own_x - closest_enemy_x, 2) + math_pow(own_y - closest_enemy_y, 2) + math_pow(own_z - closest_enemy_z, 2))

            dynamicfov_new_fov = (3800 / real_distance) * (ui.get(dynamicfov_auto_factor) * 0.01)

            if (dynamicfov_new_fov > max_fov) then
                dynamicfov_new_fov = max_fov
            elseif dynamicfov_new_fov < min_fov then
                dynamicfov_new_fov = min_fov
            end
        end

        dynamicfov_new_fov = math_floor(dynamicfov_new_fov + 0.5)

        if (dynamicfov_new_fov > closest_distance) then
            bool_in_fov = true
        else
            bool_in_fov = false
        end
    else
        dynamicfov_new_fov = min_fov
        bool_in_fov = false
    end

    if dynamicfov_new_fov ~= old_fov then
        ui.set(ragebot_maximum_fov, dynamicfov_new_fov)
    end

end
--drawing
function on_paintrifle(ctx)
    dynamicfov_logicrifle()
end
client.set_event_callback('paint', on_paintrifle)

--scoped weapons

function dynamicfov_logicscope()
    local local_player = entity_get_local_player()

    if not local_player or not entity.is_alive(local_player) then
        return
    end
    if ui.get(dynamicfov_enable, true) then
    else
        return
    end
    if ui.get(dynamicfov_select) == "Adaptive weapon dynamic FOV" then
    else
        return
    end
    if ui.get(adaptiveselect) == "Awp" then
    elseif ui.get(adaptiveselect) == "Auto" then
    elseif ui.get(adaptiveselect) == "Scout" then
    else
        return
    end
    local old_fov = ui.get(ragebot_maximum_fov)
    dynamicfov_new_fov = old_fov
    local enemy_players = entity_get_players(true)

    local min_fov = ui.get(dynamicfov_minscope)
    local max_fov = ui.get(dynamicfov_maxscope)

    if min_fov > max_fov then
        local store_min_fov = min_fov
        min_fov = max_fov
        max_fov = store_min_fov
    end

    if #enemy_players ~= 0 then
        local own_x, own_y, own_z = client_eye_position()
        local own_pitch, own_yaw = client_camera_angles()
        closest_enemy = nil
        local closest_distance = 999999999

        for i = 1, #enemy_players do
            local enemy = enemy_players[i]
            local enemy_x, enemy_y, enemy_z = entity_hitbox_position(enemy, 0)

            local x = enemy_x - own_x
            local y = enemy_y - own_y
            local z = enemy_z - own_z

            local yaw = ((math_atan2(y, x) * 180 / math_pi))
            local pitch = -(math_atan2(z, math_sqrt(math_pow(x, 2) + math_pow(y, 2))) * 180 / math_pi)

            local yaw_dif = math_abs(own_yaw % 360 - yaw % 360) % 360
            local pitch_dif = math_abs(own_pitch - pitch) % 360

            if yaw_dif > 180 then
                yaw_dif = 360 - yaw_dif
            end

            local real_dif = math_sqrt(math_pow(yaw_dif, 2) + math_pow(pitch_dif, 2))

            if closest_distance > real_dif then
                closest_distance = real_dif
                closest_enemy = enemy
            end
        end

        if closest_enemy ~= nil then
            local closest_enemy_x, closest_enemy_y, closest_enemy_z = entity_hitbox_position(closest_enemy, 0)
            local real_distance = math_sqrt(math_pow(own_x - closest_enemy_x, 2) + math_pow(own_y - closest_enemy_y, 2) + math_pow(own_z - closest_enemy_z, 2))

            dynamicfov_new_fov = (3800 / real_distance) * (ui.get(dynamicfov_auto_factor) * 0.01)

            if (dynamicfov_new_fov > max_fov) then
                dynamicfov_new_fov = max_fov
            elseif dynamicfov_new_fov < min_fov then
                dynamicfov_new_fov = min_fov
            end
        end

        dynamicfov_new_fov = math_floor(dynamicfov_new_fov + 0.5)

        if (dynamicfov_new_fov > closest_distance) then
            bool_in_fov = true
        else
            bool_in_fov = false
        end
    else
        dynamicfov_new_fov = min_fov
        bool_in_fov = false
    end

    if dynamicfov_new_fov ~= old_fov then
        ui.set(ragebot_maximum_fov, dynamicfov_new_fov)
    end

end
--drawing
function on_paintscope(ctx)
    dynamicfov_logicscope()
end
client.set_event_callback('paint', on_paintscope)

--other

--scoped weapons

function dynamicfov_logicother()
    local local_player = entity_get_local_player()

    if not local_player or not entity.is_alive(local_player) then
        return
    end
    if ui.get(dynamicfov_enable, true) then
    else
        return
    end
    if ui.get(dynamicfov_select) == "Adaptive weapon dynamic FOV" then
    else
        return
    end
    if ui.get(adaptiveselect) == "Global" then
    else
        return
    end
    local old_fov = ui.get(ragebot_maximum_fov)
    dynamicfov_new_fov = old_fov
    local enemy_players = entity_get_players(true)

    local min_fov = ui.get(dynamicfov_minother)
    local max_fov = ui.get(dynamicfov_maxother)

    if min_fov > max_fov then
        local store_min_fov = min_fov
        min_fov = max_fov
        max_fov = store_min_fov
    end

    if #enemy_players ~= 0 then
        local own_x, own_y, own_z = client_eye_position()
        local own_pitch, own_yaw = client_camera_angles()
        closest_enemy = nil
        local closest_distance = 999999999

        for i = 1, #enemy_players do
            local enemy = enemy_players[i]
            local enemy_x, enemy_y, enemy_z = entity_hitbox_position(enemy, 0)

            local x = enemy_x - own_x
            local y = enemy_y - own_y
            local z = enemy_z - own_z

            local yaw = ((math_atan2(y, x) * 180 / math_pi))
            local pitch = -(math_atan2(z, math_sqrt(math_pow(x, 2) + math_pow(y, 2))) * 180 / math_pi)

            local yaw_dif = math_abs(own_yaw % 360 - yaw % 360) % 360
            local pitch_dif = math_abs(own_pitch - pitch) % 360

            if yaw_dif > 180 then
                yaw_dif = 360 - yaw_dif
            end

            local real_dif = math_sqrt(math_pow(yaw_dif, 2) + math_pow(pitch_dif, 2))

            if closest_distance > real_dif then
                closest_distance = real_dif
                closest_enemy = enemy
            end
        end

        if closest_enemy ~= nil then
            local closest_enemy_x, closest_enemy_y, closest_enemy_z = entity_hitbox_position(closest_enemy, 0)
            local real_distance = math_sqrt(math_pow(own_x - closest_enemy_x, 2) + math_pow(own_y - closest_enemy_y, 2) + math_pow(own_z - closest_enemy_z, 2))

            dynamicfov_new_fov = (3800 / real_distance) * (ui.get(dynamicfov_auto_factor) * 0.01)

            if (dynamicfov_new_fov > max_fov) then
                dynamicfov_new_fov = max_fov
            elseif dynamicfov_new_fov < min_fov then
                dynamicfov_new_fov = min_fov
            end
        end

        dynamicfov_new_fov = math_floor(dynamicfov_new_fov + 0.5)

        if (dynamicfov_new_fov > closest_distance) then
            bool_in_fov = true
        else
            bool_in_fov = false
        end
    else
        dynamicfov_new_fov = min_fov
        bool_in_fov = false
    end

    if dynamicfov_new_fov ~= old_fov then
        ui.set(ragebot_maximum_fov, dynamicfov_new_fov)
    end

end
--drawing
function on_paintother(ctx)
    dynamicfov_logicother()
end
client.set_event_callback('paint', on_paintother)

--dynamic legit aa
--local variables for API. Automatically generated by https://github.com/simpleavaster/gslua/blob/master/authors/sapphyrus/generate_api.lua
local client_latency, client_log, client_draw_rectangle, client_draw_circle_outline, client_userid_to_entindex, client_draw_indicator, client_draw_gradient, client_set_event_callback, client_screen_size, client_eye_position = client.latency, client.log, client.draw_rectangle, client.draw_circle_outline, client.userid_to_entindex, client.draw_indicator, client.draw_gradient, client.set_event_callback, client.screen_size, client.eye_position
local client_draw_circle, client_color_log, client_delay_call, client_draw_text, client_visible, client_exec, client_trace_line, client_set_cvar = client.draw_circle, client.color_log, client.delay_call, client.draw_text, client.visible, client.exec, client.trace_line, client.set_cvar
local client_world_to_screen, client_draw_hitboxes, client_get_cvar, client_draw_line, client_camera_angles, client_draw_debug_text, client_random_int, client_random_float = client.world_to_screen, client.draw_hitboxes, client.get_cvar, client.draw_line, client.camera_angles, client.draw_debug_text, client.random_int, client.random_float
local entity_get_local_player, entity_is_enemy, entity_get_player_name, entity_get_steam64, entity_get_bounding_box, entity_get_all, entity_set_prop, entity_get_player_weapon = entity.get_local_player, entity.is_enemy, entity.get_player_name, entity.get_steam64, entity.get_bounding_box, entity.get_all, entity.set_prop, entity.get_player_weapon
local entity_hitbox_position, entity_get_prop, entity_get_players, entity_get_classname = entity.hitbox_position, entity.get_prop, entity.get_players, entity.get_classname
local globals_realtime, globals_absoluteframetime, globals_tickcount, globals_curtime, globals_mapname, globals_tickinterval, globals_framecount, globals_frametime, globals_maxplayers = globals.realtime, globals.absoluteframetime, globals.tickcount, globals.curtime, globals.mapname, globals.tickinterval, globals.framecount, globals.frametime, globals.maxplayers
local math_ceil, math_tan, math_log10, math_randomseed, math_cos, math_sinh, math_random, math_huge, math_pi, math_max, math_atan2, math_ldexp, math_floor, math_sqrt, math_deg, math_atan, math_fmod = math.ceil, math.tan, math.log10, math.randomseed, math.cos, math.sinh, math.random, math.huge, math.pi, math.max, math.atan2, math.ldexp, math.floor, math.sqrt, math.deg, math.atan, math.fmod
local math_acos, math_pow, math_abs, math_min, math_sin, math_frexp, math_log, math_tanh, math_exp, math_modf, math_cosh, math_asin, math_rad = math.acos, math.pow, math.abs, math.min, math.sin, math.frexp, math.log, math.tanh, math.exp, math.modf, math.cosh, math.asin, math.rad
local table_maxn, table_foreach, table_sort, table_remove, table_foreachi, table_move, table_getn, table_concat, table_insert = table.maxn, table.foreach, table.sort, table.remove, table.foreachi, table.move, table.getn, table.concat, table.insert
local string_find, string_format, string_rep, string_gsub, string_len, string_gmatch, string_dump, string_match, string_reverse, string_byte, string_char, string_upper, string_lower, string_sub = string.find, string.format, string.rep, string.gsub, string.len, string.gmatch, string.dump, string.match, string.reverse, string.byte, string.char, string.upper, string.lower, string.sub
local render_text = renderer.text
local GetBoundingBox = entity.get_bounding_box

local world_to_screen = function(x, y, z, func)
    local x, y = renderer.world_to_screen(x, y, z)
    if x ~= nil and y ~= nil then
        func(x, y)
    end
end
--end of local variables
local leftdamage = 0
local rightdamage = 0
local rad2deg = function(rad)
    return (rad * 180 / math.pi)
end
local deg2rad = function(deg)
    return (deg * math.pi / 180)
end
local trace_line = function(entity, start, _end)
    return client.trace_line(entity, start.x, start.y, start.z, _end.x, _end.y, _end.z)
end

local screenx, screeny = client_screen_size()

local vector = function(x, y, z)
    x = x ~= nil and x or 0
    y = y ~= nil and y or 0
    z = z ~= nil and z or 0

    return {
        ["x"] = x,
        ["y"] = y,
        ["z"] = z
    }
end

local vector_add = function(vector1, vector2)
    return {
        ["x"] = vector1.x + vector2.x,
        ["y"] = vector1.y + vector2.y,
        ["z"] = vector1.z + vector2.z
    }
end

local vector_substract = function(vector1, vector2)
    return {
        ["x"] = vector1.x - vector2.x,
        ["y"] = vector1.y - vector2.y,
        ["z"] = vector1.z - vector2.z
    }
end
function slot136(slot0, slot1)
    for slot5 = 1, #slot0, 1 do
        if slot0[slot5] == slot1 then
            return true
        end
    end

    return false
end

function slot137(slot0, slot1)
    for slot5, slot6 in ipairs(slot0) do
        if slot6 == slot1 then
            return true, slot5
        end
    end

    return false
end

function slot138()
    if ui.get(otherref.tp_alive) and ui.get(otherref.tp_alive_key) then
        ui.set_visible(otherref.tp_dead, true)
    else
        ui.set_visible(otherref.tp_dead, false)
    end
end
local clamp_angles = function(angle)
    angle = angle % 360
    angle = (angle + 360) % 360

    if angle > 180 then
        angle = angle - 360
    end

    return angle
end

function LAASetup()
    if ui.get(legitAA) then
        if ui.get(legitAAbase) == "Manual" then
            ui.set_visible(LegitAAHotkey, true)
        elseif ui.get(legitAAbase) == "Dynamic" then
            ui.set_visible(LegitAAHotkey, false)
        end
    else
        ui.set_visible(LegitAAHotkey, false)
    end
end

function LAAFunc()
    ----------------------------------------------------------------------LEGITAA
    local legita = ui.get(legitAA)
    local base = ui.get(legitAAbase)
    local aamodes = ui.get(LegitAABreaker)
    local aamoving = ui.get(enableaawm)
    local movingbox = ui.get(legitaamoving)

    ui.set_visible(legitAAbase, legita)
    ui.set_visible(LegitAABreaker, legita)

    ui.set_visible(brutemode2, legita and aamodes == "Break bruteforce")
    ui.set_visible(ui_indicator_combobox4, legita)
    ui.set_visible(ui_indicator_color_picker4, legita)
    ui.set_visible(LegitAAHotkey, legita and base == "Manual")
    ----------------------------------------------------------------------LEGITAA WHILE MOVING
    ui.set_visible(enableaawm, legita)
    ui.set_visible(legitaamoving, legita and aamoving)

    ui.set_visible(slowmode, aamoving and legita and movingbox == "Slow walk")
    ui.set_visible(movemode, aamoving and legita and movingbox == "Moving")
    ui.set_visible(standmode, aamoving and legita and movingbox == "Standing")

    if not ui.get(legitAA) then
        LAASetup()
        ui.set(yaw, "Off")
        ui.set(body, "Off")
        ui.set(autodirection, "-")
        ui.set(autodirection_key, "On hotkey")
        ui.set(aaenablers, false)
    elseif ui.get(legitAA) then
        LAASetup()
        ui.set(yaw, "180")
        ui.set(yaw_num, 180)
        ui.set(body, "Static")
        ui.set(autodirection, "-")
        ui.set(autodirection_key, "On hotkey")
        ui.set(aaenablers, true)
    end
end

LAAFunc()
ui.set_callback(legitAA, LAAFunc)
ui.set_callback(legitAAbase, LAAFunc)
ui.set_callback(LegitAAHotkey, LAAFunc)
ui.set_callback(LegitAABreaker, LAAFunc)
ui.set_callback(enableaawm, LAAFunc)
ui.set_callback(legitaamoving, LAAFunc)

local get_atan = function(ent, eye_pos, camera)
    local data = { id = nil, dst = 2147483647, fov = 360 }
    local screenx, screeny = client_screen_size()
    local crosshair = screenx / 2, screeny / 2
    for i = 0, 19 do
        local hitbox = vector(entity.hitbox_position(ent, i))
        local ext = vector_substract(hitbox, eye_pos)

        local yaw = rad2deg(math.atan2(ext.y, ext.x))
        local pitch = -rad2deg(math.atan2(ext.z, math.sqrt(ext.x ^ 2 + ext.y ^ 2)))

        local yaw_dif = math.abs(camera.y % 360 - yaw % 360) % 360
        local pitch_dif = math.abs(camera.x - pitch) % 360

        if yaw_dif > 180 then
            yaw_dif = 360 - yaw_dif
        end

        local dst = math.sqrt(yaw_dif ^ 2 + pitch_dif ^ 2)
        local dstcorrect = math.sqrt(ext.x ^ 2 + ext.y ^ 2 + ext.z ^ 2)
        if dstcorrect < data.dst then
            data.dst = dstcorrect
            data.id = i
            data.fov = yaw - crosshair
        end
    end

    return data.id, data.dst, data.fov
end

local function getdistance()
    local get_players = entity.get_players(true)

    if #get_players == 0 then
        return
    end
    local eye_pos = vector(client.eye_position())
    local camera = vector(client.camera_angles())
    camera.z = z_pos ~= nil and 64 or camera.z
    local distance = math.huge
    local closest_enemy = nil
    local adv_fov = 1000
    local screenx, screeny = client_screen_size()
    local crosshair = screenx / 2, screeny / 2
    for i = 1, #get_players do
        local hitbox_id, dist, fov = get_atan(get_players[i], eye_pos, camera)
        if distance > dist then
            distance = dist
            hitbox = hitbox_id
            closest_enemy = get_players[i]
            adv_fov = fov
        end
    end

    return closest_enemy, hitbox, distance, adv_fov
end

function slot158()
    if ui.get(yaw) == "Off" then
        return
    end

    if entity_get_prop(entity.get_game_rules(), "m_bFreezePeriod") == 1 then
        return
    end

    local screenx, screeny = client_screen_size()
    local lx, ly, lz = entity_get_prop(entity_get_local_player(), "m_angEyeAngles")
    local divisor = screenx / 2
    local divisor2 = screeny / 2
    local size = 15 * cvar.cl_crosshairsize:get_float() * 0.67

    if ui.get(yaw_num) ~= 180 and ui.get(yaw_num) ~= -180 then
        render_text(divisor, divisor2, 255, 0, 0, 255, "c-", 0, "AA IS BROKEN, SET YAW SLIDER TO 180 OR -180")
        render_text(divisor, divisor2 + 10, 255, 0, 0, 255, "c-", 0, "CURRENT YAW: ", ly)
    end
end

function slot159()
    ui.set(pitch, "Off")
    ui.set(yaw_base, "Local view")
    ui.set(yaw, "180")
    ui.set(yaw_jitter, "Off")
    ui.set(edgeyaw, false)
    ui.set(bodyyaw_freestand, false)
    ui.set(autodirection_key, "On hotkey")
end

function slot160()
    if not ui.get(legitAA) or ui.get(ref_fakeduck) or ui.get(legitAAbase) == "Dynamic" or entity_get_local_player() == nil or entity_get_prop(entity_get_local_player(), "m_lifeState") ~= 0 then
        return
    end

    if entity_get_prop(entity.get_game_rules(), "m_bFreezePeriod") == 1 then
        return
    end

    local screenx, screeny = client_screen_size()
    local halfx = screenx / 2
    local halfy = screeny / 2

    if ui.get(legitAA) then
        if ui.get(legitAAbase) == "Manual" then
            ui.set_visible(LegitAAHotkey, true)
            ui.set(LegitAAHotkey, "Toggle")

            if ui.get(LegitAAHotkey) then
                slot159()
                ui.set(yaw_num, 180)
                ui.set(body_num, 90)

                slot94 = "RIGHT"
            else
                slot159()
                ui.set(yaw_num, 180)
                ui.set(body_num, -90)

                slot94 = "LEFT"
            end
        else
            ui.set_visible(LegitAAHotkey, false)
        end
    end
end
local edge_count = { [1] = 7, [2] = 12, [3] = 15, [4] = 19, [5] = 23, [6] = 28, [7] = 35, [8] = 39 }

local function do_legit_aa()
    local local_player = entity_get_local_player()

    if not local_player or not entity.is_alive(local_player) then
        return
    end

    local m_vecOrigin = vector(entity_get_prop(local_player, "m_vecOrigin"))
    local m_vecViewOffset = vector(entity_get_prop(local_player, "m_vecViewOffset"))

    local m_vecOrigin = vector_add(m_vecOrigin, m_vecViewOffset)

    local radius = 20 + 110 + 0.1
    local step = math.pi * 2.0 / edge_count[8]

    local camera = vector(client.camera_angles())
    local central = deg2rad(math.floor(camera.y + 0.5))

    local data = {
        fraction = 1,
        surpassed = false,
        angle = vector(0, 0, 0),
        var = 0,
        side = "LAST KNOWN"
    }

    for a = central, math.pi * 3.0, step do
        if a == central then
            central = clamp_angles(rad2deg(a))
            local trace_line = function(entity, start, _end)
                return client.trace_line(entity, start.x, start.y, start.z, _end.x, _end.y, _end.z)
            end
        end

        local clm = clamp_angles(central - rad2deg(a))
        local abs = math.abs(clm)

        if abs < 90 and abs > 1 then

            local side = "LAST KNOWN"
            local location = vector(
                    radius * math.cos(a) + m_vecOrigin.x,
                    radius * math.sin(a) + m_vecOrigin.y,
                    m_vecOrigin.z
            )

            local _fr, entindex = client.trace_line(local_player, m_vecOrigin.x, m_vecOrigin.y, m_vecOrigin.z, location.x, location.y, location.z)

            if math.floor(clm + 0.5) < -21 then
                side = "LEFT"
            end
            if math.floor(clm + 0.5) > 21 then
                side = "RIGHT"
            end

            local fr_info = {
                fraction = _fr,
                surpassed = (_fr < 1),
                angle = vector(0, clamp_angles(rad2deg(a)), 0),
                var = math.floor(clm + 0.5),
                side = side --[ 0 - center / 1 - left / 2 - right ]
            }

            if data.fraction > _fr then
                data = fr_info
            end
        end
    end

    return data
end

function dodynamic()
    local local_player = entity_get_local_player()

    if not local_player or not entity.is_alive(local_player) then
        return
    end

    local local_player = entity_get_local_player()
    local topX, topY, botX, botY, alpha = entity.get_bounding_box(client_draw_text, local_player)
    local origin = vector(entity_get_prop(local_player, "m_vecOrigin"))
    local collision = (entity_get_prop(local_player, "m_Collision"))
    local vecmin = vector(entity_get_prop(local_player, "m_vecMins"))
    local vecmax = vector(entity_get_prop(local_player, "m_vecMaxs"))
    local min = vector_add(vecmin, origin)
    local max = vector_add(vecmax, origin)

    if not ui.get(legitAA) or ui.get(ref_fakeduck) or ui.get(legitAAbase) == "Manual" then
        return
    end

    if ui.get(legitAA) and ui.get(legitAAbase) == "Dynamic" then

        if entity_get_prop(entity.get_game_rules(), "m_bFreezePeriod") == 1 then
            return
        end
        local data = do_legit_aa()

        if data == nil then
            return
        end
        if data.fraction < 1 then
            slot159()
            ui.set(body_num, data.var > 0 and 180 or -180)
            ui.set(yaw_num, -180)
        end
    end


end

local function fyls()
    if ui.get(legitAA) == false then
        return
    else
        if ui.get(LegitAABreaker) == "Smart" then
            ui.set(limit, 60)
            ui.set(body, "Static")
        elseif ui.get(LegitAABreaker) == "Maximum" then
            ui.set(limit, 60)
            ui.set(body, "Static")
        elseif ui.get(LegitAABreaker) == "Slow" then
            ui.set(limit, 60)
            ui.set(body, "Static")
        elseif ui.get(LegitAABreaker) == "Fast" then
            ui.set(limit, 60)
            ui.set(body, "Static")
        elseif ui.get(LegitAABreaker) == "Break bruteforce" then
            ui.set(body, "Static")
        end
    end
end

client.set_event_callback("paint", fyls)

function slot163()
    if ui.get(legitAA) then
        if ui.get(LegitAABreaker) == "Maximum" then
        elseif ui.get(LegitAABreaker) == "Smart" then
        end
    else
    end
end

client.set_event_callback("run_command", function()
    slot158()
    slot160()
end)

client.set_event_callback("paint", function(c)
    slot163()
    dodynamic()
end)

client.set_event_callback("game_newmap", function()
end)

--aa indicator
function on_paint(c)
    local scrsize_x, scrsize_y = client.screen_size()
    local center_x, center_y = scrsize_x / 2, scrsize_y / 2

    local indicator = ui.get(ui_indicator_combobox4)
    local indicator_r, indicator_g, indicator_b, indicator_a = ui.get(ui_indicator_color_picker4)

    if ui.get(body_num) == 90 and indicator == "Metro" and ui.get(legitAA) == true or ui.get(body_num) == 180 and indicator == "Metro" and ui.get(legitAA) == true then
        client.draw_text(c, center_x + 45, center_y, indicator_r, indicator_g, indicator_b, indicator_a, "c+", 0, "⮞")
    elseif ui.get(body_num) == -90 and indicator == "Metro" and ui.get(legitAA) == true or ui.get(body_num) == -180 and indicator == "Metro" and ui.get(legitAA) == true then
        client.draw_text(c, center_x - 45, center_y, indicator_r, indicator_g, indicator_b, indicator_a, "c+", 0, "⮜")
    end
    if ui.get(body_num) == 90 and indicator == "Point arrows" and ui.get(legitAA) == true or ui.get(body_num) == 180 and indicator == "Point arrows" and ui.get(legitAA) == true then
        client.draw_text(c, center_x + 45, center_y, indicator_r, indicator_g, indicator_b, indicator_a, "c+", 0, "→")
    elseif ui.get(body_num) == -90 and indicator == "Point arrows" and ui.get(legitAA) == true or ui.get(body_num) == -180 and indicator == "Point arrows" and ui.get(legitAA) == true then
        client.draw_text(c, center_x - 45, center_y, indicator_r, indicator_g, indicator_b, indicator_a, "c+", 0, "←")
    end
    if ui.get(body_num) == 90 and indicator == "Dashes" and ui.get(legitAA) == true or ui.get(body_num) == 180 and indicator == "Dashes" and ui.get(legitAA) == true then
        client.draw_text(c, center_x + 45, center_y, indicator_r, indicator_g, indicator_b, indicator_a, "c-", 0, "‒")
    elseif ui.get(body_num) == -90 and indicator == "Dashes" and ui.get(legitAA) == true or ui.get(body_num) == -180 and indicator == "Dashes" and ui.get(legitAA) == true then
        client.draw_text(c, center_x - 45, center_y, indicator_r, indicator_g, indicator_b, indicator_a, "c-", 0, "‒")
    end
end
err = client.set_event_callback('paint', on_paint)
--trigger magnet

--thx saph for callback shit
function on_paint(ctx)
    if ui.get(tm_cb) then
        local width, height = client.screen_size()
        if ui.get(triggermagnet) then
            ui.set(rageautofire, true)
            ui.set(ragebotmode, "Always on")
        else
            ui.set(rageautofire, false)
            ui.set(ragebotmode, "On hotkey")
        end
    end
end

client.set_event_callback("paint", on_paint)

reduce = false

function reduction(c)
    if ui.get(tm_cb, true) and ui.get(typeselect) == "Advanced" then
    else
        return
    end
    local h_key = ui.get(triggermagnet)
    local hc_slider_ref = ui.get(triggerhtc)
    local dmg_slider_ref = ui.get(triggerdmg)

    if h_key and reduce == false then
        stored_hc = ui.get(hitchance)
        stored_dmg = ui.get(min_dmg)
        ui.set(hitchance, hc_slider_ref)
        ui.set(min_dmg, dmg_slider_ref)
        reduce = true
    elseif not h_key and reduce == true then
        ui.set(hitchance, stored_hc)
        ui.set(min_dmg, stored_dmg)
        reduce = false
    end

end

client.set_event_callback("paint", reduction)

-- autowall
function on_paint(ctx)
    if not ui.get(autowallbutton, true) then
        autowallvar1 = false
    end
    if ui.get(autowallbutton, true) then
    else
        return
    end

    if ui.get(autowalltoggle) then

        autowallvar1 = true

    else

        autowallvar1 = false

    end
end

client.set_event_callback("paint", on_paint)
--autowall transperency
range = false
-- Trans range function
function changed1(c)
    local state = table_contains(ui.get(auto_autowall), "Transparent props")
    local dmg_slider_ref1 = ui.get(slider_trans)
    local autowaller1 = ui.get(autowalltoggle)
    if state and ui.get(autowallbutton, true) then
    else
        return
    end

    if autowaller1 and range == false then
        stored_dmg2 = ui.get(trans)
        ui.set(trans, dmg_slider_ref1)
        range = true
    elseif not autowaller1 and range == true then
        ui.set(trans, stored_dmg2)
        range = false
    end

end
client.set_event_callback("paint", changed1)

--min dmg override

reducer = false

function reduction(c)
    if ui.get(autowallbutton) == true then
    else
        return
    end

    local state = table_contains(ui.get(auto_autowall), "Min dmg override")
    if state and ui.get(autowallbutton) == true then
    else
        return
    end

    local h_key = ui.get(autowalltoggle)
    local dmg_slider_ref = ui.get(autowalldmg)

    if h_key and reducer == false then
        stored_hc = ui.get(hitchance)
        stored_dmg = ui.get(min_dmg)
        ui.set(min_dmg, dmg_slider_ref)
        reducer = true
    elseif not h_key and reducer == true then
        ui.set(min_dmg, stored_dmg)
        reducer = false
    end

end

client.set_event_callback("paint", reduction)

--penetration reticle
function on_paint2(ctx)
    local state = table_contains(ui.get(auto_autowall), "Penetration reticle")
    if state and ui.get(autowallbutton, true) then
    else
        return
    end

    if ui.get(autowalltoggle) then
        ui.set(preticle, true)
    else
        ui.set(preticle, false)
    end
end

client.set_event_callback("paint", on_paint2)
--autowall if shot me

function enablewhileshotme()
    autowallvar2 = true
end

function disablewhileshotme()
    autowallvar2 = false
end

function on_fire(e)
    local userID = e.userid
    local userEntIndex = client.userid_to_entindex(userID)

    if userEntIndex == entity.get_local_player() then
        local state = table_contains(ui.get(auto_autowall), "Autowall if shot me")
        if not state then
            autowallvar2 = false
            return
        end
        if ui.get(autowallbutton, true) then
        else
            return
        end

        client.delay_call(globals.tickinterval() * ui.get(beforedelay), enablewhileshotme)
        client.delay_call(globals.tickinterval() * ui.get(autodely), disablewhileshotme)
    end
end

client.set_event_callback("player_hurt", on_fire)

function dynamicfov_logicaw()
    local state = table_contains(ui.get(auto_autowall), "Dynamic autowall FOV")
    if not state then
        return
    end
    if ui.get(autowalltoggle) and ui.get(autowallbutton, true) then
    else
        return
    end

    local old_fov = ui.get(ragebot_maximum_fov)
    dynamicfov_new_fov = old_fov
    local enemy_players = entity_get_players(true)

    local min_fov = ui.get(dynamicfov_minaw)
    local max_fov = ui.get(dynamicfov_maxaw)

    if min_fov > max_fov then
        local store_min_fov = min_fov
        min_fov = max_fov
        max_fov = store_min_fov
    end

    if #enemy_players ~= 0 then
        local own_x, own_y, own_z = client_eye_position()
        local own_pitch, own_yaw = client_camera_angles()
        closest_enemy = nil
        local closest_distance = 999999999

        for i = 1, #enemy_players do
            local enemy = enemy_players[i]
            local enemy_x, enemy_y, enemy_z = entity_hitbox_position(enemy, 0)

            local x = enemy_x - own_x
            local y = enemy_y - own_y
            local z = enemy_z - own_z

            local yaw = ((math_atan2(y, x) * 180 / math_pi))
            local pitch = -(math_atan2(z, math_sqrt(math_pow(x, 2) + math_pow(y, 2))) * 180 / math_pi)

            local yaw_dif = math_abs(own_yaw % 360 - yaw % 360) % 360
            local pitch_dif = math_abs(own_pitch - pitch) % 360

            if yaw_dif > 180 then
                yaw_dif = 360 - yaw_dif
            end

            local real_dif = math_sqrt(math_pow(yaw_dif, 2) + math_pow(pitch_dif, 2))

            if closest_distance > real_dif then
                closest_distance = real_dif
                closest_enemy = enemy
            end
        end

        if closest_enemy ~= nil then
            local closest_enemy_x, closest_enemy_y, closest_enemy_z = entity_hitbox_position(closest_enemy, 0)
            local real_distance = math_sqrt(math_pow(own_x - closest_enemy_x, 2) + math_pow(own_y - closest_enemy_y, 2) + math_pow(own_z - closest_enemy_z, 2))

            dynamicfov_new_fov = max_fov - ((max_fov - min_fov) * (real_distance - 250) / 1000)
        end

        if (dynamicfov_new_fov > max_fov) then
            dynamicfov_new_fov = max_fov
        elseif dynamicfov_new_fov < min_fov then
            dynamicfov_new_fov = min_fov
        end

        dynamicfov_new_fov = math_floor(dynamicfov_new_fov + 0.5)

        if (dynamicfov_new_fov > closest_distance) then
            bool_in_fov = true
        else
            bool_in_fov = false
        end
    else
        dynamicfov_new_fov = min_fov
        bool_in_fov = false
    end

    if dynamicfov_new_fov ~= old_fov then
        ui.set(ragebot_maximum_fov, dynamicfov_new_fov)
    end

end

function on_paint(ctx)
    dynamicfov_logicaw()
end

client.set_event_callback('paint', on_paint)

--legitbot weapons

function legitbotimp(disab)
    if ui.get(legitbotimprovements, true) and not ui.get(triggermagnet) then
    else
        return
    end
    local_entindex = entity.get_local_player()
    local local_weapon = entity.get_player_weapon(local_entindex)
    local weapon_name = entity.get_classname(local_weapon)
    if weapon_name == "CWeaponAWP" or weapon_name == "CDEagle" or weapon_name == "CWeaponElite" or weapon_name == "CWeaponSSG08" or weapon_name == "CWeaponGlock" or weapon_name == "CWeaponHKP2000" or weapon_name == "CWeaponCZ75" or weapon_name == "CWeaponUSP" or weapon_name == "CWeaponP250" then
        ui.set(ragebot, true)
        return
    end
    if disab.in_attack == 1 then
        ui.set(ragebot, false)
    else
        ui.set(ragebot, true)
    end
end
client.set_event_callback("setup_command", legitbotimp)

--indicators

legit_active, legit_key = ui.reference("Legit", "Aimbot", "Enabled")
rage_active, active_key = ui.reference("RAGE", "Aimbot", "Enabled")

indicator = renderer.indicator
text = renderer.text
w, h = client.screen_size()
draw = {
    box = renderer.rectangle,
    line = renderer.line,
    text = renderer.text,
    measure_text = renderer.measure_text,
    gradient = renderer.gradient
}
h2o = 5
mouse_position = ui.mouse_position
wnd = {
    x = database.read("speclist_x") or 250,
    y = database.read("speclist_y") or 25,
    w = database.read("speclist_w") or 150,
    dragging = false,
    resize = false,
    rx = 0,
}
function intersect(x, y, w, h, debug)
    local cx, cy = mouse_position()
    debug = debug or false
    if debug then
        renderer.rectangle(x, y, w, h, 255, 0, 0, 50)
    end
    return cx >= x and cx <= x + w and cy >= y and cy <= y + h
end
client.set_event_callback("paint", function(ctx, entity_index)
    if ui.get(indicate_enable, true) then
    else
        return
    end
    local local_player = entity_get_local_player()

    if not local_player or not entity.is_alive(local_player) then
        return
    end
    local local_weapon = entity.get_player_weapon(local_entindex)
    local weapon_name = entity.get_classname(local_weapon)
    local width, height = client.screen_size()
    local indiselect = ui.get(indicate_on)
    local triggermag = table_contains(ui.get(indicate_select), "Triggermagnet")
    local silentaim = table_contains(ui.get(indicate_select), "Silent aim")
    local autowalli = table_contains(ui.get(indicate_select), "Autowall")
    local fovi = table_contains(ui.get(indicate_select), "FOV")
    local forcebodyaims = table_contains(ui.get(indicate_select), "Force body aim")
    local legitboti = table_contains(ui.get(indicate_select), "Legitbot improvements")
    local bruteforcei = table_contains(ui.get(indicate_select), "Bruteforce")
    local safepointind = table_contains(ui.get(indicate_select), "Safe point")

    local cx, cy = mouse_position()

    local left_click = client.key_state(0x01)

    if not wnd.resize and ui.is_menu_open() then
        if wnd.dragging and not left_click then
            wnd.dragging = false
        end

        if wnd.dragging and left_click then
            wnd.x = cx - wnd.drag_x
            wnd.y = cy - wnd.drag_y
        end

        if intersect(wnd.x, wnd.y, wnd.w, 180) and left_click then
            wnd.dragging = true
            wnd.drag_x = cx - wnd.x
            wnd.drag_y = cy - wnd.y
        end
    end
    if indiselect == "Default" then
        for iiiiiiiii = ui.get(indicateposition), 1, -1
        do
            renderer.indicator(255, 255, 255, 0, iiiiiiiii)
        end
    end
    local r, g, b, a = ui.get(indicate_color)
    if getui(rageautofire) == true and triggermag and indiselect == "Small" then
        text(wnd.x + 8, wnd.y + 10, r, g, b, a, "", 0, "TRIGGERBOT")
    elseif ui.get(rageautofire, true) and triggermag and indiselect == "Big" then
        client_draw_text(c, wnd.x + 8, wnd.y + 10, r, g, b, a, "+", 0, "trigger")
    elseif ui.get(rageautofire, true) and triggermag and indiselect == "Default" then
        renderer.indicator(r, g, b, a, "TM")
    end
    if getui(silent, true) and silentaim and indiselect == "Small" then
        text(wnd.x + 8, wnd.y + 22, r, g, b, a, "", 0, "SILENT AIM")
    elseif ui.get(silent, true) and silentaim and indiselect == "Big" then
        client_draw_text(c, wnd.x + 8, wnd.y + 30, r, g, b, a, "+", 0, "silent")
    elseif ui.get(silent, true) and silentaim and indiselect == "Default" then
        renderer.indicator(r, g, b, a, "SILENT")
    end
    if getui(autowall, true) and autowalli and indiselect == "Small" then
        text(wnd.x + 8, wnd.y + 34, r, g, b, a, "", 0, "AUTOWALL")
    elseif getui(autowall, true) and autowalli and indiselect == "Big" then
        client_draw_text(c, wnd.x + 8, wnd.y + 50, r, g, b, a, "+", 0, "autowall")
    elseif getui(autowall, true) and autowalli and indiselect == "Default" then
        renderer.indicator(r, g, b, a, "AW")
    end
    if getui(force_body_aim, true) and forcebodyaims and indiselect == "Small" then
        text(wnd.x + 8, wnd.y + 46, r, g, b, a, "", 0, "FORCE BODY AIM")
    elseif getui(force_body_aim, true) and forcebodyaims and indiselect == "Big" then
        client_draw_text(c, wnd.x + 8, wnd.y + 70, r, g, b, a, "+", 0, "baim")
    elseif getui(force_body_aim, true) and forcebodyaims and indiselect == "Default" then
        renderer.indicator(r, g, b, a, "BAIM")
    end
    if fovi and indiselect == "Small" then
        text(wnd.x + 8, wnd.y + 58, r, g, b, a, "", 0, "FOV:", getui(ragebot_maximum_fov))
    elseif fovi and indiselect == "Big" then
        client_draw_text(c, wnd.x + 8, wnd.y + 90, r, g, b, a, "+", 0, "fov:", getui(ragebot_maximum_fov))
    elseif fovi and indiselect == "Default" then
        renderer.indicator(r, g, b, a, "FOV:", getui(ragebot_maximum_fov))
    end
    if ui.get(body_slider) == 60 and bruteforcei and indiselect == "Small" and ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" then
    elseif ui.get(body_slider) == 60 and bruteforcei and indiselect == "Big" and ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" then
        client_draw_text(c, wns.x + 8, wns.y + 110, r, g, b, a, "+", 0, "brute:right")
    elseif ui.get(body_slider) == 60 and bruteforcei and indiselect == "Default" and ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" then
        renderer.indicator(r, g, b, a, "B:LEFT")
    end

    if ui.get(body_slider) == -60 and bruteforcei and indiselect == "Small" and ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" then
    elseif ui.get(body_slider) == -60 and bruteforcei and indiselect == "Big" and ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" then
        client_draw_text(c, wns.x + 8, wns.y + 110, r, g, b, a, "+", 0, "brute:left")
    elseif ui.get(body_slider) == -60 and bruteforcei and indiselect == "Default" and ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" then
        renderer.indicator(r, g, b, a, "B:RIGHT")
    end
    if ui.get(forcebody) == false and bruteforcei and indiselect == "Small" and ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" then
        text(wnd.x + 8, wnd.y + 70, r, g, b, a, "", 0, "BRUTE:OFF")
    elseif ui.get(forcebody) == false and bruteforcei and indiselect == "Big" and ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" then
        client_draw_text(c, wnd.x + 8, wnd.y + 110, r, g, b, a, "+", 0, "brute:off")
    elseif ui.get(forcebody) == false and bruteforcei and indiselect == "Default" and ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" then
        renderer.indicator(r, g, b, a, "B:OFF")
    end
    if ui.get(forcesafepoint) and safepointind and indiselect == "Small" then
        text(wnd.x + 8, wnd.y + 94, r, g, b, a, "", 0, "SAFE POINT")
    elseif ui.get(forcesafepoint) and safepointind and indiselect == "Big" then
        client_draw_text(c, wnd.x + 8, wnd.y + 150, r, g, b, a, "+", 0, "safe")
    elseif ui.get(forcesafepoint) and safepointind and indiselect == "Default" then
        renderer.indicator(r, g, b, a, "SAFE")
    end
    if weapon_name == "CWeaponAWP" and legitboti and indiselect == "Small" or weapon_name == "CDEagle" and legitboti and indiselect == "Small" or weapon_name == "CWeaponElite" and legitboti and indiselect == "Small" or weapon_name == "CWeaponSSG08" and legitboti and indiselect == "Small" or weapon_name == "CWeaponGlock" and legitboti and indiselect == "Small" or weapon_name == "CWeaponHKP2000" and legitboti and indiselect == "Small" or weapon_name == "CWeaponCZ75" and legitboti and indiselect == "Small" or weapon_name == "CWeaponUSP" and legitboti and indiselect == "Small" or weapon_name == "CWeaponP250" and legitboti and indiselect == "Small" then
        text(wnd.x + 8, wnd.y + 82, r, g, b, a, "", 0, "RAGEBOT")
    elseif weapon_name == "CWeaponAWP" and legitboti and indiselect == "Big" or weapon_name == "CDEagle" and legitboti and indiselect == "Big" or weapon_name == "CWeaponElite" and legitboti and indiselect == "Big" or weapon_name == "CWeaponSSG08" and legitboti and indiselect == "Big" or weapon_name == "CWeaponGlock" and legitboti and indiselect == "Big" or weapon_name == "CWeaponHKP2000" and legitboti and indiselect == "Big" or weapon_name == "CWeaponCZ75" and legitboti and indiselect == "Big" or weapon_name == "CWeaponUSP" and legitboti and indiselect == "Big" or weapon_name == "CWeaponP250" and legitboti and indiselect == "Big" then
        client_draw_text(c, wnd.x + 8, wnd.y + 130, r, g, b, a, "+", 0, "ragebot")
    elseif weapon_name == "CWeaponAWP" and legitboti and indiselect == "Default" or weapon_name == "CDEagle" and legitboti and indiselect == "Default" or weapon_name == "CWeaponElite" and legitboti and indiselect == "Default" or weapon_name == "CWeaponSSG08" and legitboti and indiselect == "Default" or weapon_name == "CWeaponGlock" and legitboti and indiselect == "Default" or weapon_name == "CWeaponHKP2000" and legitboti and indiselect == "Default" or weapon_name == "CWeaponCZ75" and legitboti and indiselect == "Default" or weapon_name == "CWeaponUSP" and legitboti and indiselect == "Default" or weapon_name == "CWeaponP250" and legitboti and indiselect == "Default" then
        renderer.indicator(r, g, b, a, "RAGE")
    else
        if legitboti and indiselect == "Small" then
            text(wnd.x + 8, wnd.y + 82, r, g, b, a, "", 0, "LEGITBOT")
        elseif legitboti and indiselect == "Big" then
            client_draw_text(c, wnd.x + 8, wnd.y + 130, r, g, b, a, "+", 0, "legitbot")
        elseif legitboti and indiselect == "Default" then
            renderer.indicator(r, g, b, a, "LEGIT")
        end
    end
end)

client.set_event_callback("paint", on_paint)

-- Tempest AA fix by Kessie and Whæliin

local player_is_alive
local spamtime = 0
local antiresolve
local delay_time = 0
local inverse_time = 0
local anti_resolve_timer = 0

function contains(table, val)
    for i = 1, #table do
        if table[i] == val then
            return true
        end
    end

    return false
end

function anti_resolver2()
    if ui.get(legitAA, true) then
    else
        return
    end
    if ui.get(LegitAABreaker) == "Break bruteforce" then
        if ui.get(brutemode2) == "Slow" then
            if globals.realtime() >= anti_resolve_timer then
                client.delay_call(0.1, ui.set, limit, 60)
                client.delay_call(1.1, ui.set, limit, 2)

                anti_resolve_timer = globals.realtime() + 1.1
            end
        end

        if ui.get(brutemode2) == "Fast" then
            if globals.realtime() >= anti_resolve_timer then
                client.delay_call(0.1, ui.set, limit, 60)
                client.delay_call(0.5, ui.set, limit, 2)

                anti_resolve_timer = globals.realtime() + 0.5
            end
        end

        if ui.get(brutemode2) == "Jitter" then
            if globals.realtime() >= anti_resolve_timer then
                client.delay_call(0.08, ui.set, limit, 60)
                client.delay_call(0.06, ui.set, limit, 0)

                anti_resolve_timer = globals.realtime() + 0.2
            end
        end
    end
end
client.set_event_callback("run_command", anti_resolver2)

--hook tag
hooktag_enabled = ui.new_checkbox("MISC", "Miscellaneous", "clan tag")

function time_to_ticks(time)
    return math_floor(time / globals.tickinterval() + .5)
end

clan_tag_prev = ""
enabled_prev = "Off"

function gamesense_anim(text, indices)
    local text_anim = "               " .. text .. "                      "
    local tickinterval = globals.tickinterval()
    local tickcount = globals.tickcount() + time_to_ticks(client_latency())
    local i = tickcount / time_to_ticks(0.3)
    i = math_floor(i % #indices)
    i = indices[i + 1] + 1

    return string_sub(text_anim, i, i + 15)
end

function run_tag_animation()
    if ui.get(hooktag_enabled, true) then
        local clan_tag = gamesense_anim("HELLBANIANZ", { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22 })
        if clan_tag ~= clan_tag_prev then
            local fixed = string.sub(clan_tag, 1, 15)
            local spaces = string.gsub(fixed, "\x20\x20\x20", "\xE2\xA0\x80")
            client.set_clan_tag(spaces)
        end
        clan_tag_prev = clan_tag
    end
end

function on_paint(ctx)
    if ui.get(hooktag_enabled, true) then
        local local_player = entity.get_local_player()
        if local_player ~= nil and (not entity.is_alive(local_player)) and globals.tickcount() % 2 == 0 then
            run_tag_animation()
        end
    end
end
client.set_event_callback("paint", on_paint)

function on_run_command(e)
    if ui.get(hooktag_enabled, true) then
        if e.chokedcommands == 0 then
            run_tag_animation()
        end
    end
end
client.set_event_callback("run_command", on_run_command)

----silent aim on key
function on_paint(ctx)
    local state = table_contains(ui.get(silentmulti), "Silent aim on key")
    if not state and not ui.get(silentbuttonenable, true) then
        silentvar1 = false
        return
    end

    if ui.get(silentkey) then

        silentvar1 = true

    else

        silentvar1 = false

    end
end

client.set_event_callback("paint", on_paint)


--silent aim in distance

event_handler_functions = {
    [true] = client.set_event_callback,
    [false] = client.unset_event_callback,
}

function get_distance(x1, y1, z1, x2, y2, z2)
    return math.sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2 + (z2 - z1) ^ 2)
end

function on_run_command()
    local state = table_contains(ui.get(silentmulti), "Silent aim in distance")
    if not state and not ui.get(silentbuttonenable, true) then
        silentvar3 = false
        return
    end
    local players = entity.get_players(true)
    local lx, ly, lz = entity.get_prop(entity.get_local_player(), "m_vecOrigin")
    for i = 1, #players do
        local x, y, z = entity.get_prop(players[i], "m_vecOrigin")
        local distance = get_distance(lx, ly, lz, x, y, z)
        local weapon = entity.get_player_weapon(players[i])
        if distance <= ui.get(silentdistance) then
            silentvar3 = true
            return
        else
            silentvar3 = false
        end
    end
end

client.set_event_callback("run_command", on_run_command)

outline = true
function rotate_point(x, y, x_center, y_center, rotation)
    if rotation == 0 then
        return x, y
    end

    local rotation = math_rad(rotation)
    local sin, cos = math_sin(rotation), math_cos(rotation)

    local x_new = cos * (x - x_center) - sin * (y - y_center) + x_center
    local y_new = sin * (x - x_center) + cos * (y - y_center) + y_center

    return x_new, y_new
end
function draw_circle_3d(ctx, x, y, z, radius, r, g, b, a, accuracy, width, outline, start_degrees, percentage)
    local accuracy = accuracy or 3
    local width = width or 1
    local outline = outline or false
    local start_degrees = start_degrees ~= nil and start_degrees or 0
    local percentage = percentage ~= nil and percentage or 1

    local screen_x_line_old, screen_y_line_old
    for rot = start_degrees, start_degrees + percentage * 360, accuracy do
        local rot_temp = math_rad(rot)
        local lineX, lineY, lineZ = radius * math_cos(rot_temp) + x, radius * math_sin(rot_temp) + y, z
        local screen_x_line, screen_y_line = client_world_to_screen(ctx, lineX, lineY, lineZ)
        if rot == start_degrees then
            screen_x_line_old, screen_y_line_old = screen_x_line, screen_y_line
        end
        if screen_x_line ~= nil and screen_x_line_old ~= nil then
            for i = 1, width do
                local i = i - 1
                client_draw_line(ctx, screen_x_line, screen_y_line - i, screen_x_line_old, screen_y_line_old - i, r, g, b, a)
            end
            if outline then
                local outline_a = a / 255 * 160
                client_draw_line(ctx, screen_x_line, screen_y_line - width, screen_x_line_old, screen_y_line_old - width, 16, 16, 16, outline_a)
                client_draw_line(ctx, screen_x_line, screen_y_line + 1, screen_x_line_old, screen_y_line_old + 1, 16, 16, 16, outline_a)
            end
        end
        screen_x_line_old, screen_y_line_old = screen_x_line, screen_y_line
    end
end
function on_paint(ctx)
    local state = table_contains(ui.get(silentmulti), "Silent aim in distance")
    if state and ui.get(silentbuttonenable, true) and ui.get(distancecircle, true) then
    else
        return
    end

    local local_player = entity_get_local_player()
    if local_player == nil or not entity_is_alive(local_player) then
        return
    end

    local location_x, location_y, location_z = entity_get_prop(local_player, "m_vecAbsOrigin")
    location_z = location_z + 1

    local _, base_yaw = client_camera_angles()

    local screen_width, screen_height = client_screen_size()
    local screen_center_x, screen_center_y = screen_width / 2, screen_height / 2

    if location_x ~= nil then
        local world_x, world_y = client_world_to_screen(ctx, location_x, location_y, location_z)

        draw_circle_3d(ctx, location_x, location_y, location_z, ui.get(silentdistance), 17, 17, 17, 200, 2.5, 2)

    end
end

client.set_event_callback("paint", on_paint)

--silent aim while slow walking

function slowwalksilent(ctx)
    local state = table_contains(ui.get(silentmulti), "Silent aim while slow walking")
    if not state then
        silentvar4 = false
        return
    end

    if ui.get(hotkey_reference) then

        silentvar4 = true

    else

        silentvar4 = false

    end
end

client.set_event_callback("paint", slowwalksilent)


--slowwalk

slowwalkcheck = ui.new_checkbox("AA", "Other", "Slow motion limit")
limit_reference = ui.new_slider("AA", "Other", "Slow motion limit", 10, 57, 50, 57, "", 1, { [57] = "Max" })
function modify_velocity(cmd, goalspeed)
    if ui.get(slowwalkcheck, true) then
    else
        return
    end
    if goalspeed <= 0 then
        return
    end

    local minimalspeed = math.sqrt((cmd.forwardmove * cmd.forwardmove) + (cmd.sidemove * cmd.sidemove))

    if minimalspeed <= 0 then
        return
    end

    if cmd.in_duck == 1 then
        goalspeed = goalspeed * 2.94117647 -- wooo cool magic number
    end

    if minimalspeed <= goalspeed then
        return
    end

    local speedfactor = goalspeed / minimalspeed
    cmd.forwardmove = cmd.forwardmove * speedfactor
    cmd.sidemove = cmd.sidemove * speedfactor
end

function on_setup_cmd(cmd)
    if ui.get(slowwalkcheck, true) then
    else
        return
    end
    local checkbox = ui.get(checkbox_reference)
    local hotkey = ui.get(hotkey_reference)
    local limit = ui.get(limit_reference)

    if limit >= 57 then
        return
    end

    if checkbox and hotkey then
        modify_velocity(cmd, limit)
    end
end

client.set_event_callback('setup_command', on_setup_cmd)

--experimental dynamic legit aa

local flips
local desync_types

function contains(table, val)
    --pasted cuz i didnt know that multiselect cant work properly without custom checks
    
    if type(table) ~= "table" then
        return 1
        end

    for i = 1, #table do
        if table[i] == val then
            return true
        end
    end

    return false
end


    if entity_get_local_player() == nil or entity_get_prop(entity_get_local_player(), "m_iHealth") <= 0 then
        return
    end

    local vel_x, vel_y = entity_get_prop(entity_get_local_player(), "m_vecVelocity")
    local vel = math_sqrt(vel_x ^ 2 + vel_y ^ 2)

    desync_types = ui.get(LegitAABreaker) == "Smart" and 1 or 0

    local sFlips = globals_tickcount() % 100 > 1 and globals_tickcount() % 100 < 50 and true or false



    if entity_get_local_player() == nil or entity_get_prop(entity_get_local_player(), "m_iHealth") <= 0 then
        return
    end

    local show_desync = desync_types == 0



--aw selected player

selectedplayer = ui.reference("players", "players", "player list")
player_list = ui.reference("PLAYERS", "Players", "Player list")
edgeawplayer = { }

ui.set_callback(player_list, function()
    ui.set(edgeautowallbutton, edgeawplayer[ui.get(player_list)] or false)
end)

ui.set_callback(edgeautowallbutton, function()
    local plist = ui.get(player_list)
    if plist then
        edgeawplayer[plist] = ui.get(edgeautowallbutton)
    end
end)

client.set_event_callback("player_connect_full", function(c)
    if client.userid_to_entindex(c) == entity.get_local_player() then
        edgeawplayer = { }
    end
end)

local client_camera_angles, client_trace_line, entity_get_local_player, entity_get_players, entity_get_prop, entity_hitbox_position, math_acos, math_cos, math_sin, math_sqrt = client.camera_angles, client.trace_line, entity.get_local_player, entity.get_players, entity.get_prop, entity.hitbox_position, math.acos, math.cos, math.sin, math.sqrt

maximum_fov_ref = ui_reference("RAGE", "Aimbot", "Maximum FOV")

PI = 3.14159265358979323846
DEG_TO_RAD = PI / 180.0
RAD_TO_DEG = 180.0 / PI

--------------------------------------------------------------------------------
-- Utility functions
--------------------------------------------------------------------------------
function vec3_normalize(x, y, z)
    local len = math_sqrt(x * x + y * y + z * z)
    if len == 0 then
        return 0, 0, 0
    end
    local r = 1 / len
    return x * r, y * r, z * r
end

function vec3_dot(ax, ay, az, bx, by, bz)
    return ax * bx + ay * by + az * bz
end

function angle_to_vec(pitch, yaw)
    local pitch_rad, yaw_rad = DEG_TO_RAD * pitch, DEG_TO_RAD * yaw
    local sp, cp, sy, cy = math_sin(pitch_rad), math_cos(pitch_rad), math_sin(yaw_rad), math_cos(yaw_rad)
    return cp * cy, cp * sy, -sp
end

function calculate_fov_to_player(ent, lx, ly, lz, fx, fy, fz)
    local px, py, pz = entity_get_prop(ent, "m_vecOrigin")
    local dx, dy, dz = vec3_normalize(px - lx, py - ly, lz - lz)
    local dot_product = vec3_dot(dx, dy, dz, fx, fy, fz)
    local cos_inverse = math_acos(dot_product)
    return RAD_TO_DEG * cos_inverse
end

function get_closest_player_to_crosshair(lx, ly, lz, pitch, yaw)
    -- Calculate our forward vector once instead of doing it for each player
    local fx, fy, fz = angle_to_vec(pitch, yaw)
    local enemy_players = entity_get_players(true)

    local nearest_player = nil
    local nearest_player_fov = math.huge

    for i = 1, #enemy_players do
        local enemy_ent = enemy_players[i]

        -- Calculate the FOV to the player so we can determine if they are closer than the stored player
        local fov_to_player = calculate_fov_to_player(enemy_ent, lx, ly, lz, fx, fy, fz)

        if fov_to_player <= nearest_player_fov then
            nearest_player = enemy_ent
            nearest_player_fov = fov_to_player
        end
    end

    return nearest_player, nearest_player_fov
end

function is_player_visible(local_player, lx, ly, lz, ent)
    local visible_hitboxes = 0
    local visible_hitbox_threshold = ui.get(legit_pen_threshold_ref)

    for i = 0, 18 do
        -- Get the current hitbox position so that we can run a trace to it and see if it is hit
        local ex, ey, ez = entity_hitbox_position(ent, i)
        -- Run the trace from our eye position to the hitbox if the trace hits the enemy then we know the player is visible
        local _, entindex = client_trace_line(local_player, lx, ly, lz, ex, ey, ez)

        if entindex == ent then
            -- Increment the visible hitbox counter so that we can determine if the player meets the threshold
            visible_hitboxes = visible_hitboxes + 1
        end
    end

    return visible_hitboxes >= visible_hitbox_threshold
end

--------------------------------------------------------------------------------
-- Callback functions
--------------------------------------------------------------------------------
function on_run_command()
    local state = table_contains(ui.get(auto_autowall), "Edge autowall")

    local maximum_fov = ui.get(maximum_fov_ref)
    local local_player = entity_get_local_player()

    local pitch, yaw = client_camera_angles()
    local lx, ly, lz = entity_get_prop(local_player, "m_vecOrigin")

    local nearest_player, nearest_player_fov = get_closest_player_to_crosshair(lx, ly, lz, pitch, yaw)

    local view_offset = entity_get_prop(local_player, "m_vecViewOffset[2]")
    local lz = lz + view_offset

    if nearest_player ~= nil and nearest_player_fov <= maximum_fov and ui.get(autowallbutton, true) and state and ui.get(edgeautowalltype) == "All players" or nearest_player ~= nil and nearest_player_fov <= maximum_fov and ui.get(autowallbutton, true) and state and ui.get(edgeautowalltype) == "Selected players" and ui.get(edgeautowallbutton, true) then
        autowallvar3 = is_player_visible(local_player, lx, ly, lz, nearest_player)
    else
        autowallvar3 = false
    end
end

client.set_event_callback("run_command", on_run_command)

--silent aim if under fov

function run_cmd()
    local state = table_contains(ui.get(silentmulti), "Silent aim if in fov")
    if not state and not ui.get(silentbuttonenable, true) then
        silentvar2 = false
        return
    end
    local local_player = entity_get_local_player()

    local pitch, yaw = client_camera_angles()
    local lx, ly, lz = entity_get_prop(local_player, "m_vecOrigin")

    local nearest_player, nearest_player_fov = get_closest_player_to_crosshair(lx, ly, lz, pitch, yaw)

    if nearest_player ~= nil and nearest_player_fov <= ui.get(silentfovslider) then
        silentvar2 = true
    else
        silentvar2 = false
    end
end

client.set_event_callback("run_command", run_cmd)

--aw selected player

selectedplayer = ui.reference("players", "players", "player list")
player_list = ui.reference("PLAYERS", "Players", "Player list")
autowallplayer = { }

ui.set_callback(player_list, function()
    ui.set(autowallplayerbutton, autowallplayer[ui.get(player_list)] or false)
end)

ui.set_callback(autowallplayerbutton, function()
    local plist = ui.get(player_list)
    if plist then
        autowallplayer[plist] = ui.get(autowallplayerbutton)
    end
end)

client.set_event_callback("paint", function()
    local autowallplayer = table_contains(ui.get(auto_autowall), "Autowall specific players")
    -- Get the aimbots maximum fov so we can determine if a player is within that range
    local maximum_fov = ui.get(maximum_fov_ref)
    local local_player = entity_get_local_player()

    -- Get the local players origin, pitch, and yaw so that we can calculate our FOV to enemies
    local pitch, yaw = client_camera_angles()
    local lx, ly, lz = entity_get_prop(local_player, "m_vecOrigin")

    -- Get the nearest player to our crosshair, and the fov to that player so we can determine if they are in the aimbots range
    local nearest_player, nearest_player_fov = get_closest_player_to_crosshair(lx, ly, lz, pitch, yaw)

    -- Get our view offset and add it to our origin so that we can trace from our eye position
    local view_offset = entity_get_prop(local_player, "m_vecViewOffset[2]")
    local lz = lz + view_offset

    if ui.get(autowallplayerbutton, true) and autowallplayer and ui.get(autowallbutton, true) and nearest_player_fov <= maximum_fov then
        autowallvar5 = true
    else
        autowallvar5 = false
    end
end)

client.set_event_callback("player_connect_full", function(c)
    if client.userid_to_entindex(c) == entity.get_local_player() then
        autowallplayer = { }
    end
end)

--autowall if was visible

local function ifvisableaw()
    local wasvisible = table_contains(ui.get(auto_autowall), "Autowall if was visible")
    if wasvisible and ui.get(autowallbutton, true) then
    else
        return
    end
    local enemy_players = entity_get_players(true)
    --check if are found, else sets fov to min
    if #enemy_players ~= 0 then
        f_var_int_old_closest_enemy = f_var_int_new_closest_enemy

        local own_x, own_y, own_z = client_eye_position()
        local own_pitch, own_yaw = client_camera_angles()
        f_var_int_new_closest_enemy = nil
        f_var_float_closest_mouse_distance_to_enemy = 720

        for i = 1, #enemy_players do
            local enemy = enemy_players[i]
            local enemy_x, enemy_y, enemy_z = entity_hitbox_position(enemy, 0)

            local x = enemy_x - own_x
            local y = enemy_y - own_y
            local z = enemy_z - own_z
            --needed yaw/pitch to face the enemy
            local yaw = ((math_atan2(y, x) * 180 / math_pi))
            local pitch = -(math_atan2(z, math_sqrt(math_pow(x, 2) + math_pow(y, 2))) * 180 / math_pi)

            local yaw_dif = math_abs(own_yaw % 360 - yaw % 360) % 360
            local pitch_dif = math_abs(own_pitch - pitch) % 360

            if yaw_dif > 180 then
                yaw_dif = 360 - yaw_dif
            end

            local real_dif = math_sqrt(math_pow(yaw_dif, 2) + math_pow(pitch_dif, 2))

            if (f_var_float_closest_mouse_distance_to_enemy > real_dif) and (not var_dynamicfov_bool_ignore_out_of_of or (real_dif < var_dynamicfov_int_max)) then
                f_var_float_closest_mouse_distance_to_enemy = real_dif
                f_var_int_new_closest_enemy = enemy
            end

        end
    end
end

local f_var_autowall_last_time_spotted = 0

local function awifwasvisible()
    local wasvisible = table_contains(ui.get(auto_autowall), "Autowall if was visible")
    if wasvisible and ui.get(autowallbutton, true) then
    else
        return
    end
    local aw_result = false
    local vis_check = 0

    if not aw_result and f_var_bool_new_in_fov then
        vis_check = -1
        --client_log('-1')
        if var_autowall_bool_vischeck_beta then
            --client_log('0')
            if var_autowall_bool_vischeck_closest then
                --client_log('1')
                local health = entity_get_prop(f_var_int_new_closest_enemy, "m_iHealth")
                if health ~= nil and health > 0 then
                    --client_log('2')
                    i = f_var_int_new_closest_enemy
                    if level_0_table[i] ~= nil and not aw_result then
                        --client_log('3')
                        for j = 1, #level_0_table[i] do
                            if level_0_table[i][j] ~= nil and not aw_result then
                                --client_log('4')
                                --k starts as 2 to skip the time thing
                                for k = 2, #level_0_table[i][j] do
                                    if not aw_result then
                                        --client_log('5')
                                        local x, y, z = level_0_table[i][j][k][1], level_0_table[i][j][k][2], level_0_table[i][j][k][3]
                                        if client_visible(x, y, z) then
                                            --client_log('6')
                                            aw_result = true
                                            vis_check = 1
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            else
            end
        end
    end

    if not aw_result then
        if var_autowall_bool_vischeck_beta then
            --client_log('0')
            if var_autowall_bool_vischeck_closest then
                --client_log('1')
                local health = entity_get_prop(f_var_int_new_closest_enemy, "m_iHealth")
                if health ~= nil and health > 0 then
                    --client_log('2')
                    i = f_var_int_new_closest_enemy
                    if level_0_table[i] ~= nil and not aw_result then
                        --client_log('3')
                        for j = 1, #level_0_table[i] do
                            if level_0_table[i][j] ~= nil and not aw_result then
                                --client_log('4')
                                --k starts as 2 to skip the time thing
                                for k = 2, #level_0_table[i][j] do
                                    if not aw_result then
                                        --client_log('5')
                                        local x, y, z = level_0_table[i][j][k][1], level_0_table[i][j][k][2], level_0_table[i][j][k][3]
                                        if client_visible(x, y, z) then
                                            --client_log('6')
                                            vis_check = 1
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            else
                for i = 1, #level_0_table do
                    --client_log(' a', i)
                    if level_0_table[i] ~= nil and not aw_result then
                        --client_log(' a', false)
                        local health = entity_get_prop(i, "m_iHealth")
                        if health ~= nil and health > 0 then
                            --client_log(' a', true)
                            for j = 1, #level_0_table[i] do
                                if level_0_table[i][j] ~= nil and not aw_result then
                                    --client_log(' a', false)
                                    --k starts as 2 to skip the time thing
                                    for k = 2, #level_0_table[i][j] do
                                        if not aw_result then
                                            --client_log(' a', true)
                                            local x, y, z = level_0_table[i][j][k][1], level_0_table[i][j][k][2], level_0_table[i][j][k][3]
                                            if client_visible(x, y, z) then
                                                --client_log(' a', false)
                                                vis_check = 1
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        else
            if vis_check == 0 then
                if (f_var_int_new_closest_enemy ~= nil) then
                    local health = entity_get_prop(f_var_int_new_closest_enemy, "m_iHealth")
                    if health ~= nil and health > 0 then
                        for i = 1, 18 do
                            local x, y, z = entity_hitbox_position(f_var_int_new_closest_enemy, i)
                            if client_visible(x, y, z) then
                                vis_check = 1
                            end
                        end
                    end
                end
            end
        end
        if vis_check == 1 then
            f_var_autowall_last_time_spotted = globals_realtime()
        end
        if (vis_check ~= 1) and (globals_realtime() - f_var_autowall_last_time_spotted < ui.get(_autowall_mode_auto_trigger_delay) / 1000) then
            aw_result = true
        end
    end

    autowallvar6 = aw_result
end
local function on_paint()
    ifvisableaw()
    awifwasvisible()
end
client.set_event_callback('paint', on_paint)

----------------------- Autowall Handler
function AWHandler()
    if ui.get(autowallbutton, true) then
    else
        return
    end
    if autowallvar1 or autowallvar2 or autowallvar3 or autowallvar4 or autowallvar5 or autowallvar6 then

        ui.set(autowall, true)

    else

        ui.set(autowall, false)

    end

end
client.set_event_callback("paint", AWHandler)
-----------------------

----------------------- Silent aim handler
function SilentHandler()
    if ui.get(silentbuttonenable, true) then
    else
        return
    end
    if silentvar1 or silentvar2 or silentvar3 or silentvar4 or silentvar5 then

        ui.set(silent, true)

    else

        ui.set(silent, false)

    end

end
client.set_event_callback("paint", SilentHandler)

-----------------------
--menu call
local function set_visible()
    local tagenable = ui.get(hooktag_enabled)

    -----------------------------SILENT REF
    local silentenable = ui.get(silentbuttonenable)
    local under = table_contains(ui.get(silentmulti), "Silent aim if in fov")
    local key = table_contains(ui.get(silentmulti), "Silent aim on key")
    local distance = table_contains(ui.get(silentmulti), "Silent aim in distance")
    -----------------------------AUTOWALL REF
    local autowallenable = ui.get(autowallbutton)
    local transparent = table_contains(ui.get(auto_autowall), "Transparent props")
    local reticle = table_contains(ui.get(auto_autowall), "Penetration reticle")
    local dynamic = table_contains(ui.get(auto_autowall), "Dynamic autowall FOV")
    local shotme = table_contains(ui.get(auto_autowall), "Autowall if shot me")
    local edge = table_contains(ui.get(auto_autowall), "Edge autowall")
    local dmg = table_contains(ui.get(auto_autowall), "Min dmg override")
    local autowallplayer = table_contains(ui.get(auto_autowall), "Autowall specific players")
    local edgeawtype = ui.get(edgeautowalltype)
    local wasvisible = table_contains(ui.get(auto_autowall), "Autowall if was visible")
    -----------------------------INDICATORS REF
    local indicate = ui.get(indicate_enable)
    local indicateselet = ui.get(indicate_on)
    -----------------------------TRIGGERMAG REF
    local triggerenable = ui.get(tm_cb)
    local triggerselect = ui.get(typeselect)
    -----------------------------DYNAMIC FOV REF
    local fovenable = ui.get(dynamicfov_enable)
    local fovselect = ui.get(dynamicfov_select)
    local weaponselect = ui.get(dynamicfov_weapons)
    -----------------------------RESOLVER REF
    local resolverenable = ui.get(overridebutton)
    local solverselect = ui.get(resolverselect)
    -----------------------------FAKELAG REF
    local flenable = ui.get(flcheckbox)
    local legitfl = table_contains(ui.get(flmulti), "Fakelag presets")
    local flwmenable = table_contains(ui.get(flmulti), "Custom fake lag while moving")
    local flenabler = ui.get(enablecfl)
    local flcomb = ui.get(enablecflcombo)
    local legitflm = ui.get(legitflmode)
    -----------------------------FLAGS REF
    local flagenable = ui.get(flag_enable)
    -----------------------------KILLSAY REF
    local killenable = ui.get(talkshitenable)
    local killtype = ui.get(talkshittype)
    ----------------------------------------------------------------------
    ----------------------------------------------------------------------
    ----------------------------------------------------------------------SILENT AIM
    ----------------------------------------------------------------------
    ----------------------------------------------------------------------
    ui.set_visible(silentmulti, silentenable)
    ui.set_visible(silentfovslider, silentenable and under)
    ui.set_visible(silentkey, silentenable and key)
    ui.set_visible(silentdistance, silentenable and distance)
    ui.set_visible(distancecircle, silentenable and distance)
    ----------------------------------------------------------------------AUTOWALL
    ui.set_visible(auto_autowall, autowallenable)
    ui.set_visible(autowalltoggle, autowallenable)
    ui.set_visible(slider_trans, autowallenable and transparent)
    ui.set_visible(dynamicfov_minaw, autowallenable and dynamic)
    ui.set_visible(dynamicfov_maxaw, autowallenable and dynamic)
    ui.set_visible(dynamicfov_auto_factoraw, autowallenable and dynamic)
    ui.set_visible(autodely, autowallenable and shotme)
    ui.set_visible(beforedelay, autowallenable and shotme)
    ui.set_visible(autowalldmg, autowallenable and dmg)
    ui.set_visible(legit_pen_threshold_ref, autowallenable and edge)
    ui.set_visible(edgeautowalltype, autowallenable and edge)
    ui.set_visible(edgeautowallbutton, autowallenable and edge and edgeawtype == "Selected players")
    ui.set_visible(autowallplayerbutton, autowallenable and autowallplayer)
    ui.set_visible(_autowall_mode_auto_trigger_delay, autowallenable and wasvisible)
    ----------------------------------------------------------------------INDICATORS
    ui.set_visible(indicate_on, indicate)
    ui.set_visible(indicate_select, indicate)
    ui.set_visible(indicate_color, indicate)
    ui.set_visible(dynamicfov_minaw, autowallenable and dynamic)
    ui.set_visible(dynamicfov_maxaw, autowallenable and dynamic)
    ui.set_visible(dynamicfov_auto_factoraw, autowallenable and dynamic)
    ui.set_visible(autodely, autowallenable and shotme)
    ui.set_visible(autowalldmg, autowallenable and dmg)
    ui.set_visible(indicateposition, indicateselet == "Default" and indicate)
    ----------------------------------------------------------------------TRIGGERMAG
    ui.set_visible(typeselect, triggerenable)
    ui.set_visible(triggermagnet, triggerenable)
    ui.set_visible(triggerdmg, triggerenable and triggerselect == "Advanced")
    ui.set_visible(triggerhtc, triggerenable and triggerselect == "Advanced")
    ----------------------------------------------------------------------DYNAMIC FOV
    ui.set_visible(dynamicfov_select, fovenable)
    ui.set_visible(dynamicfov_min, fovenable and fovselect == "Default")
    ui.set_visible(dynamicfov_max, fovenable and fovselect == "Default")
    ui.set_visible(dynamicfov_auto_factor, fovenable)
    ui.set_visible(dynamicfov_weapons, fovenable and fovselect == "Adaptive weapon dynamic FOV")
    ui.set_visible(dynamicfov_minpistol, fovenable and fovselect == "Adaptive weapon dynamic FOV" and weaponselect == "Pistols")
    ui.set_visible(dynamicfov_maxpistol, fovenable and fovselect == "Adaptive weapon dynamic FOV" and weaponselect == "Pistols")
    ui.set_visible(dynamicfov_minrifle, fovenable and fovselect == "Adaptive weapon dynamic FOV" and weaponselect == "Rifles")
    ui.set_visible(dynamicfov_maxrifle, fovenable and fovselect == "Adaptive weapon dynamic FOV" and weaponselect == "Rifles")
    ui.set_visible(dynamicfov_minscope, fovenable and fovselect == "Adaptive weapon dynamic FOV" and weaponselect == "Awp/scout/auto")
    ui.set_visible(dynamicfov_maxscope, fovenable and fovselect == "Adaptive weapon dynamic FOV" and weaponselect == "Awp/scout/auto")
    ui.set_visible(dynamicfov_minother, fovenable and fovselect == "Adaptive weapon dynamic FOV" and weaponselect == "Smg/other")
    ui.set_visible(dynamicfov_maxother, fovenable and fovselect == "Adaptive weapon dynamic FOV" and weaponselect == "Smg/other")
    ----------------------------------------------------------------------RESOLVER
    ui.set_visible(resolverselect, resolverenable)
    ui.set_visible(overridekey, resolverenable and solverselect == "Override")
    ui.set_visible(oppositeenable, resolverenable and solverselect == "Opposite resolver")
    ----------------------------------------------------------------------FLAGS
    ui.set_visible(flag_select, flagenable)
    ui.set_visible(flag_color, flagenable)
    ----------------------------------------------------------------------KILLSAY
    ui.set_visible(talkshittype, killenable)
    ui.set_visible(talkshittext, killenable and killtype == "Custom")
    ----------------------------------------------------------------------FAKELAG
    ui.set_visible(flmulti, flenable)
    ui.set_visible(legitflmode, legitfl and flenable)
    ui.set_visible(enablecfl, flenable and flwmenable)
    ui.set_visible(enablecflcombo, flenabler and flenable and flwmenable)
    ui.set_visible(slowvariance, flenabler and flcomb == "Slow walk" and flenable and flwmenable)
    ui.set_visible(slowlimit, flenabler and flcomb == "Slow walk" and flenable and flwmenable)
    ui.set_visible(slowamount, flenabler and flcomb == "Slow walk" and flenable and flwmenable)
    ui.set_visible(movevariance, flenabler and flcomb == "Moving" and flenable and flwmenable)
    ui.set_visible(movelimit, flenabler and flcomb == "Moving" and flenable and flwmenable)
    ui.set_visible(moveamount, flenabler and flcomb == "Moving" and flenable and flwmenable)
    ui.set_visible(standvariance, flenabler and flcomb == "Standing" and flenable and flwmenable)
    ui.set_visible(standlimit, flenabler and flcomb == "Standing" and flenable and flwmenable)
    ui.set_visible(standamount, flenabler and flcomb == "Standing" and flenable and flwmenable)
    ui.set_visible(jumpvariance, flenabler and flcomb == "Jumping" and flenable and flwmenable)
    ui.set_visible(jumplimit, flenabler and flcomb == "Jumping" and flenable and flwmenable)
    ui.set_visible(jumpamount, flenabler and flcomb == "Jumping" and flenable and flwmenable)

    if legitflm == "On peek" and flenable and legitfl then
        ui.set(fakelag_enable, true)
        ui.set(fakelag_key, "Always on")
    elseif legitflm == "On peek & visibility" and flenable and legitfl then
        ui.set(fakelag_enable, true)
        ui.set(fakelag_key, "Always on")
    elseif legitflm == "Always on" and flenable and legitfl then
        ui.set(fakelag_enable, true)
        ui.set(fakelag_key, "Always on")
    elseif legitflm == "While targeted" and flenable and legitfl then
        ui.set(fakelag_enable, false)
        ui.set(fakelag_key, "Always on")
    elseif not legitfl then
        ui.set(fakelag_enable, false)
        ui.set(fakelag_key, "On hotkey")
    elseif not flenable then
        ui.set(fakelag_enable, false)
        ui.set(fakelag_key, "On hotkey")
    end

end
set_visible()
ui.set_callback(flcheckbox, set_visible)
ui.set_callback(flmulti, set_visible)
ui.set_callback(legitflmode, set_visible)
ui.set_callback(enablecflcombo, set_visible)
ui.set_callback(enablecfl, set_visible)
ui.set_callback(overridebutton, set_visible)
ui.set_callback(resolverselect, set_visible)
ui.set_callback(dynamicfov_enable, set_visible)
ui.set_callback(dynamicfov_select, set_visible)
ui.set_callback(dynamicfov_weapons, set_visible)
ui.set_callback(tm_cb, set_visible)
ui.set_callback(typeselect, set_visible)
ui.set_callback(indicate_enable, set_visible)
ui.set_callback(indicate_on, set_visible)
ui.set_callback(auto_autowall, set_visible)
ui.set_callback(autowallbutton, set_visible)
ui.set_callback(silentbuttonenable, set_visible)
ui.set_callback(silentmulti, set_visible)
ui.set_callback(flag_enable, set_visible)
ui.set_callback(talkshitenable, set_visible)
ui.set_callback(talkshittype, set_visible)
ui.set_callback(edgeautowalltype, set_visible)
ui.set_callback(hooktag_enabled, set_visible)

--override key
local canManual
local target
local targetx
local targety
local targetz
local screenposx
local screenposy

function reset_target(r)
    --not working for some reason, useless atm
    if ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" then
    else
        return
    end
    client.log(r)
    ui.set(selectedplayer, r)
    ui.set(forcebody, false)
    ui.set(body_slider, 0)
    ui.set(applyall, true)

end
function setbodyyaw()
    if ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" then
    else
        return
    end
    --client.delay_call(3, reset_target(selectedplayer))
    --client.delay_call(5, reset_all)  works?

    if ui.get(body_slider) == 0 and canManual == true then
        ui.set(forcebody, true)
        ui.set(body_slider, 60)
        ui.set(applyall, true)
        canManual = false
    end

    if ui.get(body_slider) == 60 and canManual == true then
        ui.set(forcebody, true)
        ui.set(body_slider, -60)
        ui.set(applyall, true)
        canManual = false
    end

    if ui.get(body_slider) == -60 and canManual == true then
        ui.set(forcebody, false)
        ui.set(body_slider, 0)
        ui.set(applyall, true)
        canManual = false
    end


end
function on_paint()
    if ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" then
    else
        return
    end
    if ui.get(overridekey) then

        if canManual == true then

            setbodyyaw()
            canManual = false

        end


    else

        canManual = true

    end

end

client.set_event_callback("paint", on_paint)

--bruteforce indicator/resolver indicator
aacorrect = ui.reference("RAGE", "OTHER", "Anti-aim correction")
playerlistplayers = ui.reference("PLAYERS", "Players", "Player list")
bruteforce_ents = {  }

client.set_event_callback("run_command", function(c)
    local overrideselect = table_contains(ui.get(flag_select), "Override")
    if ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" and ui.get(flag_enable, true) and overrideselect then
    else
        return
    end
    if not ui.is_menu_open() then
        bruteforce_ents = { }
        client.update_player_list()
        for _, v in pairs(entity.get_players(true)) do
            if ui.get(body_slider) == -60 or ui.get(body_slider) == 60 then
                table.insert(bruteforce_ents, v)
                entity.set_prop(v, "m_flDetectedByEnemySensorTime")
            else
                entity.set_prop(v, "m_flDetectedByEnemySensorTime", 0)
            end
        end
    end
end)

client.set_event_callback("paint", function()
    local overrideselect = table_contains(ui.get(flag_select), "Override")
    if ui.get(overridebutton, true) and ui.get(resolverselect) == "Override" and ui.get(flag_enable, true) and overrideselect then
    else
        return
    end
    local r, g, b, a = ui.get(flag_color)
    for _, v in pairs(bruteforce_ents) do
        local bounding_box = { entity.get_bounding_box(v) }
        if #bounding_box == 5 and bounding_box[5] ~= 0 then
            local center = bounding_box[1] + (bounding_box[3] - bounding_box[1]) / 2
            if ui.get(body_slider) == 60 then
                renderer.text(center, bounding_box[2] - 18, r, g, b, a * bounding_box[5], "bc", 0, "RIGHT")
            elseif ui.get(body_slider) == -60 then
                renderer.text(center, bounding_box[2] - 18, r, g, b, a * bounding_box[5], "bc", 0, "LEFT")
            end
        end
    end
end)

--legitaa resolverenable
selectedplayer = ui.reference("players", "players", "player list")
forcebody = ui.reference("players", "adjustments", "force body yaw")
resetlist = ui.reference("players", "players", "reset all")

player_list = ui.reference("PLAYERS", "Players", "Player list")
force_body = ui.reference("PLAYERS", "Adjustments", "Force body yaw")
body_slider = ui.reference("PLAYERS", "Adjustments", "Force body yaw value")
saved_enable = { }

ui.set_callback(player_list, function()
    ui.set(oppositeenable, saved_enable[ui.get(player_list)] or false)
end)

ui.set_callback(oppositeenable, function()
    local plist = ui.get(player_list)
    if plist then
        saved_enable[plist] = ui.get(oppositeenable)
    end
end)

function normalize(angle)
    while angle > 180 do
        angle = angle - 360
    end
    while angle < -180 do
        angle = angle + 360
    end

    return angle
end

client.set_event_callback("run_command", function()
    if ui.get(overridebutton, true) and ui.get(resolverselect) == "Opposite resolver" then
    else
        return
    end
    if not ui.is_menu_open() then
        client.update_player_list()
        for k, v in pairs(saved_enable) do
            if entity.is_enemy(k) then
                ui.set(player_list, k)
                if v then
                    local velocity = { entity.get_prop(k, "m_vecVelocity") }
                    if 1 > math.abs(math.sqrt(velocity[1] ^ 2 + velocity[2] ^ 2)) then
                        ui.set(force_body, true)
                        ui.set(body_slider, -math.min(60, math.max(-60, normalize(entity.get_prop(k, "m_angEyeAngles[1]") - entity.get_prop(k, "m_flLowerBodyYawTarget")))))
                    end
                else
                    ui.set(force_body, false)
                    ui.set(body_slider, 0)
                end
            end
        end
    end
end)

client.set_event_callback("player_connect_full", function(c)
    if client.userid_to_entindex(c) == entity.get_local_player() then
        saved_enable = { }
    end
end)

function getNearestEnemy()
    if not ui.is_menu_open() then
    else
        return
    end
    if ui.get(overridebutton, true) and ui.get(resolverselect) == "Opposite resolver" or autowallplayer and ui.get(autowallbutton, true) or ui.get(autowallbutton, true) and ui.get(edgeautowalltype) == "Selected players" and edgeautowall then
    else
        return
    end
    local enemy_players = entity.get_players(true)
    if #enemy_players ~= 0 then
        local own_x, own_y, own_z = client.eye_position()
        local own_pitch, own_yaw = client.camera_angles()
        local closest_enemy = nil
        local closest_distance = 999999999

        for i = 1, #enemy_players do
            local enemy = enemy_players[i]
            local enemy_x, enemy_y, enemy_z = entity.hitbox_position(enemy, 0)

            local x = enemy_x - own_x
            local y = enemy_y - own_y
            local z = enemy_z - own_z

            local yaw = ((math.atan2(y, x) * 180 / math.pi))
            local pitch = -(math.atan2(z, math.sqrt(math.pow(x, 2) + math.pow(y, 2))) * 180 / math.pi)

            local yaw_dif = math.abs(own_yaw % 360 - yaw % 360) % 360
            local pitch_dif = math.abs(own_pitch - pitch) % 360

            if yaw_dif > 180 then
                yaw_dif = 360 - yaw_dif
            end
            local real_dif = math.sqrt(math.pow(yaw_dif, 2) + math.pow(pitch_dif, 2))

            if closest_distance > real_dif then
                closest_distance = real_dif
                closest_enemy = enemy
            end
        end

        if closest_enemy ~= nil then
            return closest_enemy, closest_distance
        end
    end

    return nil, nil
end

function setplist()
    local autowallplayer = table_contains(ui.get(auto_autowall), "Autowall specific players")
    local edgeautowall = table_contains(ui.get(auto_autowall), "Edge autowall")
    if ui.get(overridebutton, true) and ui.get(resolverselect) == "Opposite resolver" or autowallplayer and ui.get(autowallbutton, true) or ui.get(autowallbutton, true) and ui.get(edgeautowalltype) == "Selected players" and edgeautowall then
    else
        return
    end
    -- Get the aimbots maximum fov so we can determine if a player is within that range
    local maximum_fov = ui.get(maximum_fov_ref)
    local local_player = entity_get_local_player()

    -- Get the local players origin, pitch, and yaw so that we can calculate our FOV to enemies
    local pitch, yaw = client_camera_angles()
    local lx, ly, lz = entity_get_prop(local_player, "m_vecOrigin")

    -- Get the nearest player to our crosshair, and the fov to that player so we can determine if they are in the aimbots range
    local nearest_player, nearest_player_fov = get_closest_player_to_crosshair(lx, ly, lz, pitch, yaw)

    -- Get our view offset and add it to our origin so that we can trace from our eye position
    local view_offset = entity_get_prop(local_player, "m_vecViewOffset[2]")
    local lz = lz + view_offset

    if nearest_player_fov <= 170 then
        ui.set(selectedplayer, getNearestEnemy())
        return
    end
end

client.set_event_callback("paint", setplist)

function setaa()
    if ui.get(overridebutton, true) and ui.get(resolverselect) == "Opposite resolver" then
    else
        return
    end
    if ui.get(oppositeenable, true) then
        ui.set(aacorrect, false)
    else
        ui.set(aacorrect, true)
    end
end

client.set_event_callback("paint", setaa)

ui.set_visible(adaptive_options2, false)
ui.set_visible(adaptive_config2, false)


--fakelag triggers

client.set_event_callback("setup_command", function(cms)
    if ui.get(flcheckbox, true) then
    else
        return
    end
    local flwmenable = table_contains(ui.get(flmulti), "Custom fake lag while moving")
    if flwmenable and ui.get(enablecfl, true) and ui.get(flcheckbox, true) then
    else
        return
    end
    ui.set(variance, cms.sidemove == 0 and cms.forwardmove == 0 and ui.get(standvariance) or ui.get(movevariance))
    ui.set(fakelag_limit, cms.sidemove == 0 and cms.forwardmove == 0 and ui.get(standlimit) or ui.get(movelimit))
    ui.set(amount, cms.sidemove == 0 and cms.forwardmove == 0 and ui.get(standamount) or ui.get(moveamount))
end)
local function get_velocity(ent)
    local flwmenable = table_contains(ui.get(flmulti), "Custom fake lag while moving")
    if ui.get(flcheckbox, true) and flwmenable then
    else
        return
    end

    local vecVelx, vecVely, vecVelz = entity.get_prop(ent, "m_vecVelocity")

    if vecVelx == nil and vecVely == nil and vecVelz == nil then
        return 0
    end

    return math.sqrt(vecVelx * vecVelx + vecVely * vecVely + vecVelz * vecVelz);
end

local function eventhandler_paint(ctx)
    local flwmenable = table_contains(ui.get(flmulti), "Custom fake lag while moving")
    local localplayer = entity.get_local_player()
    if flwmenable and ui.get(enablecfl, true) and ui.get(flcheckbox, true) and not localplayer == nil then
    else
        return
    end
    local flags = get_prop(localplayer, "m_fFlags");
    local onground = bit.band(flags, 1);
    if onground == 0 then
        ui.set(variance, ui.get(jumpvariance))
        ui.set(fakelag_limit, ui.get(jumplimit))
        ui.set(amount, ui.get(jumpamount))
    end
end

client.set_event_callback("paint", eventhandler_paint)

--custom aa while moving

function aaslowwalk_menu()
    if ui.get(enableaawm, true) and ui.get(hotkey_reference) then
    else
        return
    end
    ui.set(LegitAABreaker, ui.get(slowmode))
end
client.set_event_callback("paint", aaslowwalk_menu)
client.set_event_callback("setup_command", function(cme)
    if ui.get(hotkey_reference) or ui.get(ref_fakeduck) then
        return
    end
    if ui.get(enableaawm, true) then
        ui.set(LegitAABreaker, cme.sidemove == 0 and cme.forwardmove == 0 and ui.get(standmode) or ui.get(movemode))
    end
end)

--killsay

userid_to_entindex = client.userid_to_entindex
get_player_name = entity.get_player_name
get_local_player = entity.get_local_player
is_enemy = entity.is_enemy
local autowalltable = { 'hh gotcha!', '¯\\_(ツ)_/¯', 'robot machine ┌( ಠ_ಠ)┘', }
local killsaytable = { 'oof', 'you didnt pay,. right?', 'losing in 2020 couldnt be me', 'why u mad?', 'nice try, maybe next time', 'newcomer upset', 'loser', 'nt bruh', 'sit dog', }
function get_table_length(data)
    if type(data) ~= 'table' then
        return 0
    end

    local count = 0
    for _ in pairs(data) do
        count = count + 1
    end

    return count
end

num_quotes_aw = get_table_length(autowalltable)
num_quotes_kill = get_table_length(killsaytable)

function on_player_death(e)
    if ui.get(talkshitenable, true) then
    else
        return
    end

    local random = client_random_int(1, 4)
    local victim_userid, attacker_userid = e.userid, e.attacker
    if victim_userid == nil or attacker_userid == nil then
        return
    end

    local victim_entindex = userid_to_entindex(victim_userid)
    local attacker_entindex = userid_to_entindex(attacker_userid)
    if attacker_entindex == get_local_player() and is_enemy(victim_entindex) then
    else
        return
    end

    if e.penetrated > 0 and ui.get(talkshittype) == "Basic kill says" then
        local commandaw = 'say ' .. autowalltable[math.random(num_quotes_aw)]
        client.exec(commandaw)
    elseif ui.get(talkshittype) == "Basic kill says" then
        local commandkill = 'say ' .. killsaytable[math.random(num_quotes_kill)]
        client.exec(commandkill)
    end

    if ui.get(talkshittype) == "Custom" then
        client.exec("say ", ui.get(talkshittext))
    end
end

client.set_event_callback('player_death', on_player_death)

function thirdp()
    if ui.get(forcethirdpkey) then
        ui.set(thirdpersondead, true)
    else
        ui.set(thirdpersondead, false)
    end
end

client.set_event_callback('paint', thirdp)

client.set_event_callback("round_start", function()
    autowallvar1 = false
    autowallvar2 = false
    autowallvar3 = false
    autowallvar4 = false
    autowallvar5 = false
    autowallvar6 = false
    ui.set(body_slider, 0)
    ui.set(forcebody1, false)
    ui.set(applyall, true)
    silentvar1 = false
    silentvar2 = false
    silentvar3 = false
    silentvar4 = false
    silentvar5 = false
end)

client.set_event_callback("player_death", function(e)
    if client.userid_to_entindex(e.attacker) == entity.get_local_player() and client.userid_to_entindex(e.userid) ~= entity.get_local_player() and not entity.is_enemy(client.userid_to_entindex(e.userid)) then
        client.exec("say 1 retard")
    end
end)
local ui_get = ui.get
local client_userid_to_entindex = client.userid_to_entindex
local entity_get_player_name = entity.get_player_name
local client_log = client.log
local vote_option = { }
local team_name = ""
local menu_view_votes = ui.new_checkbox("VISUALS", "other esp", "View Votes")

local function on_vote_options(event)
	vote_option[0] = event.option1
	vote_option[1] = event.option2
	vote_option[2] = event.option3
	vote_option[3] = event.option4
	vote_option[4] = event.option5
end

local function on_vote_cast(event)
	local userid = event.entityid
	if userid == nil then
		return
	end

	if event.team == 3 then
		team_name = "CT"
	elseif event.team == 2 then
		team_name = "T"
	else
		team_name = "Spectator"
	end

	if ui_get(menu_view_votes) then
		local player_name = entity_get_player_name(userid)		
		client_log(player_name, " voted ", vote_option[event.vote_option], " on ", team_name)
	end
end
client.set_event_callback("vote_options", on_vote_options)
client.set_event_callback("vote_cast", on_vote_cast)

local spambuttonbutton =  ui.new_button("MISC", "Miscellaneous", "HELLBANIANZ > ALL", function()
    local local_player = entity.get_local_player()
    if not name_saved then
        original_name = entity.get_player_name(local_player)
        name_saved = true
    end
    ui.set(nameSteal, true)
    client.set_cvar("name", " HELLBANIANZ > ALL")
    client.delay_call(0.15, client.set_cvar, "name", "HELLBANIANZ > ALL")
    client.delay_call(0.3, client.set_cvar, "name", "HELLBANIANZ > ALL")
    client.delay_call(0.45, client.set_cvar, "name", "HELLBANIANZ > ALL")
    client.delay_call(0.6, client.set_cvar, "name", original_name)
    if original_name == entity.get_player_name(local_player) then
        name_saved = false
    end
end)
local name_saved = false
nameSteal = ui.reference("Misc", "Miscellaneous", "Steal player name")
namespam_box = ui.new_checkbox("MISC", "Miscellaneous", "[SH] Name spam")

client.set_event_callback("paint", function()
    usertxtx, usertxty = renderer.measure_text("bd", "The quick brown fox jumps over the lazy dog")
    renderer.text(6, 6, 0, 000, 000, 0, "d", 0, "HELLBANIANZ")
end)

local w, h = client.screen_size()
local center = { w/2, h/2 }
local offset = 0
local r, g, b, a
local indicators = {}

local menu = {
    enabled = ui.new_checkbox("RAGE", "Other", "Crosshair indicator"),
    s_offset = ui.new_slider("RAGE", "Other", "\nHitlog offset", -500, 500, 64, true, "px"),
    extra = ui.new_checkbox("RAGE", "Other", "Extra indicators"),
    color = ui.new_color_picker("RAGE", "Other", "Extra indicator color", 0, 255, 0, 255)
}

local states = {
    { { ui.reference("AA", "Anti-aimbot angles", "Freestanding") }, "FREESTANDING" },
    { { ui.reference("AA", "Other", "On shot anti-aim") }, "ONSHOT" },
    { { ui.reference("RAGE", "Other", "Force body aim") }, "FORCE BAIM" },
    { { ui.reference("RAGE", "Aimbot", "Force safe point") }, "SAFEPOINT" },
    { { ui.reference("AA", "Other", "Fake peek") }, "FAKE PEEK"},
}

local function bool_to_number(value)
    return value and 1 or 0
end

local function on_indicator(i)
    table.insert(indicators, i)
end

local function on_paint()
    for i = 1, #indicators do 
        local cur_i = indicators[i]
        local y = (offset >= 0) and (center[2] - offset - (i * 12)) or (center[2] - offset + (i * 12))
        renderer.text(center[1], y, cur_i.r, cur_i.g, cur_i.b, cur_i.a, "cb", 0, cur_i.text)
    end

    if ui.get(menu.extra) then
        local total_states = #indicators
        for i = 1, #states do 
            local active = 0
            local cur_check = states[i][1]

            for n = 1, #cur_check do 
                local value = ui.get(cur_check[n])
                local type = type(value)
                if type == "boolean" then
                    active = active + bool_to_number(value)
                elseif type == "table" and value[1] ~= nil then 
                    active = active + 1
                end
            end
            
            if active >= #cur_check then
                total_states = total_states + 1
                local y = (offset >= 0) and (center[2] - offset - (total_states * 12)) or (center[2] - offset + (total_states * 12))
                renderer.text(center[1], y, r, g, b, a, "cb", 0, states[i][2])
            end
        end
    end

    indicators = {}
end

local function cbx_toggle()
    local state = ui.get(menu.enabled)
    local update_callback = state and client.set_event_callback or client.unset_event_callback
    update_callback("indicator", on_indicator)
    update_callback("paint", on_paint)
    ui.set_visible(menu.extra, state)
    ui.set_visible(menu.s_offset, state)
    ui.set_visible(menu.color, state)
end

do
    ui.set_callback(menu.enabled, cbx_toggle)
    cbx_toggle()

    ui.set_callback(menu.color, function(self)
        r, g, b, a = ui.get(self)
    end)
    r, g, b, a = ui.get(menu.color)

    ui.set_callback(menu.s_offset, function(self)
        offset = ui.get(self)
    end)
    offset = ui.get(menu.s_offset)
end


local entity_is_alive = entity.is_alive
local entity_get_local_player = entity.get_local_player
local entity_is_enemy = entity.is_enemy

local client_register_esp_flag = client.register_esp_flag
client_register_esp_flag("Desync", 255, 0, 0, function(c)
    if entity_is_alive(entity_get_local_player()) and entity_is_enemy(c) then
        if plist.get(c, "Correction active") ==  true then
            plist.set(c, "High priority", true)
            return true
        else
            return false
        end
    end
end)


local main_enabled = ui.new_checkbox("RAGE", "Other", "Min Damage Indicator")
local color = ui.new_color_picker("RAGE", "Other", "Color", 255, 255, 255, 255)
local function get_MinDMG()
    local dmgMin = ui.reference("rage", "aimbot", "Minimum damage")
    local dmg = ui.get(dmgMin)
    if dmg == nil then return 0 end
     if dmg > 0 then
         return dmg
     end
     return 0
 end


client.set_event_callback("paint", function()
    local minDmg = get_MinDMG( )

    if ui.get(main_enabled) and entity.is_alive(entity.get_local_player()) then
        if(minDmg == 0) then
            return
        end
        local r, g, b, a = ui.get(color)
        local indicator = renderer.indicator(r, g, b, a , "" .. minDmg .. "")
    end
end)
